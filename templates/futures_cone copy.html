{% extends "base.html" %}

{% block title %}Data-Driven Futures Cone - AuNoo AI{% endblock %}

{% block extra_css %}
<style>
    /* Light theme styling to match base.html */
    :root {
        --primary-color: #FF69B4;
        --primary-dark: #FF1493;
        --text-color: #333;
        --container-width: 1200px;
        --spacing-md: 1rem;
        --bg-light: #f8f9fa;
        --bg-white: #ffffff;
        --border-color: #dee2e6;
    }

    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        background-color: var(--bg-light);
        color: var(--text-color);
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
    }
    
    .header {
        text-align: center;
        margin-bottom: 40px;
        animation: fadeInDown 1s ease-out;
    }
    
    .header h1 {
        font-size: 3rem;
        color: var(--primary-color);
        font-weight: bold;
        margin-bottom: 10px;
    }
    
    .header .subtitle {
        font-size: 1.4rem;
        color: var(--primary-dark);
        font-weight: 600;
        margin-bottom: 8px;
    }
    
    .header p {
        font-size: 1.1rem;
        color: #6c757d;
        max-width: 700px;
        margin: 0 auto;
    }
    
    .cone-container {
        position: relative;
        margin: 40px 0;
        height: 750px;
        background: var(--bg-white);
        border-radius: 20px;
        border: 1px solid var(--border-color);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        overflow: visible;
    }
    
    .cone-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
    
    .cone-shape {
        fill: none;
        stroke-width: 2;
    }
    
    .probable-line { stroke: rgba(0, 212, 255, 0.6); }
    .plausible-line { stroke: rgba(255, 193, 7, 0.4); }
    .possible-line { stroke: rgba(255, 107, 107, 0.3); }
    .preferable-line { stroke: rgba(78, 205, 196, 0.5); }
    
    .cone-fill {
        opacity: 0.1;
    }
    
    .probable-fill { fill: rgba(0, 212, 255, 0.1); }
    .plausible-fill { fill: rgba(255, 193, 7, 0.08); }
    .possible-fill { fill: rgba(255, 107, 107, 0.06); }
    .preferable-fill { fill: rgba(78, 205, 196, 0.08); }
    
    .timeline-axis {
        position: absolute;
        bottom: 60px;
        left: 8%;
        right: 8%;
        height: 2px;
        background: var(--border-color);
    }
    
    .timeline-labels {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 8%;
    }
    
    .timeline-marker {
        text-align: center;
        font-size: 0.9rem;
        color: #6c757d;
        position: relative;
    }
    
    .timeline-marker::before {
        content: '';
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        height: 10px;
        background: #6c757d;
    }
    
    .now-marker {
        position: absolute;
        left: 8%;
        top: 50%;
        transform: translateY(-50%);
        background: var(--primary-color);
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.9rem;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .scenario {
        position: absolute;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px solid;
        backdrop-filter: blur(10px);
        font-size: 0.8rem;
        max-width: 180px;
        min-width: 140px;
        z-index: 5;
        transform-origin: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        line-height: 1.3;
    }
    
    .scenario:hover {
        transform: scale(1.08);
        z-index: 20;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
        border-width: 3px;
    }
    
    /* Scenario styles */
    .scenario.probable {
        background: rgba(0, 212, 255, 0.1);
        border-color: #00d4ff;
        color: #0056b3;
    }
    
    .scenario.plausible {
        background: rgba(255, 193, 7, 0.1);
        border-color: #ffc107;
        color: #856404;
    }
    
    .scenario.possible {
        background: rgba(220, 53, 69, 0.1);
        border-color: #dc3545;
        color: #721c24;
    }
    
    .scenario.preferable {
        background: rgba(25, 135, 84, 0.1);
        border-color: #198754;
        color: #0f5132;
    }
    
    .scenario.wildcard {
        background: rgba(138, 43, 226, 0.1);
        border-color: #8a2be2;
        color: #4b0082;
        position: relative;
    }
    
    .scenario.wildcard::before {
        content: "âš¡";
        position: absolute;
        top: -8px;
        right: -8px;
        background: #8a2be2;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
    }
    
    .scenario-title {
        font-weight: bold;
        margin-bottom: 4px;
        line-height: 1.2;
    }
    
    .scenario-year {
        font-size: 0.75rem;
        opacity: 0.8;
    }
    
    .scenario-sentiment {
        font-size: 0.7rem;
        margin-top: 4px;
        padding: 2px 6px;
        border-radius: 3px;
        background: var(--bg-light);
        color: var(--text-color);
        display: inline-block;
        border: 1px solid var(--border-color);
    }



    /* Form styling */
    .form-control, .form-select {
        border-radius: 8px;
        border: 1px solid var(--border-color);
        padding: 0.5rem 0.75rem;
        transition: all 0.2s ease;
        background: var(--bg-white);
        color: var(--text-color);
    }

    .form-control:focus, .form-select:focus {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 0.2rem rgba(255, 105, 180, 0.25);
        background: var(--bg-white);
        color: var(--text-color);
    }

    .form-control option, .form-select option {
        background: var(--bg-white);
        color: var(--text-color);
    }

    .btn {
        border-radius: 8px;
        padding: 0.5rem 1rem;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .btn-primary {
        background: var(--primary-color);
        border-color: var(--primary-color);
    }

    .btn-primary:hover {
        background: var(--primary-dark);
        border-color: var(--primary-dark);
        transform: translateY(-1px);
    }

    .cone-labels {
        position: absolute;
        right: 10px;
        top: 20%;
        font-size: 0.8rem;
        color: #6c757d;
    }
    
    .cone-label {
        margin-bottom: 8px;
        padding: 4px 8px;
        border-radius: 4px;
        background: var(--bg-light);
        border: 1px solid var(--border-color);
    }

    .loading-spinner {
        text-align: center;
        padding: 40px;
    }
    
    .spinner-border {
        color: #FF69B4;
    }

    .modal-content {
        background: var(--bg-white);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        border-radius: 12px;
    }

    .modal-header {
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-light);
    }

    .modal-footer {
        border-top: 1px solid var(--border-color);
        background: var(--bg-light);
    }

    .modal-title {
        color: var(--primary-color);
        font-weight: 600;
    }

    .btn-close {
        color: var(--text-color);
    }

    .btn-close:hover {
        color: var(--primary-color);
    }

    /* Fix modal backdrop issues */
    .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-backdrop.show {
        opacity: 0.5;
    }

    /* Ensure modal is properly positioned but allow navbar dropdowns to work */
    .modal {
        z-index: 1055;
    }

    .modal-backdrop {
        z-index: 1050;
    }

    /* Form labels styling */
    .form-label {
        color: var(--text-color);
        font-weight: 500;
        margin-bottom: 0.5rem;
    }

    /* Custom form styling */
    #customDays {
        margin-top: 0.5rem;
    }

    /* Button styling improvements */
    .btn {
        font-weight: 500;
        border-radius: 8px;
    }

    .btn-outline-secondary {
        color: #6c757d;
        border-color: #6c757d;
    }

    .btn-outline-secondary:hover {
        background-color: #6c757d;
        border-color: #6c757d;
        color: white;
    }

    .alert {
        border-radius: 8px;
        border: none;
    }

    .alert-info {
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        color: var(--primary-dark);
        border-left: 4px solid var(--primary-color);
    }

    .alert-success {
        background: linear-gradient(135deg, #e8f5e8, #f1f8e9);
        color: #2e7d32;
        border-left: 4px solid #4caf50;
    }

    .alert-danger {
        background: linear-gradient(135deg, #ffebee, #fce4ec);
        color: #c62828;
        border-left: 4px solid #f44336;
    }

    /* Square button styling */
    .btn-square {
        width: 38px;
        height: 38px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
    }

    .btn-square:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transform: translateY(-1px);
    }

    .btn-square i {
        font-size: 14px;
        margin: 0;
    }

    /* Button divider */
    .btn-divider {
        width: 1px;
        height: 24px;
        background: #dee2e6;
        margin: 0 4px;
        align-self: center;
    }

    /* Controls container animation */
    #controlsContainer {
        transition: all 0.3s ease;
        overflow: hidden;
    }

    #controlsContainer.collapsed {
        opacity: 0;
        max-width: 0;
        margin: 0;
    }

    /* Toggle button */
    #toggleControlsBtn {
        transition: all 0.2s ease;
    }

    #toggleIcon {
        transition: transform 0.2s ease;
    }

    #toggleIcon.rotated {
        transform: rotate(180deg);
    }

    /* Hide header subtitle when collapsed */
    .header-subtitle-hidden {
        display: none !important;
    }

    /* Detailed Scenarios Grid */
    .scenarios-detail-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 30px;
        margin: 40px 0;
    }
    
    .scenario-type-column {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    
    .scenario-type-header {
        text-align: center;
        padding: 15px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 1.2rem;
        color: white;
        margin-bottom: 10px;
    }
    
    .scenario-type-header.probable { background: rgba(0, 212, 255, 0.8); }
    .scenario-type-header.plausible { background: rgba(255, 193, 7, 0.8); }
    .scenario-type-header.possible { background: rgba(220, 53, 69, 0.8); }
    .scenario-type-header.preferable { background: rgba(25, 135, 84, 0.8); }
    .scenario-type-header.wildcard { background: rgba(138, 43, 226, 0.8); }
    
    .scenario-detail-card {
        background: var(--bg-white);
        padding: 25px;
        border-radius: 15px;
        border: 2px solid;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
        position: relative;
    }
    
    .scenario-detail-card.probable { border-color: rgba(0, 212, 255, 0.6); }
    .scenario-detail-card.plausible { border-color: rgba(255, 193, 7, 0.6); }
    .scenario-detail-card.possible { border-color: rgba(220, 53, 69, 0.6); }
    .scenario-detail-card.preferable { border-color: rgba(25, 135, 84, 0.6); }
    .scenario-detail-card.wildcard { border-color: rgba(138, 43, 226, 0.6); }
    
    .scenario-detail-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
    }
    
    .scenario-detail-title {
        font-size: 1.3rem;
        font-weight: bold;
        margin-bottom: 10px;
        color: var(--primary-dark);
    }
    
    .scenario-detail-meta {
        display: flex;
        gap: 15px;
        margin-bottom: 15px;
        font-size: 0.9rem;
    }
    
    .scenario-detail-timeframe {
        background: var(--bg-light);
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .scenario-detail-type {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 500;
        text-transform: capitalize;
    }
    
    .scenario-detail-description {
        margin-bottom: 15px;
        line-height: 1.6;
        color: #555;
    }
    
    .scenario-detail-section {
        margin-bottom: 15px;
    }
    
    .scenario-detail-section h4 {
        font-size: 1rem;
        font-weight: 600;
        color: var(--primary-color);
        margin-bottom: 8px;
    }
    
    .scenario-detail-list {
        margin-left: 15px;
    }
    
    .scenario-detail-list li {
        margin-bottom: 5px;
        line-height: 1.5;
        color: #666;
    }

    /* Key Themes Grid */
    .themes-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 40px 0;
    }
    
    .theme-card {
        background: var(--bg-white);
        padding: 25px;
        border-radius: 15px;
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .theme-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        border-color: var(--primary-color);
    }
    
    .theme-title {
        font-size: 1.2rem;
        font-weight: bold;
        margin-bottom: 12px;
        color: var(--primary-color);
    }
    
    .theme-description {
        font-size: 0.95rem;
        line-height: 1.6;
        color: var(--text-color);
    }
    
    /* Legend */
    .legend {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-top: 40px;
    }
    
    .legend-item {
        background: var(--bg-white);
        padding: 20px;
        border-radius: 12px;
        border-left: 4px solid;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .legend-probable { border-color: rgba(0, 212, 255, 0.8); }
    .legend-plausible { border-color: rgba(255, 193, 7, 0.8); }
    .legend-possible { border-color: rgba(255, 107, 107, 0.8); }
    .legend-preferable { border-color: rgba(78, 205, 196, 0.8); }
    
    .legend-title {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 1.1rem;
        color: var(--primary-dark);
    }
    
    .legend-content {
        font-size: 0.9rem;
        color: #6c757d;
        line-height: 1.5;
    }

    /* Additional content section */
    .additional-content {
        margin-top: 60px;
        padding-top: 40px;
        border-top: 2px solid var(--border-color);
    }

    .content-section {
        margin-bottom: 50px;
    }

    .content-section h2 {
        color: var(--primary-color);
        font-size: 2rem;
        margin-bottom: 20px;
        text-align: center;
    }

    .content-section h3 {
        color: var(--primary-dark);
        font-size: 1.5rem;
        margin-bottom: 15px;
    }

    @keyframes fadeInDown {
        from {
            opacity: 0;
            transform: translateY(-30px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    @media (max-width: 768px) {
        .header h1 {
            font-size: 2rem;
        }
        
        .cone-container {
            height: 600px;
        }
        
        .scenario {
            max-width: 150px;
            padding: 8px 12px;
            font-size: 0.8rem;
        }
        
        .timeline-labels {
            padding: 0 5%;
        }
        
        .now-marker {
            left: 5%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div class="header">
        <h1>Futures Horizons</h1>
        <div class="subtitle" id="topicSubtitle">Configure Analysis Below</div>
        <p>AI-powered futures analysis using your article data to generate probable, plausible, possible, preferable, and wildcard scenarios</p>
    </div>
    
    <!-- Collapsible Control Bar -->
    <div class="mb-4 d-flex justify-content-center">
        <div class="d-flex align-items-center gap-2">
            <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleControlsBtn" onclick="toggleControls()" title="Toggle controls">
                <i class="fas fa-chevron-up" id="toggleIcon"></i>
            </button>
            <div id="controlsContainer" class="d-flex gap-1">
                <button type="button" class="btn btn-sm btn-square btn-primary" data-bs-toggle="modal" data-bs-target="#configModal" title="Configure Analysis">
                    <i class="fas fa-cog"></i>
                </button>
                <button type="button" class="btn btn-sm btn-square btn-success" id="loadAnalysisBtn" onclick="loadFuturesConeAnalysis()" disabled title="Generate Futures Cone">
                    <i class="fas fa-play"></i>
                </button>
                <button type="button" class="btn btn-sm btn-square btn-outline-secondary" onclick="clearSavedConfiguration()" title="Clear Cache">
                    <i class="fas fa-trash"></i>
                </button>
                <div class="btn-divider"></div>
                <button type="button" class="btn btn-sm btn-square btn-outline-danger" onclick="downloadAsPDF()" title="Download PDF">
                    <i class="fas fa-file-pdf"></i>
                </button>
                <button type="button" class="btn btn-sm btn-square btn-outline-info" onclick="downloadAsImage()" title="Download PNG">
                    <i class="fas fa-image"></i>
                </button>
            </div>
        </div>
    </div>
    
    <div class="loading-spinner" id="loadingSpinner" style="display: none;">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Generating futures cone analysis...</p>
    </div>
    
    <div id="errorContainer"></div>
    
    <div id="futuresConeContainer" style="display: none;">
        <div class="cone-container">
            <!-- SVG Cone Structure -->
            <svg class="cone-svg" viewBox="0 0 1400 750">
                <!-- Cone boundaries from narrow present to wide future -->
                
                <!-- Possible (outermost) -->
                <path class="cone-shape possible-line" d="M 110 375 L 1200 125 L 1200 625 Z"/>
                <path class="cone-shape possible-fill" d="M 110 375 L 1200 125 L 1200 625 Z"/>
                
                <!-- Plausible (middle) -->
                <path class="cone-shape plausible-line" d="M 110 375 L 1100 200 L 1100 550 Z"/>
                <path class="cone-shape plausible-fill" d="M 110 375 L 1100 200 L 1100 550 Z"/>
                
                <!-- Probable (innermost) -->
                <path class="cone-shape probable-line" d="M 110 375 L 1000 275 L 1000 475 Z"/>
                <path class="cone-shape probable-fill" d="M 110 375 L 1000 275 L 1000 475 Z"/>
                
                <!-- Preferable path -->
                <path class="cone-shape preferable-line" d="M 110 375 L 900 175" stroke-dasharray="5,5"/>
                
                <!-- Center line (probable path) -->
                <line x1="110" y1="375" x2="1000" y2="375" stroke="rgba(0,0,0,0.1)" stroke-width="1" stroke-dasharray="2,2"/>
                
                <!-- Time markers -->
                <line x1="300" y1="125" x2="300" y2="625" stroke="rgba(0,0,0,0.05)" stroke-width="1"/>
                <line x1="500" y1="125" x2="500" y2="625" stroke="rgba(0,0,0,0.05)" stroke-width="1"/>
                <line x1="700" y1="125" x2="700" y2="625" stroke="rgba(0,0,0,0.05)" stroke-width="1"/>
                <line x1="900" y1="125" x2="900" y2="625" stroke="rgba(0,0,0,0.05)" stroke-width="1"/>
            </svg>
            
            <!-- NOW marker -->
            <div class="now-marker">NOW<br>2025</div>
            
            <!-- Cone labels -->
            <div class="cone-labels">
                <div class="cone-label" style="color: #ff6b6b;">Possible</div>
                <div class="cone-label" style="color: #ffc107;">Plausible</div>
                <div class="cone-label" style="color: #00d4ff;">Probable</div>
                <div class="cone-label" style="color: #4ecdc4;">Preferable</div>
                <div class="cone-label" style="color: #8a2be2;">âš¡ Wildcard</div>
            </div>
            
            <!-- Scenarios will be dynamically populated here -->
            <div id="scenariosContainer"></div>
            
            <!-- Timeline -->
            <div class="timeline-axis"></div>
            <div class="timeline-labels" id="timelineLabels">
                <!-- Timeline markers will be dynamically populated -->
            </div>
        </div>

        <!-- Additional Content Section -->
        <div class="additional-content" id="additionalContent">
            <!-- Detailed Scenarios -->
            <div class="content-section" id="detailedScenariosSection" style="display: none;">
                <h2>Scenario Details</h2>
                <div class="scenarios-detail-grid" id="detailedScenariosGrid">
                    <!-- Detailed scenario cards will be dynamically populated -->
                </div>
            </div>
            
            <!-- Key Themes will be populated here -->
            <div class="content-section" id="keyThemesSection" style="display: none;">
                <h2>Key Themes</h2>
                <div class="themes-grid" id="keyThemesGrid">
                    <!-- Theme cards will be dynamically populated -->
                </div>
            </div>
            
            <!-- Legend -->
            <div class="content-section" id="legendSection" style="display: none;">
                <h2>Scenario Types</h2>
                <div class="legend" id="legendGrid">
                    <!-- Legend items will be dynamically populated -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Configuration Modal -->
<div class="modal fade" id="configModal" tabindex="-1" aria-labelledby="configModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="configModalLabel">ðŸ”® Configure Futures Cone Analysis</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="topic" class="form-label">Topic</label>
                            <select class="form-select" id="topic" required onchange="updateLoadButton()">
                                <option value="">Loading topics...</option>
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="timeframe" class="form-label">Analysis Timeframe</label>
                            <div class="d-flex gap-2">
                                <select class="form-select" id="timeframe" onchange="toggleCustomTimeframe()">
                                    <option value="30d">Last 30 Days</option>
                                    <option value="90d">Last 90 Days</option>
                                    <option value="180d">Last 180 Days</option>
                                    <option value="365d" selected>Last 365 Days</option>
                                    <option value="all">All Time</option>
                                    <option value="custom">Custom</option>
                                </select>
                                <input type="number" class="form-control" id="customDays" placeholder="Days" 
                                       style="display: none; width: 80px;" min="1" max="3650">
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label for="model" class="form-label">AI Model</label>
                            <select class="form-select" id="model" onchange="updateLoadButton()">
                                <option value="">Loading models...</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="futureHorizon" class="form-label">Future Horizon</label>
                            <select class="form-select" id="futureHorizon">
                                <option value="5" selected>5 Years</option>
                                <option value="10">10 Years</option>
                                <option value="20">20 Years</option>
                                <option value="50">50 Years</option>
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="analysisDepth" class="form-label">Analysis Depth</label>
                            <select class="form-select" id="analysisDepth">
                                <option value="standard" selected>Standard Analysis</option>
                                <option value="detailed">Detailed Analysis</option>
                                <option value="comprehensive">Comprehensive Analysis</option>
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label for="sampleSizeMode" class="form-label">Article Sample Size</label>
                            <div class="d-flex gap-2">
                                <select class="form-select" id="sampleSizeMode" onchange="handleSampleSizeModeChange()">
                                    <option value="auto" selected>Auto-size</option>
                                    <option value="balanced">Balanced</option>
                                    <option value="comprehensive">Comprehensive</option>
                                    <option value="focused">Focused</option>
                                    <option value="custom">Custom</option>
                                </select>
                                <input type="number" class="form-control" id="customLimit" placeholder="Count" 
                                       style="display: none; width: 100px;" min="10" max="500" value="50">
                            </div>
                            <div class="context-info mt-2" id="contextInfo" style="display: none;">
                                <small class="text-muted">
                                    <i class="fas fa-info-circle me-1"></i>
                                    <span id="contextStats">Context: 0 articles, ~0 tokens</span>
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveConfigurationAndClose()">
                    <i class="fas fa-save me-2"></i>Save Configuration
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Scenario Detail Modal -->
<div id="scenarioModal" class="modal fade" tabindex="-1" aria-labelledby="scenarioModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="scenarioModalLabel">Scenario Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="modalContent">
                <!-- Scenario details will be populated here -->
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Libraries for download functionality -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
// UI Control Functions
function toggleControls() {
    const controlsContainer = document.getElementById('controlsContainer');
    const toggleIcon = document.getElementById('toggleIcon');
    // Find the header subtitle
    const headerSubtitle = document.getElementById('topicSubtitle');
    
    const isCollapsed = controlsContainer.classList.contains('collapsed');
    
    if (isCollapsed) {
        // Show controls
        controlsContainer.classList.remove('collapsed');
        toggleIcon.classList.remove('rotated');
        if (headerSubtitle) {
            headerSubtitle.classList.remove('header-subtitle-hidden');
        }
        localStorage.setItem('futuresConeControlsCollapsed', 'false');
    } else {
        // Hide controls
        controlsContainer.classList.add('collapsed');
        toggleIcon.classList.add('rotated');
        if (headerSubtitle) {
            headerSubtitle.classList.add('header-subtitle-hidden');
        }
        localStorage.setItem('futuresConeControlsCollapsed', 'true');
    }
}

function restoreControlsState() {
    const isCollapsed = localStorage.getItem('futuresConeControlsCollapsed') === 'true';
    if (isCollapsed) {
        const controlsContainer = document.getElementById('controlsContainer');
        const toggleIcon = document.getElementById('toggleIcon');
        
        controlsContainer.classList.add('collapsed');
        toggleIcon.classList.add('rotated');
    }
}

async function autoLoadCachedAnalysis() {
    try {
        // Find the most recent cached result
        const allKeys = Object.keys(localStorage).filter(key => key.startsWith('futuresConeResults_'));
        
        if (allKeys.length === 0) {
            console.log('No cached results found for auto-load');
            return;
        }

        // Get the most recent cache entry
        let latestCache = null;
        let latestTimestamp = 0;
        
        for (const key of allKeys) {
            try {
                const cacheData = JSON.parse(localStorage.getItem(key));
                const timestamp = new Date(cacheData.timestamp).getTime();
                
                if (timestamp > latestTimestamp) {
                    latestTimestamp = timestamp;
                    latestCache = cacheData;
                }
            } catch (e) {
                console.warn('Invalid cache entry:', key, e);
            }
        }

        if (latestCache && latestCache.results && latestCache.results.data) {
            console.log('Auto-loading cached result from:', latestCache.timestamp);
            
            // Display the cached analysis
            await displayFuturesCone(latestCache.results.data);
            
            // Hide the subtitle if controls are collapsed
            const isCollapsed = localStorage.getItem('futuresConeControlsCollapsed') === 'true';
            if (isCollapsed) {
                setTimeout(() => {
                    const headerSubtitle = document.getElementById('topicSubtitle');
                    if (headerSubtitle) {
                        headerSubtitle.classList.add('header-subtitle-hidden');
                    }
                }, 100);
            }
            
            console.log('Auto-loaded cached futures cone analysis successfully');
        } else {
            console.log('No valid cached results found for auto-load');
        }
        
    } catch (error) {
        console.error('Error auto-loading cached result:', error);
    }
}

// Download Functions
async function downloadAsPDF() {
    try {
        showSuccess('Generating PDF... Please wait.');
        
        const { jsPDF } = window.jspdf;
        const futuresConeContainer = document.getElementById('futuresConeContainer');
        
        if (!futuresConeContainer || futuresConeContainer.style.display === 'none') {
            showError('No futures cone to download. Please generate analysis first.');
            return;
        }

        // Create a comprehensive export container
        const exportContainer = document.createElement('div');
        exportContainer.style.cssText = `
            background: white;
            padding: 30px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            width: 1400px;
            margin: 0 auto;
            box-sizing: border-box;
        `;
        
        // Add title
        const title = document.createElement('h1');
        title.style.cssText = `
            color: #FF69B4;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        `;
        title.innerHTML = '<i style="margin-right: 10px;">ðŸ”®</i>Data-Driven Futures Cone';
        exportContainer.appendChild(title);
        
        // Add subtitle
        const subtitle = document.createElement('p');
        subtitle.style.cssText = `
            color: #666;
            font-size: 18px;
            text-align: center;
            margin-bottom: 40px;
        `;
        const topicName = document.getElementById('topic')?.value || 'Selected Topic';
        subtitle.textContent = `Futures analysis for ${topicName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
        exportContainer.appendChild(subtitle);
        
        // Clone the complete futures cone content including additional sections
        const clonedContent = futuresConeContainer.cloneNode(true);
        clonedContent.style.display = 'block';
        clonedContent.style.width = '100%';
        
        // Ensure additional content sections are visible
        const additionalContent = clonedContent.querySelector('#additionalContent');
        if (additionalContent) {
            additionalContent.style.display = 'block';
            const sections = additionalContent.querySelectorAll('.content-section');
            sections.forEach(section => {
                section.style.display = 'block';
            });
        }
        
        exportContainer.appendChild(clonedContent);
        
        // Temporarily add to page for rendering
        exportContainer.style.position = 'absolute';
        exportContainer.style.left = '-10000px';
        exportContainer.style.top = '0';
        exportContainer.style.zIndex = '-1000';
        document.body.appendChild(exportContainer);

        // Wait for rendering
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Generate canvas with better settings
        const canvas = await html2canvas(exportContainer, {
            useCORS: true,
            scale: 1.0,
            logging: false,
            allowTaint: true,
            backgroundColor: '#ffffff',
            width: 1400,
            height: exportContainer.scrollHeight,
            removeContainer: false
        });

        // Remove temporary container
        document.body.removeChild(exportContainer);

        // Create PDF with proper sizing
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pdfWidth = 210;
        const pdfHeight = 297;
        const imgWidth = pdfWidth - 20;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        
        const pageHeight = pdfHeight - 20;
        let y = 10;
        let remainingHeight = imgHeight;
        let sourceY = 0;

        // Add pages as needed
        while (remainingHeight > 0) {
            const heightToAdd = Math.min(remainingHeight, pageHeight);
            const sourceHeight = (heightToAdd / imgHeight) * canvas.height;
            
            const pageCanvas = document.createElement('canvas');
            pageCanvas.width = canvas.width;
            pageCanvas.height = sourceHeight;
            const pageCtx = pageCanvas.getContext('2d');
            
            pageCtx.drawImage(canvas, 0, sourceY, canvas.width, sourceHeight, 0, 0, canvas.width, sourceHeight);
            
            if (sourceY > 0) {
                pdf.addPage();
            }
            
            const pageImgData = pageCanvas.toDataURL('image/png', 0.95);
            pdf.addImage(pageImgData, 'PNG', 10, y, imgWidth, heightToAdd);
            
            remainingHeight -= heightToAdd;
            sourceY += sourceHeight;
            y = 10;
        }

        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `futures-cone-${timestamp}.pdf`;
        
        pdf.save(filename);
        showSuccess('PDF downloaded successfully!');
        
    } catch (error) {
        console.error('Error generating PDF:', error);
        showError('Failed to generate PDF: ' + error.message);
    }
}

async function downloadAsImage() {
    try {
        showSuccess('Generating image... Please wait.');
        
        const futuresConeContainer = document.getElementById('futuresConeContainer');
        
        if (!futuresConeContainer || futuresConeContainer.style.display === 'none') {
            showError('No futures cone to download. Please generate analysis first.');
            return;
        }

        // Create a comprehensive export container
        const exportContainer = document.createElement('div');
        exportContainer.style.cssText = `
            background: white;
            padding: 40px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            width: 1400px;
            margin: 0 auto;
            box-sizing: border-box;
        `;
        
        // Add title
        const title = document.createElement('h1');
        title.style.cssText = `
            color: #FF69B4;
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        `;
        title.innerHTML = '<i style="margin-right: 10px;">ðŸ”®</i>Data-Driven Futures Cone';
        exportContainer.appendChild(title);
        
        // Add subtitle
        const subtitle = document.createElement('p');
        subtitle.style.cssText = `
            color: #666;
            font-size: 20px;
            text-align: center;
            margin-bottom: 50px;
        `;
        const topicName = document.getElementById('topic')?.value || 'Selected Topic';
        subtitle.textContent = `Futures analysis for ${topicName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
        exportContainer.appendChild(subtitle);
        
        // Clone the complete futures cone content including additional sections
        const clonedContent = futuresConeContainer.cloneNode(true);
        clonedContent.style.display = 'block';
        clonedContent.style.width = '100%';
        
        // Ensure additional content sections are visible
        const additionalContent = clonedContent.querySelector('#additionalContent');
        if (additionalContent) {
            additionalContent.style.display = 'block';
            const sections = additionalContent.querySelectorAll('.content-section');
            sections.forEach(section => {
                section.style.display = 'block';
            });
        }
        
        exportContainer.appendChild(clonedContent);
        
        // Temporarily add to page for rendering
        exportContainer.style.position = 'absolute';
        exportContainer.style.left = '-10000px';
        exportContainer.style.top = '0';
        exportContainer.style.zIndex = '-1000';
        document.body.appendChild(exportContainer);

        // Wait for rendering
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Generate canvas with optimized settings
        const canvas = await html2canvas(exportContainer, {
            useCORS: true,
            scale: 1.5,
            logging: false,
            allowTaint: true,
            backgroundColor: '#ffffff',
            width: 1400,
            height: exportContainer.scrollHeight,
            removeContainer: false
        });

        // Remove temporary container
        document.body.removeChild(exportContainer);

        // Create download link
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `futures-cone-${timestamp}.png`;
        
        link.download = filename;
        link.href = canvas.toDataURL('image/png', 0.95);
        link.click();
        
        showSuccess('Image downloaded successfully!');
        
    } catch (error) {
        console.error('Error generating image:', error);
        showError('Failed to generate image: ' + error.message);
    }
}

// Configuration and state management
let currentAnalysisData = null;

async function loadFuturesConeAnalysis() {
    const topicElement = document.getElementById('topic');
    const timeframeElement = document.getElementById('timeframe');
    const modelElement = document.getElementById('model');
    const futureHorizonElement = document.getElementById('futureHorizon');
    const analysisDepthElement = document.getElementById('analysisDepth');
    const scenarioCountElement = document.getElementById('scenarioCount');
    
    const loadingSpinner = document.getElementById('loadingSpinner');
    const futuresConeContainer = document.getElementById('futuresConeContainer');
    
    if (!topicElement || !timeframeElement || !modelElement) {
        showError('Required form elements not found. Please refresh the page.');
        return;
    }
    
    const topic = topicElement.value;
    const timeframe = timeframeElement.value;
    const model = modelElement.value;
    const futureHorizon = futureHorizonElement ? futureHorizonElement.value : '5';
    const analysisDepth = analysisDepthElement ? analysisDepthElement.value : 'standard';
    const scenarioCount = scenarioCountElement ? scenarioCountElement.value : 'standard';
    
    if (!topic) {
        showError('Please select a topic');
        return;
    }
    
    if (!model) {
        showError('Please select a model');
        return;
    }
    
    // Get current configuration for caching
    const currentConfig = getCurrentConfiguration();
    
    // Check for cached results first with configuration matching
    const cachedResults = loadCachedResults(currentConfig);
    if (cachedResults && cachedResults.data) {
        console.log('Using cached results for configuration:', currentConfig);
        await displayFuturesCone(cachedResults.data);
        showSuccess('Loaded cached results (faster response)');
        return;
    }
    
    // Get custom timeframe if selected
    let actualTimeframe = timeframe;
    if (timeframe === 'custom') {
        const customDaysElement = document.getElementById('customDays');
        const customDays = customDaysElement ? parseInt(customDaysElement.value) : null;
        if (!customDays || customDays < 1) {
            showError('Please enter a valid number of days');
            return;
        }
        actualTimeframe = customDays;
    } else {
        // Convert timeframe format
        actualTimeframe = parseInt(timeframe.replace('d', '')) || 365;
    }
    
    // Show loading
    if (loadingSpinner) loadingSpinner.style.display = 'block';
    if (futuresConeContainer) futuresConeContainer.style.display = 'none';
    
    try {
        // Get sample size parameters
        const sampleSizeMode = document.getElementById('sampleSizeMode').value;
        const customLimit = document.getElementById('customLimit').value;
        
        // Build request parameters
        const params = new URLSearchParams({
            timeframe_days: actualTimeframe,
            model: model,
            future_horizon: futureHorizon,
            analysis_depth: analysisDepth,
            sample_size_mode: sampleSizeMode
        });
        
        // Add custom limit if specified
        if (sampleSizeMode === 'custom' && customLimit) {
            params.append('custom_limit', customLimit);
        }
        
        const response = await fetch(`/api/futures-cone/${encodeURIComponent(topic)}?${params}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Cache the results with full configuration
        saveAnalysisResults(data, currentConfig);
        
        await displayFuturesCone(data);
        
    } catch (error) {
        showError(`Error loading futures cone analysis: ${error.message}`);
    } finally {
        loadingSpinner.style.display = 'none';
    }
}

async function displayFuturesCone(data) {
    currentAnalysisData = data;
    
    // Update subtitle with topic
    const topicSubtitle = document.getElementById('topicSubtitle');
    const topic = document.getElementById('topic').value;
    if (topicSubtitle && topic) {
        topicSubtitle.textContent = `Futures Cone for ${topic.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
    }
    
    // Populate scenarios on the cone
    populateScenarios(data.scenarios || []);
    
    // Update timeline based on future horizon
    updateTimeline(data.timeline || []);
    
    // Generate additional content sections
    generateDetailedScenarios(data.scenarios || []);
    generateKeyThemes(data.key_themes || data.themes || []);
    generateLegend(data.legend || generateDefaultLegend());
    
    // Show the cone
    document.getElementById('futuresConeContainer').style.display = 'block';
}

function generateDetailedScenarios(scenarios) {
    const detailedScenariosGrid = document.getElementById('detailedScenariosGrid');
    const detailedScenariosSection = document.getElementById('detailedScenariosSection');
    
    if (!scenarios || scenarios.length === 0) {
        detailedScenariosSection.style.display = 'none';
        return;
    }
    
    detailedScenariosGrid.innerHTML = '';
    
    // Group scenarios by type
    const scenariosByType = {
        'probable': [],
        'plausible': [],
        'possible': [],
        'preferable': [],
        'wildcard': []
    };
    
    scenarios.forEach(scenario => {
        const type = scenario.type || 'probable';
        if (scenariosByType[type]) {
            scenariosByType[type].push(scenario);
        }
    });
    
    // Create columns for each type that has scenarios
    const typeLabels = {
        'probable': 'Probable (Centerline)',
        'plausible': 'Plausible (Alternative Paths)',
        'possible': 'Possible (Wild Cards)',
        'preferable': 'Preferable (Aspirational)',
        'wildcard': 'Wildcard (Disruptive)'
    };
    
    Object.keys(scenariosByType).forEach(type => {
        const scenariosOfType = scenariosByType[type];
        if (scenariosOfType.length === 0) return;
        
        // Create column container
        const column = document.createElement('div');
        column.className = 'scenario-type-column';
        
        // Add header
        const header = document.createElement('div');
        header.className = `scenario-type-header ${type}`;
        header.textContent = typeLabels[type];
        column.appendChild(header);
        
        // Add scenarios for this type
        scenariosOfType.forEach(scenario => {
            const scenarioCard = document.createElement('div');
            scenarioCard.className = `scenario-detail-card ${scenario.type}`;
            
            let cardContent = `
                <div class="scenario-detail-title">${scenario.title}</div>
                <div class="scenario-detail-meta">
                    <div class="scenario-detail-timeframe">${scenario.timeframe}</div>
                </div>
            `;
            
            if (scenario.description) {
                cardContent += `<div class="scenario-detail-description">${scenario.description}</div>`;
            }
            
            if (scenario.drivers && scenario.drivers.length > 0) {
                cardContent += `
                    <div class="scenario-detail-section">
                        <h4>Key Drivers</h4>
                        <ul class="scenario-detail-list">
                            ${scenario.drivers.map(driver => {
                                const driverText = typeof driver === 'object' ? driver.description : driver;
                                return `<li>${driverText}</li>`;
                            }).join('')}
                        </ul>
                    </div>
                `;
            }
            
            if (scenario.signals && scenario.signals.length > 0) {
                cardContent += `
                    <div class="scenario-detail-section">
                        <h4>Supporting Signals</h4>
                        <ul class="scenario-detail-list">
                            ${scenario.signals.slice(0, 5).map(signal => `<li>${signal}</li>`).join('')}
                            ${scenario.signals.length > 5 ? `<li><em>...and ${scenario.signals.length - 5} more signals</em></li>` : ''}
                        </ul>
                    </div>
                `;
            }
            
            if (scenario.probability) {
                cardContent += `
                    <div class="scenario-detail-section">
                        <h4>Probability Assessment</h4>
                        <p>${scenario.probability}</p>
                    </div>
                `;
            }
            
            if (scenario.branching_point) {
                cardContent += `
                    <div class="scenario-detail-section">
                        <h4>Branching Point</h4>
                        <p><em>${scenario.branching_point}</em></p>
                    </div>
                `;
            }
            
            scenarioCard.innerHTML = cardContent;
            column.appendChild(scenarioCard);
        });
        
        detailedScenariosGrid.appendChild(column);
    });
    
    detailedScenariosSection.style.display = 'block';
}

function generateKeyThemes(themes) {
    const keyThemesGrid = document.getElementById('keyThemesGrid');
    const keyThemesSection = document.getElementById('keyThemesSection');
    
    if (!themes || themes.length === 0) {
        keyThemesSection.style.display = 'none';
        return;
    }
    
    keyThemesGrid.innerHTML = '';
    
    themes.forEach(theme => {
        const themeCard = document.createElement('div');
        themeCard.className = 'theme-card';
        themeCard.innerHTML = `
            <div class="theme-title">${theme.title}</div>
            <div class="theme-description">${theme.description}</div>
        `;
        keyThemesGrid.appendChild(themeCard);
    });
    
    keyThemesSection.style.display = 'block';
}

function generateLegend(legendData) {
    const legendGrid = document.getElementById('legendGrid');
    const legendSection = document.getElementById('legendSection');
    
    legendGrid.innerHTML = '';
    
    legendData.forEach(item => {
        const legendItem = document.createElement('div');
        legendItem.className = `legend-item legend-${item.type}`;
        legendItem.innerHTML = `
            <div class="legend-title">${item.title}</div>
            <div class="legend-content">${item.content}</div>
        `;
        legendGrid.appendChild(legendItem);
    });
    
    legendSection.style.display = 'block';
}

function generateDefaultLegend() {
    return [
        {
            type: 'probable',
            title: 'Probable (Centerline)',
            content: 'Most likely futures based on current trends and data patterns. These scenarios have strong supporting evidence and logical progression from present conditions.'
        },
        {
            type: 'plausible',
            title: 'Plausible (Alternative Paths)',
            content: 'Realistic alternative futures that could emerge under different conditions. These scenarios represent viable pathways with reasonable probability.'
        },
        {
            type: 'possible',
            title: 'Possible (Wild Cards)',
            content: 'Low-probability, high-impact scenarios that could dramatically reshape the future. These represent extreme but not impossible outcomes.'
        },
        {
            type: 'preferable',
            title: 'Preferable (Aspirational)',
            content: 'Desired futures that represent optimal outcomes. These scenarios require deliberate intervention and coordinated efforts to achieve.'
        }
    ];
}

function populateScenarios(scenarios) {
    const scenariosContainer = document.getElementById('scenariosContainer');
    scenariosContainer.innerHTML = '';
    
    console.log('Populating scenarios:', scenarios.length);
    
    scenarios.forEach((scenario, index) => {
        const scenarioDiv = document.createElement('div');
        scenarioDiv.className = `scenario ${scenario.type}`;
        
        // Use simplified positioning system
        const position = calculateScenarioPosition(scenario, index);
        scenarioDiv.style.top = `${position.y}%`;
        scenarioDiv.style.left = `${position.x}%`;
        scenarioDiv.setAttribute('data-scenario', `scenario-${index}`);
        
        // Add sentiment color coding
        const sentimentClass = getSentimentClass(scenario.sentiment);
        
        // Keep scenario cards on cone simple - details go underneath
        scenarioDiv.innerHTML = `
            <div class="scenario-title">${scenario.title}</div>
            <div class="scenario-year">${scenario.timeframe}</div>
            <div class="scenario-sentiment ${sentimentClass}">${scenario.sentiment || 'Neutral'}</div>
        `;
        
        // Add click handler
        scenarioDiv.addEventListener('click', () => showScenarioDetails(scenario));
        
        scenariosContainer.appendChild(scenarioDiv);
    });
}



function calculateScenarioPosition(scenario, index) {
    // Extract year from timeframe for temporal positioning
    const yearMatch = scenario.timeframe.match(/(\d{4})/);
    const year = yearMatch ? parseInt(yearMatch[1]) : 2030;
    
    // Simple, deterministic mapping to timeline positions
    // Based on actual SVG timeline markers and CSS positioning
    let baseX;
    if (year <= 2025) {
        baseX = 8;    // NOW marker (2025)
    } else if (year <= 2026) {
        baseX = 21.4; // 2026 marker
    } else if (year <= 2027) {
        baseX = 35.7; // 2027 marker
    } else if (year <= 2028) {
        baseX = 50;   // 2028 marker
    } else if (year <= 2030) {
        baseX = 64.3; // 2030 marker
    } else {
        baseX = 75;   // Beyond 2030
    }
    
    // Get Y position based on scenario type (no random variation)
    const centerY = 50; // Center of cone
    const coneWidth = Math.max(10, (baseX - 8) * 0.6); // Cone expands as we go right
    
    let baseY = centerY;
    switch (scenario.type) {
        case 'probable':
            // Center line - very close to center
            baseY = centerY + (index % 3 - 1) * 3; // Small vertical spacing
            break;
        case 'plausible':
            // Middle zones
            baseY = centerY + (index % 2 === 0 ? -coneWidth * 0.5 : coneWidth * 0.5);
            break;
        case 'possible':
            // Outer edges
            baseY = centerY + (index % 2 === 0 ? -coneWidth * 0.8 : coneWidth * 0.8);
            break;
        case 'preferable':
            // Upper zone
            baseY = centerY - coneWidth * 0.6;
            break;
        case 'wildcard':
            // Dramatic positions
            baseY = centerY + (index % 2 === 0 ? -coneWidth * 0.9 : coneWidth * 0.9);
            break;
        default:
            baseY = centerY;
    }
    
    // Add small index-based offset to prevent exact overlap
    const offsetX = (index % 3 - 1) * 1.5; // Small horizontal offset
    const offsetY = Math.floor(index / 3) * 4; // Vertical stacking for same type
    
    const finalX = Math.max(10, Math.min(85, baseX + offsetX));
    const finalY = Math.max(15, Math.min(85, baseY + offsetY));
    
    console.log(`Scenario ${index}: "${scenario.title}" (${scenario.timeframe}) -> Year: ${year}, Position: ${finalX}%, ${finalY}%`);
    
    return { x: finalX, y: finalY };
}



function updateTimeline(timeline) {
    const timelineLabels = document.getElementById('timelineLabels');
    timelineLabels.innerHTML = '';
    
    // Use fixed timeline that matches SVG markers and scenario positioning
    const fixedTimeline = [
        { year: 2025, label: 'Present' },
        { year: 2026, label: 'Short-term' },
        { year: 2027, label: 'Mid-term' },
        { year: 2028, label: 'Long-term' },
        { year: 2030, label: 'Horizon' }
    ];
    
    // Use provided timeline if available, otherwise use fixed
    const timelineToUse = (timeline && timeline.length > 0) ? timeline : fixedTimeline;
    
    timelineToUse.forEach(marker => {
        const markerDiv = document.createElement('div');
        markerDiv.className = 'timeline-marker';
        markerDiv.innerHTML = `${marker.year}<br><small>${marker.label}</small>`;
        timelineLabels.appendChild(markerDiv);
    });
}

function showScenarioDetails(scenario) {
    const modal = document.getElementById('scenarioModal');
    const modalLabel = document.getElementById('scenarioModalLabel');
    const modalContent = document.getElementById('modalContent');
    
    modalLabel.textContent = scenario.title;
    
    modalContent.innerHTML = `
        <div class="mb-3">
            <h6>Scenario Type: <span class="badge bg-primary">${scenario.type.charAt(0).toUpperCase() + scenario.type.slice(1)}</span></h6>
            <h6>Timeframe: <span class="text-info">${scenario.timeframe}</span></h6>
            <h6>Sentiment: <span class="badge bg-secondary">${scenario.sentiment}</span></h6>
        </div>
        
        <div class="mb-3">
            <h6>Description:</h6>
            <p>${scenario.description}</p>
        </div>
        
        ${scenario.drivers ? `
        <div class="mb-3">
            <h6>Key Drivers:</h6>
            <ul>
                ${scenario.drivers.map(driver => `<li><strong>${driver.type}:</strong> ${driver.description}</li>`).join('')}
            </ul>
        </div>
        ` : ''}
        
        ${scenario.signals ? `
        <div class="mb-3">
            <h6>Supporting Signals:</h6>
            <ul>
                ${scenario.signals.map(signal => `<li>${signal}</li>`).join('')}
            </ul>
        </div>
        ` : ''}
        
        ${scenario.branching_point ? `
        <div class="mb-3">
            <h6>Branching Point:</h6>
            <p><em>${scenario.branching_point}</em></p>
        </div>
        ` : ''}
        
        ${scenario.probability ? `
        <div class="mb-3">
            <h6>Probability Assessment:</h6>
            <p>${scenario.probability}</p>
        </div>
        ` : ''}
    `;
    
    const bootstrapModal = new bootstrap.Modal(modal);
    bootstrapModal.show();
}

function getSentimentClass(sentiment) {
    if (!sentiment) return '';
    const lowerSentiment = sentiment.toLowerCase();
    if (lowerSentiment.includes('positive')) return 'text-success';
    if (lowerSentiment.includes('negative') || lowerSentiment.includes('critical')) return 'text-danger';
    if (lowerSentiment.includes('neutral')) return 'text-info';
    return '';
}

// Auto sampling logic (copied from consensus analysis)
const contextLimits = {
    'gpt-3.5-turbo': 16385,
    'gpt-3.5-turbo-16k': 16385,
    'gpt-4': 8192,
    'gpt-4-32k': 32768,
    'gpt-4-turbo': 128000,
    'gpt-4-turbo-preview': 128000,
    'gpt-4o': 128000,
    'gpt-4o-mini': 128000,
    'gpt-4.1': 1000000,
    'gpt-4.1-mini': 1000000,
    'gpt-4.1-nano': 1000000,
    'claude-3-opus': 200000,
    'claude-3-sonnet': 200000,
    'claude-3-haiku': 200000,
    'claude-3.5-sonnet': 200000,
    'claude-4': 200000,
    'claude-4-opus': 200000,
    'claude-4-sonnet': 200000,
    'claude-4-haiku': 200000,
    'gemini-pro': 32768,
    'gemini-1.5-pro': 2097152,
    'llama-2-70b': 4096,
    'llama-3-70b': 8192,
    'mixtral-8x7b': 32768,
    'default': 16385
};

function handleSampleSizeModeChange() {
    const mode = document.getElementById('sampleSizeMode').value;
    const customLimit = document.getElementById('customLimit');
    
    if (mode === 'custom') {
        customLimit.style.display = 'block';
        customLimit.focus();
    } else {
        customLimit.style.display = 'none';
    }
    
    updateContextInfo();
}

function calculateOptimalSampleSize(model, message) {
    const mode = document.getElementById('sampleSizeMode').value;
    
    if (mode === 'custom') {
        return parseInt(document.getElementById('customLimit').value) || 50;
    }
    
    // Calculate based on mode and model capabilities
    const contextLimit = contextLimits[model] || contextLimits.default;
    const isMegaContext = contextLimit >= 1000000;
    
    let baseSampleSize;
    switch (mode) {
        case 'focused':
            baseSampleSize = isMegaContext ? 50 : 25;
            break;
        case 'balanced':
            baseSampleSize = isMegaContext ? 100 : 50;
            break;
        case 'comprehensive':
            baseSampleSize = isMegaContext ? 200 : 100;
            break;
        case 'auto':
        default:
            // Auto-size based on context window and message complexity
            const messageComplexity = (message?.length || 0) > 200 ? 1.2 : 1.0;
            let baseSize = isMegaContext ? 150 : 75;
            
            // For futures cone analysis, we need good coverage for scenario diversity
            if (message && message.includes('futures cone')) {
                baseSize = isMegaContext ? 200 : 100;
            }
            
            baseSampleSize = Math.round(baseSize * messageComplexity);
            break;
    }
    
    // Ensure reasonable limits
    const maxLimit = isMegaContext ? 1000 : 400;
    const minLimit = 20; // Minimum for good scenario diversity
    
    return Math.max(minLimit, Math.min(baseSampleSize, maxLimit));
}

function estimateTokens(text) {
    // Rough estimation: 1 token â‰ˆ 4 characters for English
    return Math.ceil((text?.length || 0) / 4);
}

function updateContextInfo() {
    const contextInfo = document.getElementById('contextInfo');
    const contextStats = document.getElementById('contextStats');
    
    if (!contextInfo || !contextStats) {
        console.warn('Context info elements not found');
        return;
    }
    
    const model = document.getElementById('model')?.value;
    const message = 'futures cone analysis'; // Default message for estimation
    
    if (!model) {
        contextInfo.style.display = 'none';
        return;
    }
    
    const sampleSize = calculateOptimalSampleSize(model, message);
    const contextLimit = contextLimits[model] || contextLimits.default;
    
    // Estimate token usage
    const systemTokens = 800; // Larger system prompt for futures cone
    const messageTokens = estimateTokens(message);
    const tokensPerArticle = 180; // Optimized article representation
    const articleTokens = sampleSize * tokensPerArticle;
    const totalTokens = systemTokens + messageTokens + articleTokens;
    
    const contextUsage = (totalTokens / contextLimit) * 100;
    
    // Model indicator
    const modelIndicator = contextLimit >= 1000000 ? ' ðŸš€1M' : 
                          contextLimit >= 200000 ? ' âš¡200K' : 
                          contextLimit >= 100000 ? ' ðŸ’«100K' : '';
    
    const contextText = `Context: ${sampleSize} articles, ~${totalTokens.toLocaleString()} tokens (${contextUsage.toFixed(1)}%)${modelIndicator}`;
    contextStats.textContent = contextText;
    
    // Color coding
    if (contextUsage > 90) {
        contextStats.style.color = '#dc3545'; // Red
        contextStats.style.fontWeight = 'bold';
    } else if (contextUsage > 70) {
        contextStats.style.color = '#fd7e14'; // Orange
        contextStats.style.fontWeight = '600';
    } else if (contextUsage > 50) {
        contextStats.style.color = '#28a745'; // Green
        contextStats.style.fontWeight = '500';
    } else {
        contextStats.style.color = '#007bff'; // Blue
        contextStats.style.fontWeight = '500';
    }
    
    contextInfo.style.display = 'block';
}

// Configuration management functions (similar to market_signals_dashboard.html)
function toggleCustomTimeframe() {
    const timeframe = document.getElementById('timeframe').value;
    const customDays = document.getElementById('customDays');
    
    if (timeframe === 'custom') {
        customDays.style.display = 'block';
        customDays.focus();
    } else {
        customDays.style.display = 'none';
        customDays.value = '';
    }
}

function updateLoadButton() {
    const topic = document.getElementById('topic').value;
    const model = document.getElementById('model').value;
    const loadBtn = document.getElementById('loadAnalysisBtn');
    const configureBtn = document.querySelector('[data-bs-target="#configModal"]');
    
    if (topic && model) {
        loadBtn.disabled = false;
        loadBtn.title = 'Generate Futures Cone';
        configureBtn.innerHTML = '<i class="fas fa-check"></i>';
        configureBtn.title = 'Configured';
        configureBtn.classList.remove('btn-primary');
        configureBtn.classList.add('btn-success');
    } else {
        loadBtn.disabled = true;
        loadBtn.title = 'Generate Futures Cone';
        configureBtn.innerHTML = '<i class="fas fa-cog"></i>';
        configureBtn.title = 'Configure Analysis';
        configureBtn.classList.remove('btn-success');
        configureBtn.classList.add('btn-primary');
    }
}

function saveConfigurationAndClose() {
    const topic = document.getElementById('topic').value;
    const model = document.getElementById('model').value;
    const timeframe = document.getElementById('timeframe').value;
    const futureHorizon = document.getElementById('futureHorizon').value;
    const analysisDepth = document.getElementById('analysisDepth').value;
    const sampleSizeMode = document.getElementById('sampleSizeMode').value;
    const customLimit = document.getElementById('customLimit').value;
    
    if (!topic) {
        alert('Please select a topic');
        return;
    }
    
    if (!model) {
        alert('Please select a model');
        return;
    }
    
    const config = {
        topic,
        model,
        timeframe,
        futureHorizon,
        analysisDepth,
        sampleSizeMode,
        customLimit,
        timestamp: new Date().toISOString()
    };
    
    // Add custom days if timeframe is custom
    if (timeframe === 'custom') {
        const customDays = document.getElementById('customDays').value;
        if (customDays) {
            config.customDays = customDays;
        }
    }
    
    console.log('Saving configuration:', config);
    localStorage.setItem('futuresConeConfig', JSON.stringify(config));
    
    // Close modal properly
    const modalElement = document.getElementById('configModal');
    const modal = bootstrap.Modal.getInstance(modalElement);
    if (modal) {
        modal.hide();
    }
    
    // Ensure backdrop is removed after modal is hidden
    modalElement.addEventListener('hidden.bs.modal', function () {
        const backdrop = document.querySelector('.modal-backdrop');
        if (backdrop) {
            backdrop.remove();
        }
        document.body.classList.remove('modal-open');
        document.body.style.removeProperty('padding-right');
    }, { once: true });
    
    updateLoadButton();
    showSuccess('Configuration saved! You can now generate the futures cone.');
}

function generateCacheKey(config) {
    // Create a unique cache key based on all configuration parameters
    const keyData = {
        topic: config.topic,
        timeframe: config.timeframe,
        customDays: config.customDays,
        model: config.model,
        futureHorizon: config.futureHorizon,
        analysisDepth: config.analysisDepth,
        sampleSizeMode: config.sampleSizeMode,
        customLimit: config.customLimit
    };
    
    // Create a hash of the configuration for the cache key
    const configString = JSON.stringify(keyData);
    let hash = 0;
    for (let i = 0; i < configString.length; i++) {
        const char = configString.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
    }
    
    return `futuresConeResults_${Math.abs(hash)}`;
}

function getCurrentConfiguration() {
    const timeframe = document.getElementById('timeframe')?.value || '';
    let customDays = null;
    
    if (timeframe === 'custom') {
        customDays = document.getElementById('customDays')?.value || null;
    }
    
    return {
        topic: document.getElementById('topic')?.value || '',
        timeframe: timeframe,
        customDays: customDays,
        model: document.getElementById('model')?.value || '',
        futureHorizon: document.getElementById('futureHorizon')?.value || '5',
        analysisDepth: document.getElementById('analysisDepth')?.value || 'standard',
        sampleSizeMode: document.getElementById('sampleSizeMode')?.value || 'auto',
        customLimit: document.getElementById('customLimit')?.value || null
    };
}

function saveAnalysisResults(data, config) {
    try {
        const cacheKey = generateCacheKey(config);
        const cacheData = {
            data,
            config,
            timestamp: new Date().toISOString()
        };
        
        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
        console.log('Analysis results cached successfully with key:', cacheKey);
        
        // Clean up old cache entries (keep only the most recent 5)
        const allKeys = Object.keys(localStorage).filter(key => key.startsWith('futuresConeResults_'));
        if (allKeys.length > 5) {
            // Get timestamps for all cached results
            const cacheEntries = allKeys.map(key => {
                try {
                    const data = JSON.parse(localStorage.getItem(key));
                    return { key, timestamp: new Date(data.timestamp) };
                } catch (e) {
                    return { key, timestamp: new Date(0) }; // Invalid entries get old timestamp
                }
            });
            
            // Sort by timestamp (newest first) and remove old entries
            cacheEntries.sort((a, b) => b.timestamp - a.timestamp);
            cacheEntries.slice(5).forEach(entry => {
                localStorage.removeItem(entry.key);
                console.log('Removed old cache entry:', entry.key);
            });
        }
    } catch (e) {
        console.warn('Failed to cache analysis results:', e);
    }
}

function loadCachedResults(config) {
    try {
        const cacheKey = generateCacheKey(config);
        const cachedData = localStorage.getItem(cacheKey);
        
        if (cachedData) {
            const cache = JSON.parse(cachedData);
            const cacheAge = new Date() - new Date(cache.timestamp);
            const maxAge = 24 * 60 * 60 * 1000; // 24 hours
            
            if (cacheAge < maxAge) {
                // Verify configuration matches
                const configMatches = JSON.stringify(cache.config) === JSON.stringify(config);
                if (configMatches) {
                    console.log('Loading cached results from:', cache.timestamp);
                    return cache;
                } else {
                    console.log('Configuration mismatch, cache invalid');
                    localStorage.removeItem(cacheKey);
                }
            } else {
                console.log('Cached results expired, removing...');
                localStorage.removeItem(cacheKey);
            }
        }
    } catch (e) {
        console.warn('Failed to load cached results:', e);
    }
    return null;
}

async function loadSavedConfiguration() {
    try {
        const savedConfig = localStorage.getItem('futuresConeConfig');
        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            
            // Set form values
            if (config.topic) document.getElementById('topic').value = config.topic;
            if (config.model) document.getElementById('model').value = config.model;
            if (config.timeframe) {
                document.getElementById('timeframe').value = config.timeframe;
                if (config.timeframe === 'custom' && config.customDays) {
                    document.getElementById('customDays').value = config.customDays;
                    document.getElementById('customDays').style.display = 'block';
                }
            }
            if (config.futureHorizon) document.getElementById('futureHorizon').value = config.futureHorizon;
            if (config.analysisDepth) document.getElementById('analysisDepth').value = config.analysisDepth;
            if (config.sampleSizeMode) {
                document.getElementById('sampleSizeMode').value = config.sampleSizeMode;
                handleSampleSizeModeChange();
            }
            if (config.customLimit) document.getElementById('customLimit').value = config.customLimit;
            
            updateLoadButton();
            return true;
        }
    } catch (e) {
        console.error('Failed to load saved configuration:', e);
    }
    return false;
}

function clearSavedConfiguration() {
    try {
        // Clear saved configuration
        localStorage.removeItem('futuresConeConfig');
        
        // Clear all cached results (they have dynamic keys now)
        const allKeys = Object.keys(localStorage).filter(key => key.startsWith('futuresConeResults_'));
        allKeys.forEach(key => {
            localStorage.removeItem(key);
        });
        
        console.log('Cleared all saved configuration and cached results');
        showSuccess(`Configuration and ${allKeys.length} cached result(s) cleared!`);
        
        // Reset form
        document.getElementById('topic').value = '';
        document.getElementById('model').value = '';
        document.getElementById('timeframe').value = '365d';
        document.getElementById('futureHorizon').value = '5';
        document.getElementById('analysisDepth').value = 'standard';
        document.getElementById('sampleSizeMode').value = 'auto';
        document.getElementById('customLimit').value = '50';
        document.getElementById('customDays').style.display = 'none';
        document.getElementById('customLimit').style.display = 'none';
        
        // Hide cone and additional sections
        document.getElementById('futuresConeContainer').style.display = 'none';
        document.getElementById('topicSubtitle').textContent = 'Configure Analysis Below';
        document.getElementById('detailedScenariosSection').style.display = 'none';
        document.getElementById('keyThemesSection').style.display = 'none';
        document.getElementById('legendSection').style.display = 'none';
        

        
        updateLoadButton();
    } catch (e) {
        console.error('Error clearing configuration:', e);
        showError('Failed to clear configuration. Please try refreshing the page.');
    }
}

function showSuccess(message) {
    const errorContainer = document.getElementById('errorContainer');
    errorContainer.innerHTML = `<div class="alert alert-success alert-dismissible fade show" role="alert">
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>`;
    
    setTimeout(() => {
        const alert = errorContainer.querySelector('.alert');
        if (alert) {
            const bsAlert = new bootstrap.Alert(alert);
            bsAlert.close();
        }
    }, 3000);
}

function showError(message) {
    const errorContainer = document.getElementById('errorContainer');
    errorContainer.innerHTML = `<div class="alert alert-danger alert-dismissible fade show" role="alert">
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>`;
}

// Initialize page
document.addEventListener('DOMContentLoaded', async function() {
    // Let Bootstrap handle its own initialization
    
    // Restore controls state
    restoreControlsState();
    
    // Try to auto-load cached analysis
    setTimeout(() => {
        autoLoadCachedAnalysis();
    }, 500);
    
    try {
        // Load topics
        const topicsResponse = await fetch('/api/forecast-charts/topics');
        const topicsData = await topicsResponse.json();
        
        const topicSelect = document.getElementById('topic');
        
        if (topicsData.success && topicsData.topics && topicsData.topics.length > 0) {
            topicSelect.innerHTML = '<option value="">Select a topic...</option>';
            
            topicsData.topics.forEach(topic => {
                const option = document.createElement('option');
                option.value = topic;
                option.textContent = topic.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                topicSelect.appendChild(option);
            });
        } else {
            topicSelect.innerHTML = '<option value="">No topics available</option>';
            showError('No topics with forecast data found.');
        }

        // Load models
        const modelsResponse = await fetch('/api/models');
        const models = await modelsResponse.json();
        
        const modelSelect = document.getElementById('model');
        
        if (models && models.length > 0) {
            modelSelect.innerHTML = '<option value="">Select model...</option>';
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.textContent = `${model.name} (${model.provider})`;
                modelSelect.appendChild(option);
            });
        } else {
            modelSelect.innerHTML = '<option value="">No models available</option>';
            showError('No AI models found.');
        }
        
        // Add event listeners for context updates
        modelSelect.addEventListener('change', updateContextInfo);
        document.getElementById('sampleSizeMode').addEventListener('change', updateContextInfo);
        document.getElementById('customLimit').addEventListener('input', updateContextInfo);
        
        // Initialize context info
        updateContextInfo();
        
        // Load saved configuration after all data is loaded
        setTimeout(async () => {
            await loadSavedConfiguration();
        }, 500);
        
    } catch (error) {
        console.warn('Failed to load data:', error);
        showError('Failed to load available data.');
    }
});
</script>
{% endblock %} 