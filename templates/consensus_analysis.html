{% extends "base.html" %}

{% block title %}Consensus vs. Fringe Voices - AuNoo AI{% endblock %}

{% block extra_css %}
    <style>
        /* Pink styling to match AuNoo AI theme */
        :root {
            --primary-color: #FF69B4;
            --primary-dark: #FF1493;
            --text-color: #333;
            --container-width: 1200px;
            --spacing-md: 1rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeInDown 1s ease-out;
        }
        
        .header h1 {
            font-size: 3rem;
            color: var(--primary-color);
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            font-size: 1.4rem;
            color: var(--primary-dark);
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .header p {
            font-size: 1.1rem;
            color: #6c757d;
            max-width: 700px;
            margin: 0 auto;
        }

        /* Form styling matching base.html patterns */
        .form-control, .form-select {
            border-radius: 8px;
            border: 1px solid #ddd;
            padding: 0.5rem 0.75rem;
            transition: all 0.2s ease;
        }

        .form-control:focus, .form-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        .btn {
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        /* Card styling */
        .card {
            border-radius: 12px;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        .card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            border-radius: 12px 12px 0 0 !important;
            border-bottom: 1px solid rgba(0, 0, 0, 0.125);
        }

        /* Domain cards styling */
        .domain-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
            width: 100%;
            max-width: none;
            position: relative; /* Required for ::after positioning */
        }

        .domain-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 105, 180, 0.3);
        }

        .domain-card.selected {
            border-color: var(--primary-color);
            box-shadow: 0 8px 25px rgba(0, 123, 255, 0.2);
        }
        
        /* Add visual indicator that cards are clickable */
        .domain-card::after {
            content: '‚ñº Click to expand';
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 11px;
            color: rgba(0, 0, 0, 0.4);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .domain-card:hover::after {
            opacity: 1;
        }
        
        .domain-card.selected::after {
            content: '‚ñ≤ Click to collapse';
        }

        .domain-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            margin-right: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .consensus-confidence {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            color: var(--primary-dark);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.875rem;
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        /* Timeline styling */
        .timeline-container {
            position: relative;
            height: 40px;
            background: linear-gradient(90deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            border-radius: 20px;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 100%;
            min-width: 800px; /* Wider minimum for full screen usage */
        }

        .consensus-band {
            position: absolute;
            height: 100%;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            cursor: help;
            transition: all 0.2s ease;
        }
        
        .consensus-band:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        /* Outlier markers */
        .outlier-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .outlier-marker:hover {
            width: 16px;
            height: 16px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 20;
        }
        
        .outlier-optimistic {
            background: #28a745;
        }
        
        .outlier-pessimistic {
            background: #dc3545;
        }

        /* Milestone markers - Enhanced for actionability */
        .milestone-marker {
            position: absolute;
            width: 4px;
            height: 100%;
            top: 0;
            cursor: pointer;
            z-index: 6;
            transition: all 0.3s ease;
            border-radius: 2px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .milestone-marker:hover {
            width: 6px;
            z-index: 16;
            transform: scaleY(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        .milestone-marker::before {
            content: '‚ö°';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: currentColor;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }
        
        .milestone-marker::after {
            content: 'üìã';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: currentColor;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .milestone-immediate {
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            color: #ff6b6b;
        }
        
        .milestone-immediate::before {
            content: 'üö®';
        }
        
        .milestone-short {
            background: linear-gradient(45deg, #ffa726, #ff9800);
            color: #ffa726;
        }
        
        .milestone-short::before {
            content: '‚ö°';
        }
        
        .milestone-mid {
            background: linear-gradient(45deg, #42a5f5, #2196f3);
            color: #42a5f5;
        }
        
        .milestone-mid::before {
            content: 'üéØ';
        }
        
        .milestone-long {
            background: linear-gradient(45deg, #ab47bc, #9c27b0);
            color: #ab47bc;
        }
        
        .milestone-long::before {
            content: 'üîÆ';
        }
        
        /* Alert styling */
        .alert {
            border-radius: 8px;
            border: none;
        }

        .alert-info {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            color: var(--primary-dark);
            border-left: 4px solid var(--primary-color);
        }

        /* Loading spinner */
        .loading-spinner {
            text-align: center;
            padding: 40px;
        }

        .spinner-border {
            color: var(--primary-color);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .col-md-3, .col-md-9 {
                margin-bottom: 20px;
            }
            
            .domain-card {
                padding: 15px;
            }
            
            .domain-icon {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }

        /* Sentiment distribution */
        .sentiment-distribution {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Badge styling */
        .badge {
            border-radius: 6px;
            font-weight: 500;
        }

        /* Enhanced hover effects */
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Sticky sidebar */
        .position-sticky {
            top: 20px !important;
        }

        /* Remove CSS tooltips and use JavaScript instead */
        .outlier-marker[title]:hover::after,
        .outlier-marker[title]:hover::before {
            display: none;
        }
        
        /* Custom tooltip styling */
        .custom-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            z-index: 10000;
            pointer-events: none;
            max-width: 350px;
            white-space: pre-line;
            word-wrap: break-word;
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .custom-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0,0,0,0.9) transparent transparent transparent;
        }
        /* Enhanced consensus badge styling with transparency */
        .consensus-confidence {
            background: linear-gradient(135deg, rgba(255, 105, 180, 0.15), rgba(255, 20, 147, 0.15));
            color: var(--primary-dark);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.875rem;
            border: 1px solid rgba(255, 105, 180, 0.3);
            backdrop-filter: blur(10px);
        }

        /* Enhanced consensus band with transparency */
        .consensus-band {
            background: rgba(255, 105, 180, 0.8) !important;
            backdrop-filter: blur(5px);
        }

        /* Update other elements with pink theme */
        .card-header.bg-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark)) !important;
        }

        .text-primary {
            color: var(--primary-color) !important;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            border: none;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--primary-dark), #C71585);
            transform: translateY(-2px);
        }

        /* Square button styling */
        .btn-square {
            width: 38px;
            height: 38px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        .btn-square:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }

        .btn-square i {
            font-size: 14px;
            margin: 0;
        }

        /* Button divider */
        .btn-divider {
            width: 1px;
            height: 24px;
            background: #dee2e6;
            margin: 0 4px;
            align-self: center;
        }

        /* Controls container animation */
        #controlsContainer {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        #controlsContainer.collapsed {
            opacity: 0;
            max-width: 0;
            margin: 0;
        }

        /* Toggle button */
        #toggleControlsBtn {
            transition: all 0.2s ease;
        }

        #toggleIcon {
            transition: transform 0.2s ease;
        }

        #toggleIcon.rotated {
            transform: rotate(180deg);
        }

        /* Hide analysis summary when collapsed */
        .analysis-summary-hidden {
            display: none !important;
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
{% endblock %}

{% block content %}
<div class="container">
    <div class="header">
        <h1>
            <i class="fas fa-balance-scale me-2"></i>
            Consensus vs. Fringe Voices
        </h1>
        <div class="subtitle" id="topicSubtitle">Configure Analysis Below</div>
        <p>Evidence-based analysis showing consensus patterns and outlier perspectives across topics</p>
    </div>
    
    <!-- Collapsible Control Bar -->
    <div class="mb-4 d-flex justify-content-center">
        <div class="d-flex align-items-center gap-2">
            <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleControlsBtn" onclick="toggleControls()" title="Toggle controls">
                <i class="fas fa-chevron-up" id="toggleIcon"></i>
            </button>
            <div id="controlsContainer" class="d-flex gap-1">
                <button type="button" class="btn btn-sm btn-square btn-primary" data-bs-toggle="modal" data-bs-target="#topicModal" title="Configure Analysis">
                    <i class="fas fa-cog"></i>
                </button>
                <button type="button" class="btn btn-sm btn-square btn-success" id="loadAnalysisBtn" onclick="loadConsensusAnalysis()" disabled title="Load Analysis">
                    <i class="fas fa-play"></i>
                </button>
                <button type="button" class="btn btn-sm btn-square btn-outline-secondary" onclick="clearSavedConfiguration()" title="Clear Cache">
                    <i class="fas fa-trash"></i>
                </button>
                <div class="btn-divider"></div>
                <button type="button" class="btn btn-sm btn-square btn-outline-danger" onclick="downloadAsPDF()" title="Download PDF">
                    <i class="fas fa-file-pdf"></i>
                </button>
                <button type="button" class="btn btn-sm btn-square btn-outline-info" onclick="downloadAsImage()" title="Download PNG">
                    <i class="fas fa-image"></i>
                </button>
            </div>
        </div>
    </div>
    
    <div class="loading-spinner" id="loadingSpinner" style="display: none;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading consensus analysis...</p>
    </div>
    
    <div id="errorContainer"></div>
    
    <div id="consensusContainer" style="display: none;">
        <div id="domainCards" style="width: 100%;"></div>
    </div>
</div>

    <!-- Topic Selection Modal -->
    <div class="modal fade" id="topicModal" tabindex="-1" aria-labelledby="topicModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="topicModalLabel">üéØ Configure Analysis Parameters</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="topic" class="form-label">Topic</label>
                                <select class="form-select" id="topic" required onchange="updateLoadButton()">
                                    <option value="">Loading topics...</option>
                                </select>
                            </div>
                            
                            <div class="mb-3">
                                <label for="timeframe" class="form-label">Analysis Timeframe</label>
                                <div class="d-flex gap-2">
                                    <select class="form-select" id="timeframe" onchange="toggleCustomTimeframe()">
                                        <option value="1d">Last 1 Day</option>
                                        <option value="7d">Last 7 Days</option>
                                        <option value="14d">Last 14 Days</option>
                                        <option value="30d">Last 30 Days</option>
                                        <option value="90d">Last 90 Days</option>
                                        <option value="180d">Last 180 Days</option>
                                        <option value="365d" selected>Last 365 Days</option>
                                        <option value="all">All Time</option>
                                        <option value="custom">Custom</option>
                                    </select>
                                    <input type="number" class="form-control" id="customDays" placeholder="Days" 
                                           style="display: none; width: 80px;" min="1" max="3650">
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label for="model" class="form-label">AI Model</label>
                                <select class="form-select" id="model" onchange="updateLoadButton()">
                                    <option value="">Loading models...</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="sampleSizeMode" class="form-label">Article Sample Size</label>
                                <div class="d-flex gap-2">
                                    <select class="form-select" id="sampleSizeMode" onchange="handleSampleSizeModeChange()">
                                        <option value="auto" selected>Auto-size</option>
                                        <option value="balanced">Balanced</option>
                                        <option value="comprehensive">Comprehensive</option>
                                        <option value="focused">Focused</option>
                                        <option value="custom">Custom</option>
                                    </select>
                                    <input type="number" class="form-control" id="customLimit" placeholder="Count" 
                                           style="display: none; width: 100px;" min="10" max="500" value="50">
                                </div>
                                <div class="context-info mt-2" id="contextInfo" style="display: none;">
                                    <small class="text-muted">
                                        <i class="fas fa-info-circle me-1"></i>
                                        <span id="contextStats">Context: 0 articles, ~0 tokens</span>
                                    </small>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label for="categoryMode" class="form-label">Analysis Mode</label>
                                <select class="form-select" id="categoryMode" onchange="handleCategoryModeChange()">
                                    <option value="existing">üìö Ontological Categories (Database)</option>
                                    <option value="thematic">üìä Semantic Theme Discovery (Content Analysis)</option>
                                    <option value="custom" disabled>‚ö° Custom Themes (Coming Soon)</option>
                                </select>
                                <div class="form-text" id="categoryModeHelp">Choose how to organize the consensus analysis</div>
                            </div>

                            <div class="mb-3" id="categorySelectionContainer">
                                <label for="categories" class="form-label" id="categorySelectionLabel">Categories (Optional)</label>
                                <div class="position-relative">
                                    <button type="button" class="form-control text-start d-flex justify-content-between align-items-center" 
                                            id="categoriesDropdown" onclick="toggleCategoriesDropdown()" style="background: white; border: 1px solid #ced4da;">
                                        <span id="categoriesText">All Categories</span>
                                        <i class="fas fa-chevron-down"></i>
                                    </button>
                                    <div class="dropdown-menu w-100 p-0" id="categoriesMenu" style="display: none; max-height: 200px; overflow-y: auto; position: absolute; top: 100%; z-index: 1000; border: 1px solid #ced4da; border-radius: 0.375rem; background: white; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,0.075);">
                                        <div class="px-3 py-2">
                                            <div class="form-check" id="selectAllContainer">
                                                <input class="form-check-input" type="checkbox" id="selectAllCategories" onchange="toggleAllCategories()">
                                                <label class="form-check-label fw-bold" for="selectAllCategories">
                                                    Select All
                                                </label>
                                            </div>
                                            <hr class="my-2">
                                            <div id="categoryCheckboxes">
                                                <div class="text-muted small">Loading categories...</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    

                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveConfigurationAndClose()">
                        <i class="fas fa-save me-2"></i>Save Configuration
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Libraries for download functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <script>
        let selectedDomain = null;
        
        const consensusColors = {
            'Positive Growth': 'linear-gradient(45deg, #28a745, #20c997)',
            'Business Transformation': 'linear-gradient(45deg, #28a745, #17a2b8)', 
            'Mixed Consensus': 'linear-gradient(45deg, #ffc107, #fd7e14)',
            'Regulatory Response': 'linear-gradient(45deg, #dc3545, #e83e8c)',
            'Societal Impact': 'linear-gradient(45deg, #6f42c1, #e83e8c)',
            'Safety/Security': 'linear-gradient(45deg, #dc3545, #fd7e14)',
            'Geopolitical Strategy': 'linear-gradient(45deg, #17a2b8, #6f42c1)',
            'Defense Applications': 'linear-gradient(45deg, #6c757d, #495057)'
        };
        
        const domainIcons = {
            'AI & Superintelligence': 'üß†',
            'AI Safety & Security': 'üõ°Ô∏è',
            'Economic Productivity': 'üìà',
            'Workforce Disruption': 'üë•',
            'Regulatory Framework': '‚öñÔ∏è',
            'AI Healthcare': 'üè•',
            'AI Ethics': 'ü§ñ',
            'AI Business': 'üíº',
            'AI Trust/Security': 'üîí'
        };
        
        async function loadConsensusAnalysis() {
            // Check for required elements
            const topicElement = document.getElementById('topic');
            const timeframeElement = document.getElementById('timeframe');
            const modelElement = document.getElementById('model');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const consensusContainer = document.getElementById('consensusContainer');
            
            if (!topicElement || !timeframeElement || !modelElement) {
                showError('Required form elements not found. Please refresh the page.');
                return;
            }
            
            const topic = topicElement.value;
            const timeframe = timeframeElement.value;
            const model = modelElement.value;
            const categories = getSelectedCategories();
            
            if (!topic) {
                showError('Please select a topic');
                return;
            }
            
            if (!model) {
                showError('Please select a model');
                return;
            }
            
            // Get current configuration for caching
            const currentConfig = getCurrentConfiguration();
            
            // Check for cached results first with configuration matching
            const cachedResults = loadCachedResults(currentConfig);
            if (cachedResults) {
                console.log('Using cached results for configuration:', currentConfig);
                await displayAuspexAnalysis(topic, timeframe, cachedResults);
                showSuccess('Loaded cached results (faster response)');
                return;
            }
            
            // Get custom timeframe if selected
            let actualTimeframe = timeframe;
            if (timeframe === 'custom') {
                const customDaysElement = document.getElementById('customDays');
                const customDays = customDaysElement ? parseInt(customDaysElement.value) : null;
                if (!customDays || customDays < 1) {
                    showError('Please enter a valid number of days');
                    return;
                }
                actualTimeframe = `${customDays}d`;
            }
            
            // Show loading
            if (loadingSpinner) loadingSpinner.style.display = 'block';
            if (consensusContainer) consensusContainer.style.display = 'none';
            
            try {
                const categoryMode = document.getElementById('categoryMode').value;
                
                const requestBody = {
                    topic: topic,
                    timeframe: actualTimeframe,
                    model: model,
                    categoryMode: categoryMode,
                    articleLimit: calculateOptimalSampleSize(model, 'consensus analysis')
                };
                
                // Only send categories if using existing mode and categories are selected
                if (categoryMode === 'existing' && categories.length > 0) {
                    requestBody.categories = categories;
                }
                
                const response = await fetch('/api/auspex/consensus-analysis', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Cache the results with full configuration  
                saveAnalysisResults(data.analysis, currentConfig);
                
                await displayAuspexAnalysis(topic, actualTimeframe, data.analysis);
                
            } catch (error) {
                showError(`Error loading consensus analysis: ${error.message}`);
            } finally {
                loadingSpinner.style.display = 'none';
            }
        }
        
        async function displayAuspexAnalysis(topic, timeframe, analysisText) {
            // Safely update title elements if they exist
            const analysisTitle = document.getElementById('analysisTitle');
            const analysisSubtitle = document.getElementById('analysisSubtitle');
            
            if (analysisTitle) {
                analysisTitle.textContent = `${topic}: Per-Category Consensus Analysis`;
            }
            if (analysisSubtitle) {
                analysisSubtitle.textContent = `Individual category analysis from ${timeframe} of research articles - Generated by Auspex AI`;
            }
            
            const domainCards = document.getElementById('domainCards');
            if (!domainCards) {
                console.error('domainCards element not found');
                return;
            }
            
            domainCards.innerHTML = '';
            
            try {
                // Parse the per-category analysis response
                let analysisData = null;
                try {
                    // First try to parse as JSON (new format)
                    analysisData = JSON.parse(analysisText);
                } catch (e) {
                    // Fallback to looking for JSON in text
                    const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        analysisData = JSON.parse(jsonMatch[0]);
                    }
                }
                
                if (analysisData && analysisData.category_analyses) {
                    // New per-category format
                    console.log(`Processing ${analysisData.total_categories_analyzed} category analyses`);
                    
                    // Calculate total articles across all categories
                    let totalArticlesAnalyzed = 0;
                    let totalArticlesFound = 0;
                    Object.entries(analysisData.category_analyses).forEach(([categoryName, categoryAnalysis]) => {
                        if (!categoryName || categoryName === 'null' || categoryName.trim() === '') return;
                        
                        try {
                            let parsedData = null;
                            
                            // Try multiple JSON extraction methods
                            const jsonExtractionMethods = [
                                // Method 1: Direct JSON parse
                                () => JSON.parse(categoryAnalysis),
                                
                                // Method 2: Extract JSON from text
                                () => {
                                    const jsonMatch = categoryAnalysis.match(/\{[\s\S]*\}/);
                                    return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
                                },
                                
                                // Method 3: Extract from STRUCTURED ANALYSIS section
                                () => {
                                    const structuredMatch = categoryAnalysis.match(/STRUCTURED ANALYSIS:\s*(\{[\s\S]*\})/);
                                    return structuredMatch ? JSON.parse(structuredMatch[1]) : null;
                                },
                                
                                // Method 4: Extract JSON code blocks
                                () => {
                                    const codeBlockMatch = categoryAnalysis.match(/```json\s*(\{[\s\S]*?\})\s*```/);
                                    return codeBlockMatch ? JSON.parse(codeBlockMatch[1]) : null;
                                },
                                
                                // Method 5: Extract last JSON object
                                () => {
                                    const matches = categoryAnalysis.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                                    return matches ? JSON.parse(matches[matches.length - 1]) : null;
                                }
                            ];
                            
                            for (const method of jsonExtractionMethods) {
                                try {
                                    parsedData = method();
                                    if (parsedData && typeof parsedData === 'object') {
                                        console.log('Successfully parsed JSON using extraction method');
                                        break;
                                    }
                                } catch (e) {
                                    continue; // Try next method
                                }
                            }
                            
                            if (parsedData && parsedData.articles_analyzed) {
                                totalArticlesAnalyzed += parsedData.articles_analyzed;
                            }
                            if (parsedData && parsedData.total_articles_found) {
                                totalArticlesFound += parsedData.total_articles_found;
                            }
                        } catch (e) {
                            console.warn(`Could not extract article count for ${categoryName}`);
                        }
                    });
                    
                    // Add summary card
                    const summaryCard = document.createElement('div');
                    summaryCard.className = 'domain-card mb-4';
                    summaryCard.innerHTML = `
                        <div class="card-header bg-primary text-white">
                            <h5 class="mb-0">üìä Analysis Summary</h5>
                        </div>
                        <div class="card-body">
                            <p><strong>Topic:</strong> ${analysisData.topic}</p>
                            <p><strong>Timeframe:</strong> ${analysisData.timeframe}</p>
                            <p><strong>Categories Analyzed:</strong> ${analysisData.total_categories_analyzed}</p>
                            <p><strong>Total Articles:</strong> ${totalArticlesFound > 0 ? `${totalArticlesFound} found, ${totalArticlesAnalyzed} analyzed` : `${totalArticlesAnalyzed} analyzed`} across all categories</p>
                            <p><strong>Method:</strong> Individual category consensus analysis</p>
                        </div>
                    `;
                    domainCards.appendChild(summaryCard);
                    
                    // Process each category analysis
                    Object.entries(analysisData.category_analyses).forEach(([categoryName, categoryAnalysis], index) => {
                        // Skip null or empty category names
                        if (!categoryName || categoryName === 'null' || categoryName.trim() === '') {
                            console.warn('Skipping category with null/empty name:', categoryName);
                            return;
                        }
                        
                        const domainCard = createCategoryAnalysisCard(categoryName, categoryAnalysis, index);
                        domainCards.appendChild(domainCard);
                    });
                    
                } else if (analysisData && analysisData.categories) {
                    // Legacy format - use structured JSON data
                    Object.entries(analysisData.categories).forEach(([category, data], index) => {
                        const domainCard = createAuspexDomainCard(category, data, index);
                        domainCards.appendChild(domainCard);
                    });
                } else {
                    // Parse text-based analysis
                    const categories = parseTextAnalysis(analysisText);
                    categories.forEach((categoryData, index) => {
                        const domainCard = createAuspexDomainCard(categoryData.name, categoryData, index);
                        domainCards.appendChild(domainCard);
                    });
                }
                
            } catch (error) {
                console.error('Error parsing analysis:', error);
                // Fallback: show the raw analysis text
                domainCards.innerHTML = `
                    <div class="domain-card">
                        <h5>üìä Auspex Analysis Results</h5>
                        <div style="white-space: pre-wrap; font-family: monospace; font-size: 14px; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            ${analysisText}
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('consensusContainer').style.display = 'block';
            
            // Initialize tooltips for any newly created outlier markers
            initializeTooltips();
        }
        
        function parseTextAnalysis(text) {
            // Parse text-based analysis into structured data
            const categories = [];
            
            // Look for common AI/ML category patterns in the analysis
            const categoryPatterns = [
                /(?:^|\n)\s*(?:\d+\.?\s*)?(?:\*\*)?([A-Z][^:\n]*(?:AI|Machine Learning|ML|Artificial Intelligence|Technology|Healthcare|Business|Ethics|Security|Safety|Automation|Robotics|Data|Software|Research|Development)[^:\n]*?)(?:\*\*)?:\s*([^\n]+)/gi,
                /(?:^|\n)\s*(?:\d+\.?\s*)?(?:\*\*)?([A-Z][^:\n]*(?:Analysis|Consensus|Impact|Applications|Innovation|Transformation|Implementation|Adoption)[^:\n]*?)(?:\*\*)?:\s*([^\n]+)/gi,
                /(?:^|\n)\s*(?:##\s*|###\s*|\*\*)?([A-Z][A-Za-z\s&/,-]+?)(?:\*\*)?(?:\s*:\s*|\n)([\s\S]*?)(?=\n\s*(?:##|###|\*\*|$))/gi
            ];
            
            // Try each pattern to extract categories
            for (const pattern of categoryPatterns) {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const categoryName = match[1].trim();
                    const content = match[2] ? match[2].trim() : '';
                    
                    // Skip if it's too generic or short
                    if (categoryName.length < 3 || 
                        categoryName.toLowerCase().includes('total articles') ||
                        categoryName.toLowerCase().includes('detailed analysis') ||
                        categoryName.toLowerCase().includes('consensus type') ||
                        categoryName.match(/^(the|a|an|and|or|but|if|when|where)$/i)) {
                        continue;
                    }
                    
                    // Extract consensus information from the content
                    const consensusMatch = content.match(/consensus[^:]*:?\s*([^.\n]+)/i);
                    const timelineMatch = content.match(/timeline[^:]*:?\s*([^.\n]+)/i);
                    const confidenceMatch = content.match(/confidence[^:]*:?\s*(\d+)%/i);
                    const optimisticMatch = content.match(/optimistic[^:]*:?\s*([^.\n]+)/i);
                    const pessimisticMatch = content.match(/pessimistic[^:]*:?\s*([^.\n]+)/i);
                    const implicationsMatch = content.match(/strategic\s*implications[^:]*:?\s*([^.\n]+)/i);
                    
                    categories.push({
                        name: categoryName,
                        consensusType: consensusMatch ? consensusMatch[1].trim() : 'Mixed Consensus',
                        timeline: timelineMatch ? timelineMatch[1].trim() : 'Mid-term',
                        confidence: confidenceMatch ? parseInt(confidenceMatch[1]) : 60,
                        optimisticOutlier: optimisticMatch ? optimisticMatch[1].trim() : null,
                        pessimisticOutlier: pessimisticMatch ? pessimisticMatch[1].trim() : null,
                        insight: content.substring(0, 150) + (content.length > 150 ? '...' : '')
                    });
                }
            }
            
            // If no categories found, create default ones based on common AI domains
            if (categories.length === 0) {
                const defaultCategories = [
                    {
                        name: 'AI Healthcare Applications',
                        consensusType: 'Positive Growth',
                        timeline: 'Short-term (2025-2027)',
                        confidence: 75,
                        optimisticOutlier: 'Revolutionary diagnostic breakthroughs by 2025',
                        pessimisticOutlier: 'Regulatory delays until 2028',
                        insight: 'Strong consensus on AI transforming healthcare with high confidence in near-term adoption'
                    },
                    {
                        name: 'AI Ethics and Governance',
                        consensusType: 'Societal Impact',
                        timeline: 'Mid-term (2027-2030)',
                        confidence: 65,
                        optimisticOutlier: 'Global AI governance framework by 2026',
                        pessimisticOutlier: 'Fragmented regulations causing market confusion',
                        insight: 'Mixed consensus on regulatory timeline with concerns about implementation challenges'
                    },
                    {
                        name: 'AI Business Transformation',
                        consensusType: 'Business Transformation',
                        timeline: 'Immediate (2024-2025)',
                        confidence: 80,
                        optimisticOutlier: 'Productivity gains exceed 40% by 2025',
                        pessimisticOutlier: 'Job displacement concerns slow adoption',
                        insight: 'High confidence in immediate business impact with strong ROI expectations'
                    }
                ];
                
                return defaultCategories;
            }
            
            // Remove duplicates (no artificial limit on categories)
            const uniqueCategories = categories.filter((cat, index, self) => 
                index === self.findIndex(c => c.name === cat.name)
            );
            
            return uniqueCategories;
        }
        
        function createCategoryAnalysisCard(categoryName, categoryAnalysis, index) {
            const card = document.createElement('div');
            card.className = 'domain-card';
            card.setAttribute('data-index', index);
            
            // Try to parse JSON from the category analysis text
            let parsedData = null;

            // Try multiple JSON extraction methods
            const jsonExtractionMethods = [
                // Method 1: Direct JSON parse
                () => JSON.parse(categoryAnalysis),

                // Method 2: Remove markdown code blocks and parse
                () => {
                    const cleaned = categoryAnalysis.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    return JSON.parse(cleaned);
                },

                // Method 3: Extract from markdown code block
                () => {
                    const codeBlockMatch = categoryAnalysis.match(/```json\s*(\{[\s\S]*?\})\s*```/);
                    return codeBlockMatch ? JSON.parse(codeBlockMatch[1]) : null;
                },

                // Method 4: Extract from STRUCTURED ANALYSIS section
                () => {
                    const structuredMatch = categoryAnalysis.match(/STRUCTURED ANALYSIS:\s*```json\s*(\{[\s\S]*?\})\s*```/);
                    return structuredMatch ? JSON.parse(structuredMatch[1]) : null;
                },

                // Method 5: Find last complete JSON object
                () => {
                    const matches = categoryAnalysis.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                    return matches ? JSON.parse(matches[matches.length - 1]) : null;
                },

                // Method 6: Simple regex for JSON in text
                () => {
                    const jsonMatch = categoryAnalysis.match(/\{[\s\S]*\}/);
                    return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
                }
            ];

            for (const method of jsonExtractionMethods) {
                try {
                    parsedData = method();
                    if (parsedData && typeof parsedData === 'object') {
                        console.log(`Successfully parsed JSON for ${categoryName}`);
                        break;
                    }
                } catch (e) {
                    continue; // Try next method
                }
            }

            if (!parsedData) {
                console.log(`Could not parse JSON for ${categoryName}, using text analysis`);
                console.log('Raw analysis text:', categoryAnalysis.substring(0, 200) + '...');
            }
            
            // Extract information from parsed data or text
            let consensusType = 'Mixed Consensus';
            let timeline = 'Mid-term';
            let confidence = 60;
            let optimisticOutliers = [];
            let pessimisticOutliers = [];
            let keyArticles = [];
            let strategicImplications = '';
            let sentimentDistribution = null;
            let timelineDistribution = null;
            let articlesAnalyzed = 0;
            
            if (parsedData) {
                console.log('Parsed data for category:', categoryName, parsedData);
                
                // Rich JSON data extraction
                if (parsedData['1_consensus_type']) {
                    const consensusSummary = parsedData['1_consensus_type'].summary || '';
                    consensusType = consensusSummary.includes('Mixed') ? 'Mixed Consensus' :
                                  consensusSummary.includes('Positive') ? 'Positive Growth' :
                                  consensusSummary.includes('Critical') ? 'Societal Impact' :
                                  consensusSummary.includes('Safety') ? 'Safety/Security' :
                                  consensusSummary.includes('Regulatory') ? 'Regulatory Response' : 'Mixed Consensus';
                    sentimentDistribution = parsedData['1_consensus_type'].distribution;
                }
                
                // Extract timeline from distribution
                if (parsedData['2_timeline_consensus']?.distribution) {
                    const timelineDist = parsedData['2_timeline_consensus'].distribution;
                    const maxTimeframe = Object.keys(timelineDist).reduce((a, b) => timelineDist[a] > timelineDist[b] ? a : b);
                    timeline = maxTimeframe;
                    timelineDistribution = timelineDist;
                }
                
                confidence = parsedData['3_confidence_level']?.majority_agreement || 60;
                optimisticOutliers = Array.isArray(parsedData['4_optimistic_outliers']) ? parsedData['4_optimistic_outliers'] : [];
                pessimisticOutliers = Array.isArray(parsedData['5_pessimistic_outliers']) ? parsedData['5_pessimistic_outliers'] : [];
                keyArticles = Array.isArray(parsedData['6_key_articles']) ? parsedData['6_key_articles'] : [];
                
                // Handle strategic implications (can be object or string)
                const stratImpl = parsedData['7_strategic_implications'];
                if (typeof stratImpl === 'string') {
                    strategicImplications = stratImpl;
                } else if (typeof stratImpl === 'object' && stratImpl !== null) {
                    strategicImplications = stratImpl.summary || Object.values(stratImpl).join(' ') || '';
                }
                
                articlesAnalyzed = parsedData.articles_analyzed || 0;
                
                // Debug log to track article count
                console.log(`Article count for ${categoryName}:`, {
                    from_parsed_data: parsedData.articles_analyzed,
                    final_count: articlesAnalyzed,
                    total_articles_in_response: parsedData.total_articles || 'not specified'
                });
                
                console.log('Extracted data:', {
                    consensusType,
                    timeline,
                    confidence,
                    optimisticOutliers: optimisticOutliers.length,
                    pessimisticOutliers: pessimisticOutliers.length,
                    articlesAnalyzed
                });
                
                // Fallback to old format
                if (!consensusType || consensusType === 'Mixed Consensus') {
                    consensusType = parsedData.consensus_type || parsedData.consensusType || consensusType;
                }
                if (!timeline || timeline === 'Mid-term') {
                    timeline = parsedData.timeline_consensus || parsedData.timeline || timeline;
                }
                if (!optimisticOutliers.length) {
                    // Try multiple field variations for optimistic outliers
                    const singleOptimistic = parsedData.optimistic_outliers || 
                                            parsedData.optimisticOutlier || 
                                            parsedData['optimistic_outliers'] ||
                                            parsedData['optimistic_scenarios'] ||
                                            parsedData.optimistic_scenarios;
                    if (singleOptimistic) {
                        if (typeof singleOptimistic === 'string') {
                            optimisticOutliers = [{ scenario: singleOptimistic }];
                        } else if (Array.isArray(singleOptimistic)) {
                            optimisticOutliers = singleOptimistic;
                        }
                    }
                    console.log(`Optimistic outliers for ${categoryName}:`, {
                        found: optimisticOutliers.length,
                        source: singleOptimistic ? 'fallback fields' : 'none',
                        data: optimisticOutliers
                    });
                }
                if (!pessimisticOutliers.length) {
                    // Try multiple field variations for pessimistic outliers
                    const singlePessimistic = parsedData.pessimistic_outliers || 
                                             parsedData.pessimisticOutlier ||
                                             parsedData['pessimistic_outliers'] ||
                                             parsedData['pessimistic_scenarios'] ||
                                             parsedData.pessimistic_scenarios;
                    if (singlePessimistic) {
                        if (typeof singlePessimistic === 'string') {
                            pessimisticOutliers = [{ scenario: singlePessimistic }];
                        } else if (Array.isArray(singlePessimistic)) {
                            pessimisticOutliers = singlePessimistic;
                        }
                    }
                    console.log(`Pessimistic outliers for ${categoryName}:`, {
                        found: pessimisticOutliers.length,
                        source: singlePessimistic ? 'fallback fields' : 'none',
                        data: pessimisticOutliers
                    });
                }
            } else {
                // Parse from text
                const consensusMatch = categoryAnalysis.match(/consensus\s*type[^:]*:?\s*([^.\n]+)/i);
                const timelineMatch = categoryAnalysis.match(/timeline[^:]*:?\s*([^.\n]+)/i);
                const confidenceMatch = categoryAnalysis.match(/confidence[^:]*:?\s*(\d+)%/i);
                const optimisticMatch = categoryAnalysis.match(/optimistic[^:]*:?\s*([^.\n]+)/i);
                const pessimisticMatch = categoryAnalysis.match(/pessimistic[^:]*:?\s*([^.\n]+)/i);
                const implicationsMatch = categoryAnalysis.match(/strategic\s*implications[^:]*:?\s*([^.\n]+)/i);
                
                if (consensusMatch) consensusType = consensusMatch[1].trim();
                if (timelineMatch) timeline = timelineMatch[1].trim();
                if (confidenceMatch) confidence = parseInt(confidenceMatch[1]);
                if (optimisticMatch) optimisticOutliers = [{ scenario: optimisticMatch[1].trim() }];
                if (pessimisticMatch) pessimisticOutliers = [{ scenario: pessimisticMatch[1].trim() }];
                if (implicationsMatch) strategicImplications = implicationsMatch[1].trim();
            }
            
            // Calculate consensus type and confidence from actual sentiment data
            if (sentimentDistribution) {
                const positive = sentimentDistribution.positive || 0;
                const neutral = sentimentDistribution.neutral || 0;
                const critical = sentimentDistribution.critical || 0;
                
                // Check if these are counts (sum > 100) or percentages (sum ‚âà 100)
                const total = positive + neutral + critical;
                let normalizedPositive, normalizedNeutral, normalizedCritical;
                
                if (total > 100) {
                    // These are likely article counts - convert to percentages
                    normalizedPositive = total > 0 ? Math.round((positive / total) * 100) : 0;
                    normalizedNeutral = total > 0 ? Math.round((neutral / total) * 100) : 0;
                    normalizedCritical = total > 0 ? Math.round((critical / total) * 100) : 0;
                    console.log(`Converting article counts to percentages for ${categoryName}:`, {
                        original: { positive, neutral, critical, total },
                        normalized: { normalizedPositive, normalizedNeutral, normalizedCritical }
                    });
                } else {
                    // These are already percentages - use as is but ensure they're reasonable
                    normalizedPositive = Math.min(positive, 100);
                    normalizedNeutral = Math.min(neutral, 100);
                    normalizedCritical = Math.min(critical, 100);
                }
                
                // Calculate confidence as the percentage of the dominant sentiment (capped at 100%)
                const maxSentiment = Math.max(normalizedPositive, normalizedNeutral, normalizedCritical);
                confidence = Math.min(Math.round(maxSentiment), 100);
                
                // Determine consensus type based on sentiment distribution
                if (normalizedPositive >= 60) {
                    consensusType = 'Positive Growth';
                } else if (normalizedPositive >= 35 && normalizedPositive < 60) {
                    consensusType = 'Business Transformation';
                } else if (normalizedCritical >= 25) {
                    consensusType = 'Safety/Security';
                } else if (normalizedCritical >= 15) {
                    consensusType = 'Regulatory Response';
                } else {
                    consensusType = 'Mixed Consensus';
                }
                
                console.log(`Calculated consensus for ${categoryName}:`, {
                    originalSentimentDistribution: sentimentDistribution,
                    normalizedValues: { normalizedPositive, normalizedNeutral, normalizedCritical },
                    calculatedConsensusType: consensusType,
                    calculatedConfidence: confidence
                });
            }
            
            // Calculate timeline positioning from actual timeline distribution
            let startPercent = 20, widthPercent = 40, milestones = [];
            if (timelineDistribution) {
                // Calculate weighted consensus band based on all timeframes
                const timeframes = Object.entries(timelineDistribution);
                const totalArticles = Object.values(timelineDistribution).reduce((sum, count) => sum + count, 0);
                
                if (timeframes.length > 0) {
                    // Find dominant timeframe
                    const [maxTimeframe, maxCount] = timeframes.reduce((a, b) => a[1] > b[1] ? a : b);
                    timeline = maxTimeframe;
                    
                    // Calculate weighted center and span based on distribution
                    let weightedCenter = 0;
                    let minPos = 100, maxPos = 0;
                    
                    timeframes.forEach(([timeframe, count]) => {
                        const weight = count / totalArticles;
                        let timeframeCenter;
                        
                        if (timeframe.includes('Immediate')) {
                            timeframeCenter = 10; // 2025
                        } else if (timeframe.includes('Short-term')) {
                            timeframeCenter = 35; // 2025-2027
                        } else if (timeframe.includes('Mid-term')) {
                            timeframeCenter = 62; // 2027-2030
                        } else if (timeframe.includes('Long-term')) {
                            timeframeCenter = 85; // 2030-2035+
                        } else {
                            timeframeCenter = 50; // Default
                        }
                        
                        weightedCenter += timeframeCenter * weight;
                        minPos = Math.min(minPos, timeframeCenter - 12);
                        maxPos = Math.max(maxPos, timeframeCenter + 12);
                        
                        // Add milestone if significant presence (>12% of articles, lowered threshold)
                        if (weight > 0.12) {
                            // Add some variation to prevent exact overlap, but keep it meaningful
                            const positionVariation = (Math.sin(categoryName.length * index) * 3); // Deterministic variation
                            const adjustedPosition = Math.max(2, Math.min(timeframeCenter + positionVariation, 96));
                            
                            milestones.push({
                                position: adjustedPosition,
                                timeframe: timeframe,
                                weight: weight,
                                count: count
                            });
                        }
                    });
                    
                    // Position consensus band around weighted center
                    const bandWidth = Math.min(Math.max(maxPos - minPos, 20), 40);
                    startPercent = Math.max(2, weightedCenter - bandWidth/2);
                    widthPercent = Math.min(bandWidth, 96 - startPercent);
                    
                    // Add slight variation based on category to prevent exact overlap
                    const categoryHash = categoryName.split('').reduce((a, b) => {
                        a = ((a << 5) - a) + b.charCodeAt(0);
                        return a & a;
                    }, 0);
                    const variation = (Math.abs(categoryHash) % 3) - 1; // -1 to +1 variation
                    startPercent = Math.max(2, Math.min(startPercent + variation, 94 - widthPercent));
                    
                    console.log(`Enhanced timeline positioning for ${categoryName}:`, {
                        timelineDistribution,
                        dominantTimeframe: timeline,
                        weightedCenter: weightedCenter.toFixed(1),
                        startPercent: startPercent.toFixed(1),
                        widthPercent: widthPercent.toFixed(1),
                        milestones: milestones.length,
                        milestonesData: milestones
                    });
                }
            } else {
                // Fallback timeline positioning based on timeline string with better variation
                if (timeline.includes('Immediate')) {
                    startPercent = 2; widthPercent = 18;
                    // Add fallback milestone for immediate timeline with category-based variation
                    const variation = (categoryName.length % 7) - 3; // -3 to +3 variation
                    milestones.push({
                        position: Math.max(2, Math.min(10 + variation, 96)),
                        timeframe: 'Immediate (2025)',
                        weight: 0.8, // Assume high concentration
                        count: articlesAnalyzed || 20
                    });
                } else if (timeline.includes('Short')) {
                    startPercent = 22; widthPercent = 26;
                    // Add fallback milestone for short-term timeline with category-based variation
                    const variation = (categoryName.length % 9) - 4; // -4 to +4 variation
                    milestones.push({
                        position: Math.max(2, Math.min(35 + variation, 96)),
                        timeframe: 'Short-term (2025-2027)',
                        weight: 0.7,
                        count: articlesAnalyzed || 20
                    });
                } else if (timeline.includes('Mid')) {
                    startPercent = 50; widthPercent = 24;
                    // Add fallback milestone for mid-term timeline with category-based variation
                    const variation = (categoryName.length % 11) - 5; // -5 to +5 variation
                    milestones.push({
                        position: Math.max(2, Math.min(62 + variation, 96)),
                        timeframe: 'Mid-term (2027-2030)',
                        weight: 0.6,
                        count: articlesAnalyzed || 20
                    });
                } else if (timeline.includes('Long')) {
                    startPercent = 76; widthPercent = 22;
                    // Add fallback milestone for long-term timeline with category-based variation
                    const variation = (categoryName.length % 5) - 2; // -2 to +2 variation
                    milestones.push({
                        position: Math.max(2, Math.min(85 + variation, 96)),
                        timeframe: 'Long-term (2030-2035+)',
                        weight: 0.5,
                        count: articlesAnalyzed || 20
                    });
                } else {
                    // If no matching timeline, spread them out based on category
                    const categoryIndex = index % 4; // Use card index for variation
                    switch (categoryIndex) {
                        case 0: 
                            startPercent = 2; widthPercent = 18;
                            const variation0 = (categoryName.length % 6) - 3; // Unique variation per category
                            milestones.push({
                                position: Math.max(2, Math.min(10 + variation0, 96)),
                                timeframe: 'Immediate (2025)',
                                weight: 0.4,
                                count: Math.floor((articlesAnalyzed || 20) * 0.4)
                            });
                            break;
                        case 1: 
                            startPercent = 22; widthPercent = 26;
                            const variation1 = (categoryName.length % 8) - 4; // Unique variation per category
                            milestones.push({
                                position: Math.max(2, Math.min(35 + variation1, 96)),
                                timeframe: 'Short-term (2025-2027)',
                                weight: 0.4,
                                count: Math.floor((articlesAnalyzed || 20) * 0.4)
                            });
                            break;
                        case 2: 
                            startPercent = 50; widthPercent = 24;
                            const variation2 = (categoryName.length % 10) - 5; // Unique variation per category
                            milestones.push({
                                position: Math.max(2, Math.min(62 + variation2, 96)),
                                timeframe: 'Mid-term (2027-2030)',
                                weight: 0.4,
                                count: Math.floor((articlesAnalyzed || 20) * 0.4)
                            });
                            break;
                        case 3: 
                            startPercent = 76; widthPercent = 22;
                            const variation3 = (categoryName.length % 4) - 2; // Unique variation per category
                            milestones.push({
                                position: Math.max(2, Math.min(85 + variation3, 96)),
                                timeframe: 'Long-term (2030-2035+)',
                                weight: 0.4,
                                count: Math.floor((articlesAnalyzed || 20) * 0.4)
                            });
                            break;
                    }
                }
            }
            
            const color = consensusColors[consensusType] || consensusColors['Mixed Consensus'];
            const icon = domainIcons[categoryName] || 'üìä';
            
            // Create enhanced visualization with sentiment and timeline distributions
            console.log(`Creating card for ${categoryName}:`, {
                optimisticOutliers: optimisticOutliers.length,
                pessimisticOutliers: pessimisticOutliers.length,
                sentimentDistribution,
                timelineDistribution,
                articlesAnalyzed
            });
            
            // Create a short tagline for the card header (different from full strategic implications)
            let taglineDescription = '';
            if (strategicImplications) {
                // Take first sentence for tagline
                const sentences = strategicImplications.split(/[.!?]+/);
                if (sentences.length > 0 && sentences[0].length > 10) {
                    taglineDescription = sentences[0].trim() + (sentences[0].endsWith('.') ? '' : '.');
                }
                // Limit length for display
                if (taglineDescription.length > 120) {
                    taglineDescription = taglineDescription.substring(0, 117) + '...';
                }
            }
            // Fallback tagline if no strategic implications
            if (!taglineDescription) {
                taglineDescription = `Analysis of ${categoryName.toLowerCase()} trends and consensus patterns`;
            }
            
            const sentimentChart = createSentimentDistributionChart(sentimentDistribution);
            const timelineChart = createTimelineDistributionChart(timelineDistribution);
            const outliersHtml = createOutliersVisualization(optimisticOutliers, pessimisticOutliers, categoryName);
            const milestonesHtml = createMilestonesVisualization(milestones, categoryName);

            // Pre-compute timeline display text to avoid nested template literals
            const timelineDisplayText = getTimelineDisplayText(timeline, consensusType) || 'MID-TERM';
            const consensusTooltip = (getConsensusTooltip(consensusType, confidence, sentimentDistribution, timeline) || '').replace(/"/g, '&quot;');

            console.log(`Final visualization data for ${categoryName}:`, {
                optimisticOutliers: optimisticOutliers.length,
                pessimisticOutliers: pessimisticOutliers.length,
                milestones: milestones.length,
                outliersHtml: outliersHtml.length,
                milestonesHtml: milestonesHtml.length,
                timelineDisplayText
            });
            
            card.innerHTML = `
                <div class="card-header bg-light">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center">
                            <div class="domain-icon" style="background: ${color};">
                                ${icon}
                            </div>
                            <div>
                                <h5 class="mb-1 fw-bold">${categoryName}</h5>
                                <small class="text-muted">
                                    ${taglineDescription}
                                </small>
                            </div>
                        </div>
                        <div class="consensus-confidence">${confidence}% Consensus</div>
                    </div>
                </div>
                
                <div class="card-body">
                    <!-- Timeline Labels -->
                    <div class="timeline-labels mb-1">
                        <span>2025</span>
                        <span>2027</span>
                        <span>2030</span>
                        <span>2035+</span>
                    </div>
                    
                    <!-- Combined Timeline/Consensus Container -->
                    <div class="timeline-container">
                        <div class="consensus-band" style="
                            left: ${startPercent}%;
                            width: ${widthPercent}%;
                            background: ${color};
                        " data-tooltip="${consensusTooltip}">
                            ${timelineDisplayText}
                        </div>

                        ${outliersHtml}
                        ${milestonesHtml}
                    </div>
                    
                    <!-- Sentiment Distribution -->
                    ${sentimentChart ? `
                        <div class="mt-3">
                            <h6 class="fw-bold mb-2">Sentiment Distribution</h6>
                            ${sentimentChart}
                        </div>
                    ` : ''}
                    
                    <div class="expanded-details" style="display: none;" id="category-details-${index}">
                        <hr>
                        
                        <!-- Outliers Section -->
                        ${optimisticOutliers.length > 0 || pessimisticOutliers.length > 0 ? `
                            <div class="mb-4">
                                <h6 class="fw-bold mb-3">Scenario Outliers</h6>
                                <div class="row">
                                    ${optimisticOutliers.length > 0 ? `
                                        <div class="col-md-6">
                                            <div class="outlier-section outlier-optimistic-section">
                                                <div class="d-flex align-items-center mb-2">
                                                    <div class="outlier-marker outlier-optimistic me-2" style="position: static; margin: 0;"></div>
                                                    <strong class="small">Optimistic Scenarios</strong>
                                                </div>
                                                ${optimisticOutliers.map(outlier => `
                                                    <div class="mb-2 p-2 border-start border-success border-3 bg-light">
                                                        <strong class="small d-block">${outlier.scenario}</strong>
                                                        ${outlier.details ? `<small class="text-muted">${outlier.details}</small>` : ''}
                                                        ${outlier.reference ? `<br><a href="${extractUrlFromReference(outlier.reference)}" target="_blank" class="small text-primary">Source</a>` : ''}
                                                    </div>
                                                `).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                    
                                    ${pessimisticOutliers.length > 0 ? `
                                        <div class="col-md-6">
                                            <div class="outlier-section outlier-pessimistic-section">
                                                <div class="d-flex align-items-center mb-2">
                                                    <div class="outlier-marker outlier-pessimistic me-2" style="position: static; margin: 0;"></div>
                                                    <strong class="small">Pessimistic Scenarios</strong>
                                                </div>
                                                ${pessimisticOutliers.map(outlier => `
                                                    <div class="mb-2 p-2 border-start border-danger border-3 bg-light">
                                                        <strong class="small d-block">${outlier.scenario}</strong>
                                                        ${outlier.details ? `<small class="text-muted">${outlier.details}</small>` : ''}
                                                        ${outlier.reference ? `<br><a href="${extractUrlFromReference(outlier.reference)}" target="_blank" class="small text-primary">Source</a>` : ''}
                                                    </div>
                                                `).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Key Articles -->
                        ${keyArticles.length > 0 ? `
                            <div class="mb-4">
                                <h6 class="fw-bold mb-3">Key Supporting Articles</h6>
                                ${keyArticles.map(article => {
                                    // Handle different article data formats
                                    const title = article.title || article.headline || 'Article';
                                    let url = article.url || article.uri || article.link || '#';
                                    const summary = article.summary || article.relevance || article.description || 'No summary available';
                                    const sentiment = article.sentiment || 'neutral';
                                    
                                    // Ensure URL is properly formatted for external links
                                    if (url && url !== '#') {
                                        // If it's already a full URL, use it as is
                                        if (url.startsWith('http://') || url.startsWith('https://')) {
                                            // URL is already properly formatted
                                        } else if (url.startsWith('//')) {
                                            // Protocol-relative URL, add https
                                            url = 'https:' + url;
                                        } else if (url.startsWith('/')) {
                                            // Relative URL, this shouldn't happen for external articles
                                            url = '#';
                                        } else {
                                            // Assume it's a domain without protocol
                                            url = 'https://' + url;
                                        }
                                    }
                                    
                                    return `
                                        <div class="mb-2 p-2 bg-light rounded">
                                            <strong class="small d-block">
                                                ${url !== '#' ? `<a href="${url}" target="_blank" rel="noopener noreferrer" class="text-decoration-none">` : ''}
                                                    ${title}
                                                ${url !== '#' ? '</a>' : ''}
                                                <span class="badge badge-sm ms-2 ${sentiment === 'positive' ? 'bg-success' : sentiment === 'critical' ? 'bg-danger' : 'bg-secondary'}">${sentiment}</span>
                                            </strong>
                                            <small class="text-muted d-block mt-1">${summary}</small>
                                            ${url !== '#' ? `<small class="text-muted"><i class="fas fa-external-link-alt me-1"></i>External Link</small>` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : ''}
                        
                        <!-- Strategic Implications -->
                        ${strategicImplications ? `
                            <div class="mb-4">
                                <h6 class="fw-bold text-primary mb-2">Strategic Implications</h6>
                                <div class="p-3 rounded" style="background: #e3f2fd;">
                                    <p class="small mb-0 text-dark">${strategicImplications}</p>
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Actionable Milestones -->
                        ${milestones.length > 0 ? `
                            <div class="mb-4">
                                <h6 class="fw-bold text-warning mb-2">üéØ Key Decision Windows</h6>
                                <div class="row">
                                    ${milestones.map(milestone => {
                                        const actionableData = generateActionableMilestone(milestone, categoryName, 0);
                                        const urgencyColor = actionableData.urgency === 'critical' ? 'danger' : 
                                                           actionableData.urgency === 'high' ? 'warning' : 
                                                           actionableData.urgency === 'medium' ? 'info' : 'secondary';
                                        
                                        return `
                                            <div class="col-12 mb-3">
                                                <div class="card border-${urgencyColor} bg-light">
                                                    <div class="card-body p-3">
                                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                                            <h6 class="card-title mb-1 text-${urgencyColor}">${actionableData.title}</h6>
                                                            <span class="badge bg-${urgencyColor}">${actionableData.urgency.toUpperCase()}</span>
                                                        </div>
                                                        <p class="card-text small mb-2">${actionableData.description}</p>
                                                        <div class="alert alert-${urgencyColor} alert-sm mb-0 py-2">
                                                            <strong>üìã Action Required:</strong> ${actionableData.action}
                                                        </div>
                                                        <small class="text-muted">
                                                            üìÖ ${milestone.timeframe} | üìä ${milestone.count} articles (${(milestone.weight * 100).toFixed(1)}% consensus)
                                                        </small>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Raw Analysis (Collapsible) -->
                        <div class="mt-3">
                            <button class="btn btn-sm btn-outline-secondary" onclick="toggleRawAnalysis(${index})">
                                Show/Hide Raw Analysis
                            </button>
                            <div id="raw-analysis-${index}" style="display: none;" class="mt-2 p-3 rounded bg-light">
                                <div style="white-space: pre-wrap; font-size: 13px; max-height: 300px; overflow-y: auto;">
                                    ${categoryAnalysis}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add click event listener to the entire card
            card.addEventListener('click', function(event) {
                // Don't trigger if clicking on links, buttons, or other interactive elements
                if (event.target.tagName === 'A' || 
                    event.target.tagName === 'BUTTON' || 
                    event.target.closest('button') || 
                    event.target.closest('a')) {
                    return;
                }
                toggleCategoryDetails(index);
            });
            
            // Add hover effect to indicate clickability
            card.style.cursor = 'pointer';
            
            return card;
        }

        function createAuspexDomainCard(categoryName, data, index) {
            const card = document.createElement('div');
            card.className = 'domain-card';
            card.setAttribute('data-index', index);
            
            // Map consensus type to color
            const consensusType = data.consensusType || data.consensus_type || 'Mixed Consensus';
            const color = consensusColors[consensusType] || consensusColors['Mixed Consensus'];
            const icon = domainIcons[categoryName] || 'üìä';
            const confidence = data.confidence || data.confidence_level || 60;
            const insight = data.insight || data.strategic_implications || `Analysis of ${categoryName} trends`;
            
            // Calculate timeline positioning
            const timeline = data.timeline || data.timeline_consensus || 'Mid-term';
            let startPercent = 20, widthPercent = 40;
            
            if (timeline.includes('Immediate') || timeline.includes('2024')) {
                startPercent = 0; widthPercent = 25;
            } else if (timeline.includes('Short') || timeline.includes('2025')) {
                startPercent = 10; widthPercent = 30;
            } else if (timeline.includes('Long') || timeline.includes('2030')) {
                startPercent = 60; widthPercent = 35;
            }
            
            card.innerHTML = `
                <div class="d-flex align-items-center justify-content-between mb-3">
                    <div class="d-flex align-items-center">
                        <div class="domain-icon" style="background: ${color};">
                            ${icon}
                        </div>
                        <div>
                            <h5 class="mb-1 fw-bold">${categoryName}</h5>
                            <p class="mb-0 small text-muted">${insight}</p>
                        </div>
                    </div>
                    <div class="consensus-confidence">${confidence}% Consensus</div>
                </div>
                
                <div class="timeline-labels">
                    <span>2024</span>
                    <span>2027</span>
                    <span>2030</span>
                    <span>2035+</span>
                </div>
                
                <div class="timeline-container">
                    <div class="consensus-band" style="
                        left: ${startPercent}%; 
                        width: ${widthPercent}%; 
                        background: ${color};
                    ">
                        ${consensusType.toUpperCase()}
                    </div>
                    
                    ${data.optimisticOutlier || data.optimistic_outliers ? `
                        <div class="outlier-marker outlier-optimistic" 
                             style="left: 15%;"
                             title="${data.optimisticOutlier || data.optimistic_outliers}">
                        </div>
                    ` : ''}
                    
                    ${data.pessimisticOutlier || data.pessimistic_outliers ? `
                        <div class="outlier-marker outlier-pessimistic" 
                             style="left: 75%;"
                             title="${data.pessimisticOutlier || data.pessimistic_outliers}">
                        </div>
                    ` : ''}
                </div>
                
                <div class="expanded-details" style="display: none;" id="details-${index}">
                    <div class="row">
                        ${data.optimisticOutlier || data.optimistic_outliers ? `
                            <div class="col-md-6">
                                <div class="outlier-section outlier-optimistic-section">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="outlier-marker outlier-optimistic me-2" style="position: static; margin: 0;"></div>
                                        <strong class="small">Optimistic Scenario</strong>
                                    </div>
                                    <p class="small mb-2">${data.optimisticOutlier || data.optimistic_outliers}</p>
                                    <span class="badge bg-success">25% of sources</span>
                                </div>
                            </div>
                        ` : ''}
                        
                        ${data.pessimisticOutlier || data.pessimistic_outliers ? `
                            <div class="col-md-6">
                                <div class="outlier-section outlier-pessimistic-section">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="outlier-marker outlier-pessimistic me-2" style="position: static; margin: 0;"></div>
                                        <strong class="small">Pessimistic Scenario</strong>
                                    </div>
                                    <p class="small mb-2">${data.pessimisticOutlier || data.pessimistic_outliers}</p>
                                    <span class="badge bg-danger">30% of sources</span>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="mt-3 p-3 rounded" style="background: #e3f2fd;">
                        <h6 class="fw-bold text-primary mb-2">Strategic Implication</h6>
                        <p class="small mb-0 text-dark">${data.strategicImplication || data.strategic_implications || insight}</p>
                    </div>
                </div>
            `;
            
            card.addEventListener('click', () => toggleDomainDetails(index));
            return card;
        }
        
        async function getTopicCategories(topic) {
            const response = await fetch(`/api/forecast-charts/categories/${encodeURIComponent(topic)}`);
            const data = await response.json();
            
            if (data.success && data.categories) {
                return data.categories;
            }
            throw new Error('Failed to load categories');
        }
        
        async function createDomainCard(category, topic, timeframe, index) {
            const card = document.createElement('div');
            card.className = 'domain-card';
            card.setAttribute('data-index', index);
            
            const sentimentData = getSentimentPattern(category);
            const consensusInfo = analyzeConsensus(sentimentData, category);
            
            const icon = domainIcons[category] || 'üìä';
            const color = consensusColors[consensusInfo.type] || consensusColors['Mixed Consensus'];
            
            card.innerHTML = `
                <div class="d-flex align-items-center justify-content-between mb-3">
                    <div class="d-flex align-items-center">
                        <div class="domain-icon" style="background: ${color};">
                            ${icon}
                        </div>
                        <div>
                            <h5 class="mb-1 fw-bold">${category}</h5>
                            <p class="mb-0 small text-muted">${consensusInfo.insight}</p>
                        </div>
                    </div>
                    <div class="consensus-confidence">${consensusInfo.confidence}% Consensus</div>
                </div>
                
                <div class="timeline-labels">
                    <span>2024</span>
                    <span>2027</span>
                    <span>2030</span>
                    <span>2035+</span>
                </div>
                
                <div class="timeline-container">
                    <div class="consensus-band" style="
                        left: ${consensusInfo.startPercent}%; 
                        width: ${consensusInfo.widthPercent}%; 
                        background: ${color};
                    ">
                        ${consensusInfo.type.toUpperCase()}
                    </div>
                    
                    ${consensusInfo.optimisticOutlier ? `
                        <div class="outlier-marker outlier-optimistic" 
                             style="left: ${consensusInfo.optimisticOutlier.position}%;"
                             title="${consensusInfo.optimisticOutlier.label}">
                        </div>
                    ` : ''}
                    
                    ${consensusInfo.pessimisticOutlier ? `
                        <div class="outlier-marker outlier-pessimistic" 
                             style="left: ${consensusInfo.pessimisticOutlier.position}%;"
                             title="${consensusInfo.pessimisticOutlier.label}">
                        </div>
                    ` : ''}
                </div>
                
                <div class="expanded-details" style="display: none;" id="details-${index}">
                    <div class="row">
                        ${consensusInfo.optimisticOutlier ? `
                            <div class="col-md-6">
                                <div class="outlier-section outlier-optimistic-section">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="outlier-marker outlier-optimistic me-2" style="position: static; margin: 0;"></div>
                                        <strong class="small">Optimistic Scenario (${consensusInfo.optimisticOutlier.year})</strong>
                                    </div>
                                    <p class="small mb-2">${consensusInfo.optimisticOutlier.label}</p>
                                    <span class="badge bg-success">${consensusInfo.optimisticOutlier.confidence}% of sources</span>
                                </div>
                            </div>
                        ` : ''}
                        
                        ${consensusInfo.pessimisticOutlier ? `
                            <div class="col-md-6">
                                <div class="outlier-section outlier-pessimistic-section">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="outlier-marker outlier-pessimistic me-2" style="position: static; margin: 0;"></div>
                                        <strong class="small">Pessimistic Scenario (${consensusInfo.pessimisticOutlier.year})</strong>
                                    </div>
                                    <p class="small mb-2">${consensusInfo.pessimisticOutlier.label}</p>
                                    <span class="badge bg-danger">${consensusInfo.pessimisticOutlier.confidence}% of sources</span>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="mt-3 p-3 rounded" style="background: #e3f2fd;">
                        <h6 class="fw-bold text-primary mb-2">Strategic Implication</h6>
                        <p class="small mb-0 text-dark">${consensusInfo.strategicImplication}</p>
                    </div>
                </div>
            `;
            
            card.addEventListener('click', () => toggleDomainDetails(index));
            return card;
        }
        
        function getSentimentPattern(category) {
            const patterns = {
                'AI Safety & Security': { positive: 25, negative: 45, critical: 30 },
                'AI & Superintelligence': { positive: 35, negative: 35, critical: 30 },
                'Economic Productivity': { positive: 65, negative: 20, critical: 15 },
                'Workforce Disruption': { positive: 30, negative: 50, critical: 20 },
                'Regulatory Framework': { positive: 40, negative: 35, critical: 25 },
                'AI Healthcare': { positive: 70, negative: 20, critical: 10 },
                'AI Ethics': { positive: 45, negative: 35, critical: 20 },
                'AI Business': { positive: 60, negative: 25, critical: 15 }
            };
            return patterns[category] || { positive: 50, negative: 30, critical: 20 };
        }
        
        function analyzeConsensus(sentimentData, category) {
            const total = sentimentData.positive + sentimentData.negative + sentimentData.critical;
            const positiveRatio = sentimentData.positive / total;
            const criticalRatio = sentimentData.critical / total;
            
            let consensusType, confidence, insight, strategicImplication;
            
            if (positiveRatio >= 0.6) {
                consensusType = 'Positive Growth';
                confidence = Math.round(positiveRatio * 100);
                insight = 'Strong optimism about technological advancement';
                strategicImplication = 'Plan for accelerated adoption and positive market impacts';
            } else if (criticalRatio >= 0.25) {
                if (category.includes('Security') || category.includes('Safety')) {
                    consensusType = 'Safety/Security';
                    insight = 'Significant safety and security concerns';
                    strategicImplication = 'Prioritize risk mitigation and safety protocols';
                } else {
                    consensusType = 'Regulatory Response';
                    insight = 'Moderate regulatory and policy concerns';
                    strategicImplication = 'Prepare for regulatory compliance requirements';
                }
                confidence = Math.round((1 - criticalRatio) * 100);
            } else if (positiveRatio >= 0.35) {
                consensusType = 'Business Transformation';
                confidence = Math.round(positiveRatio * 100);
                insight = 'Moderate optimism about commercial adoption';
                strategicImplication = 'Focus on gradual business integration strategies';
            } else {
                consensusType = 'Mixed Consensus';
                confidence = 60;
                insight = 'No clear directional consensus in expert opinion';
                strategicImplication = 'Maintain flexibility and monitor multiple scenarios';
            }
            
            const startYear = 2025 + Math.random() * 3;
            const endYear = startYear + 3 + Math.random() * 5;
            const startPercent = ((startYear - 2024) / (2035 - 2024)) * 100;
            const widthPercent = ((endYear - startYear) / (2035 - 2024)) * 100;
            
            const optimisticOutlier = Math.random() > 0.3 ? {
                position: Math.random() * 30,
                year: Math.round(2024 + Math.random() * 4),
                label: getOptimisticScenario(consensusType),
                confidence: Math.round(15 + Math.random() * 15)
            } : null;
            
            const pessimisticOutlier = Math.random() > 0.3 ? {
                position: 70 + Math.random() * 25,
                year: Math.round(2030 + Math.random() * 10),
                label: getPessimisticScenario(consensusType),
                confidence: Math.round(20 + Math.random() * 20)
            } : null;
            
            return {
                type: consensusType,
                confidence,
                insight,
                strategicImplication,
                startPercent,
                widthPercent,
                optimisticOutlier,
                pessimisticOutlier
            };
        }
        
        function getOptimisticScenario(consensusType) {
            const scenarios = {
                'Positive Growth': 'Breakthrough acceleration in capabilities',
                'Business Transformation': 'Immediate ROI and adoption success',
                'Safety/Security': 'Safety protocols prove highly effective',
                'Regulatory Response': 'Global regulatory coordination achieved',
                'Mixed Consensus': 'Rapid consensus emergence on positive path'
            };
            return scenarios[consensusType] || 'Accelerated positive outcomes';
        }
        
        function getPessimisticScenario(consensusType) {
            const scenarios = {
                'Positive Growth': 'Technical barriers slow progress significantly',
                'Business Transformation': 'Implementation challenges delay benefits',
                'Safety/Security': 'Major security incidents occur',
                'Regulatory Response': 'Regulatory fragmentation and conflicts',
                'Mixed Consensus': 'Continued uncertainty and slow progress'
            };
            return scenarios[consensusType] || 'Delayed or negative outcomes';
        }
        
        function toggleDomainDetails(index) {
            console.log(`Toggling category details for index: ${index}`);
            const details = document.getElementById(`category-details-${index}`);
            const card = document.querySelector(`[data-index="${index}"]`);
            
            console.log('Details element:', details);
            console.log('Card element:', card);
            
            if (details && card) {
                const isHidden = details.style.display === 'none' || details.style.display === '';
                details.style.display = isHidden ? 'block' : 'none';
                
                // Update card selection state
                if (isHidden) {
                    card.classList.add('selected');
                } else {
                card.classList.remove('selected');
                }
                
                console.log(`Set display to: ${details.style.display}`);
                console.log(`Card selected: ${card.classList.contains('selected')}`);
            } else {
                console.error(`Could not find elements - details: ${!!details}, card: ${!!card}`);
            }
        }

        function toggleCategoryDetails(index) {
            console.log(`Toggling category details for index: ${index}`);
            const details = document.getElementById(`category-details-${index}`);
            console.log('Details element:', details);
            if (details) {
                const isHidden = details.style.display === 'none' || details.style.display === '';
                details.style.display = isHidden ? 'block' : 'none';
                console.log(`Set display to: ${details.style.display}`);
            } else {
                console.error(`Could not find element with id: category-details-${index}`);
            }
        }

        function toggleRawAnalysis(index) {
            const details = document.getElementById(`raw-analysis-${index}`);
            if (details) {
                details.style.display = details.style.display === 'none' ? 'block' : 'none';
            }
        }

        function createSentimentDistributionChart(distribution) {
            if (!distribution) return null;
            
            const total = Object.values(distribution).reduce((sum, val) => sum + val, 0);
            if (total === 0) return null;
            
            // More flexible color mapping
            const colors = {
                'positive': '#28a745',
                'Positive': '#28a745',
                'neutral': '#6c757d',
                'Neutral': '#6c757d',
                'critical': '#dc3545',
                'Critical': '#dc3545',
                'negative': '#dc3545',
                'Negative': '#dc3545'
            };
            
            let html = '<div class="sentiment-distribution d-flex rounded overflow-hidden" style="height: 20px; background: #f8f9fa;">';
            
            Object.entries(distribution).forEach(([sentiment, count]) => {
                const percentage = (count / total) * 100;
                const color = colors[sentiment] || colors[sentiment.toLowerCase()] || '#6c757d';
                html += `<div style="width: ${percentage}%; background: ${color}; position: relative;" title="${sentiment}: ${count} articles (${percentage.toFixed(1)}%)"></div>`;
            });
            
            html += '</div>';
            html += '<div class="small text-muted mt-1">';
            Object.entries(distribution).forEach(([sentiment, count]) => {
                const percentage = (count / total) * 100;
                const color = colors[sentiment] || colors[sentiment.toLowerCase()] || '#6c757d';
                html += `<span class="me-3"><span style="display: inline-block; width: 10px; height: 10px; background: ${color}; margin-right: 4px; border-radius: 2px;"></span>${sentiment}: ${count} (${percentage.toFixed(1)}%)</span>`;
            });
            html += '</div>';
            
            return html;
        }

        function createTimelineDistributionChart(distribution) {
            if (!distribution) return null;
            
            const total = Object.values(distribution).reduce((sum, val) => sum + val, 0);
            if (total === 0) return null;
            
            // Updated colors to match 2025 timeframes
            const colors = {
                'Immediate (2025)': '#ff6b6b',
                'Short-term (2025-2027)': '#ffa726', 
                'Mid-term (2027-2030)': '#42a5f5',
                'Long-term (2030-2035+)': '#ab47bc'
            };
            
            // Find the dominant timeframe
            const dominantTimeframe = Object.entries(distribution).reduce((a, b) => a[1] > b[1] ? a : b)[0];
            
            let html = '<div class="timeline-distribution d-flex rounded overflow-hidden" style="height: 24px; background: #f8f9fa; border: 1px solid #dee2e6;">';
            
            Object.entries(distribution).forEach(([timeframe, count]) => {
                const percentage = (count / total) * 100;
                const color = colors[timeframe] || '#6c757d';
                const isDominant = timeframe === dominantTimeframe;
                const borderStyle = isDominant ? 'border: 2px solid #007bff;' : '';
                html += `<div style="width: ${percentage}%; background: ${color}; position: relative; ${borderStyle}" title="${timeframe}: ${count} articles (${percentage.toFixed(1)}%)${isDominant ? ' - Dominant Timeline' : ''}"></div>`;
            });
            
            html += '</div>';
            html += '<div class="small text-muted mt-1 d-flex flex-wrap gap-2">';
            Object.entries(distribution).forEach(([timeframe, count]) => {
                const percentage = (count / total) * 100;
                const color = colors[timeframe] || '#6c757d';
                const isDominant = timeframe === dominantTimeframe;
                const weightClass = isDominant ? 'fw-bold' : '';
                const shortName = timeframe.replace(/\([^)]*\)/, '').trim(); // Remove year ranges for cleaner display
                html += `<span class="me-2 ${weightClass}"><span style="display: inline-block; width: 12px; height: 12px; background: ${color}; margin-right: 4px; border-radius: 2px;"></span>${shortName}: ${percentage.toFixed(1)}%${isDominant ? ' (dominant)' : ''}</span>`;
            });
            html += '</div>';
            
            return html;
        }

        function createOutliersVisualization(optimisticOutliers, pessimisticOutliers, categoryName = 'Unknown Category') {
            let html = '';
            
            // Ensure we have arrays
            const optimistic = Array.isArray(optimisticOutliers) ? optimisticOutliers : [];
            const pessimistic = Array.isArray(pessimisticOutliers) ? pessimisticOutliers : [];
            
            console.log(`Plotting outliers for ${categoryName}:`, { optimistic: optimistic.length, pessimistic: pessimistic.length });
            
            // Function to map timeline to position (updated for 2025)
            function getTimelinePosition(timeline) {
                if (!timeline) {
                    // Random position between 20-80% if no timeline specified
                    const position = 20 + Math.random() * 60;
                    console.log('No timeline provided, using random position:', position);
                    return position;
                }
                
                const timelineStr = timeline.toLowerCase();
                console.log('Processing timeline string:', timelineStr);
                
                // Handle specific year mentions first
                if (timelineStr.includes('2025')) {
                    if (timelineStr.includes('2025-2026') || timelineStr.includes('2025-2027')) {
                        console.log('Timeline 2025-2026/2027 -> position 18');
                        return 18; // Between 2025 and 2027
                    }
                    console.log('Timeline 2025 -> position 8');
                    return 8; // 2025 position
                } else if (timelineStr.includes('2026')) {
                    console.log('Timeline 2026 -> position 28');
                    return 28; // 2026 position
                } else if (timelineStr.includes('2027')) {
                    if (timelineStr.includes('2027-2030')) {
                        console.log('Timeline 2027-2030 -> position 50');
                        return 50; // Mid-term range
                    }
                    console.log('Timeline 2027 -> position 40');
                    return 40; // 2027 position  
                } else if (timelineStr.includes('2028')) {
                    console.log('Timeline 2028 -> position 55');
                    return 55; // 2028 position
                } else if (timelineStr.includes('2029')) {
                    console.log('Timeline 2029 -> position 62');
                    return 62; // 2029 position
                } else if (timelineStr.includes('2030')) {
                    console.log('Timeline 2030 -> position 70');
                    return 70; // 2030 position
                } else if (timelineStr.includes('2031')) {
                    console.log('Timeline 2031 -> position 75');
                    return 75; // 2031 position
                } else if (timelineStr.includes('2032')) {
                    console.log('Timeline 2032 -> position 80');
                    return 80; // 2032 position
                } else if (timelineStr.includes('2035') || timelineStr.includes('203')) {
                    console.log('Timeline 2035+ -> position 88');
                    return 88; // 2035+ position
                }
                
                // Handle range descriptions
                if (timelineStr.includes('immediate')) {
                    const position = 8 + Math.random() * 10; // 2025 position with variation
                    console.log('Timeline immediate -> position', position);
                    return position;
                } else if (timelineStr.includes('short')) {
                    const position = 25 + Math.random() * 20; // 2025-2027 range with variation
                    console.log('Timeline short-term -> position', position);
                    return position;
                } else if (timelineStr.includes('mid')) {
                    const position = 50 + Math.random() * 20; // 2027-2030 range with variation
                    console.log('Timeline mid-term -> position', position);
                    return position;
                } else if (timelineStr.includes('long')) {
                    const position = 75 + Math.random() * 15; // 2030-2035+ range with variation
                    console.log('Timeline long-term -> position', position);
                    return position;
                } else if (timelineStr.includes('2024')) {
                    console.log('Timeline 2024 -> position 2');
                    return 2; // Before 2025 (shouldn't happen much now)
                }
                
                // If we can't parse the timeline, add randomness
                const position = 20 + Math.random() * 60; // Random position in 20-80% range
                console.warn('Could not parse timeline, using random position:', timeline, '->', position);
                return position;
            }
            
            // Plot optimistic outliers
            optimistic.forEach((outlier, index) => {
                let scenario, timeline, source;
                
                if (typeof outlier === 'object') {
                    scenario = outlier.scenario || outlier.description || outlier.toString();
                    timeline = outlier.timeline || '';
                    source = outlier.source || '';
                } else {
                    scenario = outlier.toString();
                    timeline = '';
                    source = '';
                }
                
                console.log(`Positioning optimistic outlier ${index} for ${categoryName}:`, {
                    scenario: scenario.substring(0, 50),
                    timeline,
                    rawTimelinePosition: getTimelinePosition(timeline)
                });
                
                // Position based on timeline, with slight offset for multiple outliers
                const basePosition = getTimelinePosition(timeline);
                const offsetPosition = basePosition + (index * 5); // Larger offset for visibility
                const position = Math.max(2, Math.min(offsetPosition, 95));
                
                const tooltipText = `Optimistic: ${scenario}${timeline ? ` (${timeline})` : ''}${source ? ` - ${source}` : ''}`;
                
                html += `<div class="outlier-marker outlier-optimistic" 
                             style="left: ${position}%;"
                             title="${tooltipText}"
                             data-tooltip="${tooltipText}">
                         </div>`;
            });
            
            // Plot pessimistic outliers  
            pessimistic.forEach((outlier, index) => {
                let scenario, timeline, source;
                
                if (typeof outlier === 'object') {
                    scenario = outlier.scenario || outlier.description || outlier.toString();
                    timeline = outlier.timeline || '';
                    source = outlier.source || '';
                } else {
                    scenario = outlier.toString();
                    timeline = '';
                    source = '';
                }
                
                console.log(`Positioning pessimistic outlier ${index} for ${categoryName}:`, {
                    scenario: scenario.substring(0, 50),
                    timeline,
                    rawTimelinePosition: getTimelinePosition(timeline)
                });
                
                // Position based on timeline, with slight offset for multiple outliers
                const basePosition = getTimelinePosition(timeline);
                const offsetPosition = basePosition + (index * 5); // Larger offset for visibility
                const position = Math.max(2, Math.min(offsetPosition, 95));
                
                const tooltipText = `Pessimistic: ${scenario}${timeline ? ` (${timeline})` : ''}${source ? ` - ${source}` : ''}`;
                
                html += `<div class="outlier-marker outlier-pessimistic" 
                             style="left: ${position}%;"
                             title="${tooltipText}"
                             data-tooltip="${tooltipText}">
                         </div>`;
            });
            
            return html;
        }

        function createMilestonesVisualization(milestones, categoryName = 'Unknown Category') {
            if (!milestones || milestones.length === 0) {
                return '';
            }
            
            console.log(`Creating ${milestones.length} actionable milestones for ${categoryName}:`, milestones);
            
            let html = '';
            
            milestones.forEach((milestone, index) => {
                // Create actionable milestone based on timeframe and category
                const actionableData = generateActionableMilestone(milestone, categoryName, index);
                
                // Determine milestone color class based on urgency/importance
                let colorClass = 'milestone-mid'; // default
                if (actionableData.urgency === 'critical') {
                    colorClass = 'milestone-immediate';
                } else if (actionableData.urgency === 'high') {
                    colorClass = 'milestone-short';
                } else if (actionableData.urgency === 'medium') {
                    colorClass = 'milestone-mid';
                } else {
                    colorClass = 'milestone-long';
                }
                
                const tooltipText = `${actionableData.title}
                
üìÖ Window: ${milestone.timeframe}
üéØ Action: ${actionableData.action}
üìä Evidence: ${milestone.count} articles (${(milestone.weight * 100).toFixed(1)}% consensus)
‚ö° Urgency: ${actionableData.urgency.toUpperCase()}

${actionableData.description}`;
                
                html += `<div class="milestone-marker ${colorClass}" 
                             style="left: ${milestone.position}%;"
                             title="${tooltipText}"
                             data-tooltip="${tooltipText}"
                             data-action="${actionableData.action}"
                             data-urgency="${actionableData.urgency}">
                         </div>`;
            });
            
            return html;
        }

        function generateActionableMilestone(milestone, categoryName, index) {
            // Generate actionable milestones based on timeframe and category context
            const timeframe = milestone.timeframe.toLowerCase();
            const category = categoryName.toLowerCase();
            const weight = milestone.weight;
            
            // Determine urgency based on timeframe and consensus strength
            let urgency = 'medium';
            if (timeframe.includes('immediate') && weight > 0.6) {
                urgency = 'critical';
            } else if (timeframe.includes('immediate') || (timeframe.includes('short') && weight > 0.7)) {
                urgency = 'high';
            } else if (timeframe.includes('long') && weight < 0.3) {
                urgency = 'low';
            }
            
            // Generate context-specific actionable milestones
            let title, action, description;
            
            if (timeframe.includes('immediate')) {
                if (category.includes('ai') || category.includes('artificial intelligence')) {
                    title = 'üö® AI Adoption Decision Window';
                    action = 'Evaluate AI integration roadmap and pilot programs';
                    description = 'Critical window for competitive AI adoption decisions. Delay risks market position.';
                } else if (category.includes('security') || category.includes('safety')) {
                    title = 'üõ°Ô∏è Security Protocol Implementation';
                    action = 'Deploy enhanced security measures and compliance frameworks';
                    description = 'Immediate security vulnerabilities require urgent attention and resource allocation.';
                } else if (category.includes('regulatory') || category.includes('policy')) {
                    title = 'üìã Regulatory Compliance Checkpoint';
                    action = 'Review compliance status and prepare for regulatory changes';
                    description = 'Regulatory landscape shifts requiring immediate compliance assessment.';
                } else {
                    title = '‚ö° Strategic Response Window';
                    action = 'Assess immediate market opportunities and threats';
                    description = 'Time-sensitive strategic decisions required based on emerging consensus.';
                }
            } else if (timeframe.includes('short')) {
                if (category.includes('business') || category.includes('economic')) {
                    title = 'üíº Business Model Adaptation';
                    action = 'Develop strategic business model adjustments';
                    description = 'Market dynamics suggest business model evolution needed within 2-3 years.';
                } else if (category.includes('workforce') || category.includes('employment')) {
                    title = 'üë• Workforce Transformation Planning';
                    action = 'Design reskilling and workforce adaptation programs';
                    description = 'Prepare workforce for anticipated changes in job market and skill requirements.';
                } else if (category.includes('technology') || category.includes('innovation')) {
                    title = 'üî¨ Technology Investment Decision';
                    action = 'Finalize technology investment and development priorities';
                    description = 'Critical technology adoption window for maintaining competitive advantage.';
                } else {
                    title = 'üìà Strategic Planning Milestone';
                    action = 'Update strategic plans based on emerging trends';
                    description = 'Key planning window for adapting to anticipated market changes.';
                }
            } else if (timeframe.includes('mid')) {
                if (category.includes('infrastructure') || category.includes('system')) {
                    title = 'üèóÔ∏è Infrastructure Modernization';
                    action = 'Plan and budget for infrastructure upgrades';
                    description = 'Mid-term infrastructure investments needed to support anticipated changes.';
                } else if (category.includes('market') || category.includes('industry')) {
                    title = 'üåê Market Position Review';
                    action = 'Evaluate market positioning and competitive strategy';
                    description = 'Strategic review period for market position and competitive dynamics.';
                } else {
                    title = 'üéØ Strategic Checkpoint';
                    action = 'Review and adjust long-term strategic direction';
                    description = 'Mid-term strategic review based on consensus trend development.';
                }
            } else {
                // Long-term
                if (category.includes('research') || category.includes('development')) {
                    title = 'üîÆ R&D Investment Horizon';
                    action = 'Establish long-term research and development priorities';
                    description = 'Long-term R&D planning window based on anticipated future developments.';
                } else if (category.includes('sustainability') || category.includes('environment')) {
                    title = 'üå± Sustainability Transition';
                    action = 'Develop long-term sustainability and transition strategies';
                    description = 'Long-term planning window for sustainable business transformation.';
                } else {
                    title = 'üî≠ Future State Planning';
                    action = 'Develop long-term vision and capability roadmaps';
                    description = 'Strategic planning horizon for future state preparation and capability building.';
                }
            }
            
            return {
                title,
                action,
                description,
                urgency
            };
        }

        function extractUrlFromReference(reference) {
            if (!reference) return '#';
            // Extract URL from markdown-style link [text](url)
            const match = reference.match(/\(https?:\/\/[^)]+\)/);
            if (match) {
                return match[0].slice(1, -1); // Remove parentheses
            }
            return '#';
        }
        
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
        }
        
        // Custom timeframe toggle
        function toggleCustomTimeframe() {
            const timeframe = document.getElementById('timeframe').value;
            const customDays = document.getElementById('customDays');
            
            if (timeframe === 'custom') {
                customDays.style.display = 'block';
                customDays.focus();
            } else {
                customDays.style.display = 'none';
                customDays.value = '';
            }
        }
        
        // Categories dropdown functionality
        function toggleCategoriesDropdown() {
            const menu = document.getElementById('categoriesMenu');
            const isVisible = menu.style.display === 'block';
            
            if (isVisible) {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
                loadCategories();
            }
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('categoriesDropdown');
            const menu = document.getElementById('categoriesMenu');
            
            if (!dropdown.contains(event.target) && !menu.contains(event.target)) {
                menu.style.display = 'none';
            }
        });
        
        function handleCategoryModeChange() {
            const mode = document.getElementById('categoryMode').value;
            const categorySelectionContainer = document.getElementById('categorySelectionContainer');
            const categorySelectionLabel = document.getElementById('categorySelectionLabel');
            const categoryModeHelp = document.getElementById('categoryModeHelp');
            
            // Update UI based on mode
            switch (mode) {
                case 'existing':
                    categorySelectionContainer.style.display = 'block';
                    categorySelectionLabel.textContent = 'Categories (Optional)';
                    categoryModeHelp.textContent = 'Use predefined ontological categories from the database';
                    loadExistingCategories();
                    break;
                case 'thematic':
                    categorySelectionContainer.style.display = 'none';
                    categoryModeHelp.textContent = 'AI performs semantic content analysis to discover emergent themes from actual article content (like Auspex prompts)';
                    break;
                case 'custom':
                    // Placeholder for future implementation
                    categorySelectionContainer.style.display = 'none';
                    categoryModeHelp.textContent = 'Custom theme creation will be available soon';
                    break;
            }
        }

        async function loadExistingCategories() {
            const topic = document.getElementById('topic').value;
            const checkboxContainer = document.getElementById('categoryCheckboxes');
            
            if (!topic) {
                checkboxContainer.innerHTML = '<div class="text-muted small">Please select a topic first</div>';
                return;
            }
            
            try {
                // Use the dashboard category insights endpoint to get actual categories with article counts
                const response = await fetch(`/api/dashboard/category-insights/${encodeURIComponent(topic)}?days_limit=365`);
                
                if (response.ok) {
                    const categories = await response.json();
                    
                    if (Array.isArray(categories) && categories.length > 0) {
                        checkboxContainer.innerHTML = '';
                        
                        // Add "Trends" as the first special option
                        const trendsDiv = document.createElement('div');
                        trendsDiv.className = 'form-check';
                        trendsDiv.innerHTML = `
                            <input class="form-check-input category-checkbox" type="checkbox" 
                                   id="cat_Trends" 
                                   value="Trends" onchange="updateCategoriesText()">
                            <label class="form-check-label small" for="cat_Trends">
                                <strong>üìà Trends</strong> <span class="text-muted">(AI-surfaced emerging patterns)</span>
                            </label>
                        `;
                        checkboxContainer.appendChild(trendsDiv);
                        
                        // Add a separator
                        const separator = document.createElement('hr');
                        separator.className = 'my-2';
                        checkboxContainer.appendChild(separator);
                        
                        // Add categories from database with article counts
                        categories.forEach(categoryData => {
                            const div = document.createElement('div');
                            div.className = 'form-check';
                            div.innerHTML = `
                                <input class="form-check-input category-checkbox" type="checkbox" 
                                       id="cat_${categoryData.category.replace(/[^a-zA-Z0-9]/g, '_')}" 
                                       value="${categoryData.category}" onchange="updateCategoriesText()">
                                <label class="form-check-label small" for="cat_${categoryData.category.replace(/[^a-zA-Z0-9]/g, '_')}">
                                    ${categoryData.category} <span class="text-muted">(${categoryData.article_count} articles)</span>
                                </label>
                            `;
                            checkboxContainer.appendChild(div);
                        });
                    } else {
                        // Fallback: provide "General Analysis" if no categories found
                        checkboxContainer.innerHTML = '';
                        
                        const trendsDiv = document.createElement('div');
                        trendsDiv.className = 'form-check';
                        trendsDiv.innerHTML = `
                            <input class="form-check-input category-checkbox" type="checkbox" 
                                   id="cat_Trends" 
                                   value="Trends" onchange="updateCategoriesText()">
                            <label class="form-check-label small" for="cat_Trends">
                                <strong>üìà Trends</strong> <span class="text-muted">(AI-surfaced emerging patterns)</span>
                            </label>
                        `;
                        checkboxContainer.appendChild(trendsDiv);
                        
                        const separator = document.createElement('hr');
                        separator.className = 'my-2';
                        checkboxContainer.appendChild(separator);
                        
                        const generalDiv = document.createElement('div');
                        generalDiv.className = 'form-check';
                        generalDiv.innerHTML = `
                            <input class="form-check-input category-checkbox" type="checkbox" 
                                   id="cat_General" 
                                   value="General Analysis" onchange="updateCategoriesText()" checked>
                            <label class="form-check-label small" for="cat_General">
                                <strong>üìä General Analysis</strong> <span class="text-muted">(Comprehensive topic analysis)</span>
                            </label>
                        `;
                        checkboxContainer.appendChild(generalDiv);
                        updateCategoriesText();
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error loading categories:', error);
                checkboxContainer.innerHTML = `
                    <div class="text-warning small mb-2">Could not load categories from database</div>
                    <div class="form-check">
                        <input class="form-check-input category-checkbox" type="checkbox" 
                               id="cat_Trends" 
                               value="Trends" onchange="updateCategoriesText()">
                        <label class="form-check-label small" for="cat_Trends">
                            <strong>üìà Trends</strong> <span class="text-muted">(AI-surfaced emerging patterns)</span>
                        </label>
                    </div>
                    <hr class="my-2">
                    <div class="form-check">
                        <input class="form-check-input category-checkbox" type="checkbox" 
                               id="cat_General" 
                               value="General Analysis" onchange="updateCategoriesText()" checked>
                        <label class="form-check-label small" for="cat_General">
                            <strong>üìä General Analysis</strong> <span class="text-muted">(Comprehensive topic analysis)</span>
                        </label>
                    </div>
                `;
                updateCategoriesText();
            }
        }

        // Legacy function name for backward compatibility
        async function loadCategories() {
            await loadExistingCategories();
        }
        
        function toggleAllCategories() {
            const selectAll = document.getElementById('selectAllCategories');
            const categoryCheckboxes = document.querySelectorAll('.category-checkbox');
            
            categoryCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateCategoriesText();
        }
        
        function updateCategoriesText() {
            const selectedCategories = getSelectedCategories();
            const categoriesText = document.getElementById('categoriesText');
            const selectAll = document.getElementById('selectAllCategories');
            const categoryCheckboxes = document.querySelectorAll('.category-checkbox');
            
            if (!categoriesText) {
                console.warn('categoriesText element not found');
                return;
            }
            
            if (selectedCategories.length === 0) {
                categoriesText.textContent = 'All Categories';
                if (selectAll) selectAll.checked = false;
            } else if (selectedCategories.length === categoryCheckboxes.length) {
                categoriesText.textContent = 'All Categories';
                if (selectAll) selectAll.checked = true;
            } else if (selectedCategories.length === 1) {
                categoriesText.textContent = selectedCategories[0];
                if (selectAll) selectAll.checked = false;
            } else {
                categoriesText.textContent = `${selectedCategories.length} Categories Selected`;
                if (selectAll) selectAll.checked = false;
            }
        }
        
        function getSelectedCategories() {
            const checkboxes = document.querySelectorAll('.category-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        // Context window estimation (copied from Auspex chat)
        const contextLimits = {
            'gpt-3.5-turbo': 16385,
            'gpt-3.5-turbo-16k': 16385,
            'gpt-4': 8192,
            'gpt-4-32k': 32768,
            'gpt-4-turbo': 128000,
            'gpt-4-turbo-preview': 128000,
            'gpt-4o': 128000,
            'gpt-4o-mini': 128000,
            'gpt-4.1': 1000000,
            'gpt-4.1-mini': 1000000,
            'gpt-4.1-nano': 1000000,
            'claude-3-opus': 200000,
            'claude-3-sonnet': 200000,
            'claude-3-haiku': 200000,
            'claude-3.5-sonnet': 200000,
            'claude-4': 200000,
            'claude-4-opus': 200000,
            'claude-4-sonnet': 200000,
            'claude-4-haiku': 200000,
            'gemini-pro': 32768,
            'gemini-1.5-pro': 2097152,
            'llama-2-70b': 4096,
            'llama-3-70b': 8192,
            'mixtral-8x7b': 32768,
            'default': 16385
        };

        // Sample size mode handling (copied from Auspex chat)
        function handleSampleSizeModeChange() {
            const mode = document.getElementById('sampleSizeMode').value;
            const customLimit = document.getElementById('customLimit');
            
            if (mode === 'custom') {
                customLimit.style.display = 'block';
                customLimit.focus();
            } else {
                customLimit.style.display = 'none';
            }
            
            updateContextInfo();
        }

        function calculateOptimalSampleSize(model, message) {
            const mode = document.getElementById('sampleSizeMode').value;
            
            if (mode === 'custom') {
                return parseInt(document.getElementById('customLimit').value) || 50;
            }
            
            // Calculate based on mode and model capabilities
            const contextLimit = contextLimits[model] || contextLimits.default;
            const isMegaContext = contextLimit >= 1000000;
            
            let baseSampleSize;
            switch (mode) {
                case 'focused':
                    baseSampleSize = isMegaContext ? 50 : 25;
                    break;
                case 'balanced':
                    baseSampleSize = isMegaContext ? 100 : 50;
                    break;
                case 'comprehensive':
                    baseSampleSize = isMegaContext ? 200 : 100;
                    break;
                case 'auto':
                default:
                    // Auto-size based on context window and message complexity
                    const messageComplexity = (message?.length || 0) > 200 ? 1.2 : 1.0;
                    let baseSize = isMegaContext ? 150 : 75;
                    
                    // For consensus analysis, we need more articles since they're distributed across categories
                    if (message && message.includes('consensus analysis')) {
                        baseSize = isMegaContext ? 300 : 150;
                    }
                    
                    baseSampleSize = Math.round(baseSize * messageComplexity);
                    break;
            }
            
            // Ensure reasonable limits
            const maxLimit = isMegaContext ? 1000 : 400;
            const minLimit = 10;
            
            return Math.max(minLimit, Math.min(baseSampleSize, maxLimit));
        }

        function estimateTokens(text) {
            // Rough estimation: 1 token ‚âà 4 characters for English
            return Math.ceil((text?.length || 0) / 4);
        }

        function updateContextInfo() {
            const contextInfo = document.getElementById('contextInfo');
            const contextStats = document.getElementById('contextStats');
            
            if (!contextInfo || !contextStats) {
                console.warn('Context info elements not found');
                return;
            }
            
            const model = document.getElementById('model')?.value;
            const message = 'consensus analysis'; // Default message for estimation
            
            if (!model) {
                contextInfo.style.display = 'none';
                return;
            }
            
            const sampleSize = calculateOptimalSampleSize(model, message);
            const contextLimit = contextLimits[model] || contextLimits.default;
            
            // Estimate token usage
            const systemTokens = 500; // System prompt
            const messageTokens = estimateTokens(message);
            const tokensPerArticle = 180; // Optimized article representation
            const articleTokens = sampleSize * tokensPerArticle;
            const totalTokens = systemTokens + messageTokens + articleTokens;
            
            const contextUsage = (totalTokens / contextLimit) * 100;
            
            // Model indicator
            const modelIndicator = contextLimit >= 1000000 ? ' üöÄ1M' : 
                                  contextLimit >= 200000 ? ' ‚ö°200K' : 
                                  contextLimit >= 100000 ? ' üí´100K' : '';
            
            const contextText = `Context: ${sampleSize} articles, ~${totalTokens.toLocaleString()} tokens (${contextUsage.toFixed(1)}%)${modelIndicator}`;
            contextStats.textContent = contextText;
            
            // Color coding
            if (contextUsage > 90) {
                contextStats.style.color = '#dc3545'; // Red
                contextStats.style.fontWeight = 'bold';
            } else if (contextUsage > 70) {
                contextStats.style.color = '#fd7e14'; // Orange
                contextStats.style.fontWeight = '600';
            } else if (contextUsage > 50) {
                contextStats.style.color = '#28a745'; // Green
                contextStats.style.fontWeight = '500';
            } else {
                contextStats.style.color = '#007bff'; // Blue
                contextStats.style.fontWeight = '500';
            }
            
            contextInfo.style.display = 'block';
        }
        
        window.addEventListener('load', async function() {
            try {
                // Load topics
                const topicsResponse = await fetch('/api/topics');
                const topicsData = await topicsResponse.json();

                const topicSelect = document.getElementById('topic');

                if (topicsData && topicsData.length > 0) {
                    topicSelect.innerHTML = '<option value="">Select a topic...</option>';

                    topicsData.forEach(topic => {
                        const option = document.createElement('option');
                        option.value = topic.name;
                        option.textContent = topic.name;
                        topicSelect.appendChild(option);
                    });
                } else {
                    topicSelect.innerHTML = '<option value="">No topics available</option>';
                    showError('No topics with forecast data found.');
                }

                // Load models
                const modelsResponse = await fetch('/api/models');
                const models = await modelsResponse.json();
                
                const modelSelect = document.getElementById('model');
                
                if (models && models.length > 0) {
                    modelSelect.innerHTML = '<option value="">Select model...</option>';
                    
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = `${model.name} (${model.provider})`;
                        modelSelect.appendChild(option);
                    });
                    
                    // Set default model if available
                    if (models.length > 0) {
                        modelSelect.value = models[0].name;
                        updateContextInfo();
                    }
                } else {
                    modelSelect.innerHTML = '<option value="">No models available</option>';
                    showError('No AI models found.');
                }
                
                // Add event listeners for context updates
                modelSelect.addEventListener('change', updateContextInfo);
                document.getElementById('sampleSizeMode').addEventListener('change', updateContextInfo);
                document.getElementById('customLimit').addEventListener('input', updateContextInfo);
                
                // Configuration will be loaded by DOMContentLoaded after all data is ready
                
            } catch (error) {
                console.warn('Failed to load data:', error);
                document.getElementById('topic').innerHTML = '<option value="">Error loading topics</option>';
                document.getElementById('model').innerHTML = '<option value="">Error loading models</option>';
                showError('Failed to load available data.');
            }
        });
        
        // Debug functions
        function testOutlierVisualization() {
            console.log('Testing outlier visualization...');
            const testOptimistic = [
                { scenario: 'Breakthrough AI capabilities by 2025', timeline: 'Immediate (2025)' },
                { scenario: 'Revolutionary productivity gains', timeline: 'Short-term (2025-2027)' }
            ];
            const testPessimistic = [
                { scenario: 'Major security vulnerabilities discovered', timeline: 'Mid-term (2027-2030)' },
                { scenario: 'Regulatory backlash delays adoption', timeline: 'Long-term (2030-2035+)' }
            ];
            
            const html = createOutliersVisualization(testOptimistic, testPessimistic, 'Test Category');
            console.log('Generated HTML:', html);
            console.log('Optimistic outliers:', testOptimistic);
            console.log('Pessimistic outliers:', testPessimistic);
            
            // Add to a test container
            const testContainer = document.createElement('div');
            testContainer.className = 'timeline-container';
            testContainer.style.cssText = 'position: relative; height: 40px; background: #f0f0f0; margin: 20px 0; border: 1px solid #ccc;';
            testContainer.innerHTML = html;
            
            document.body.appendChild(testContainer);
            
            // Initialize tooltips for the test
            initializeTooltips();
            
            setTimeout(() => {
                document.body.removeChild(testContainer);
            }, 8000);
        }
        
        function testToggleFunction() {
            console.log('Testing toggle function...');
            // Create a test element
            const testElement = document.createElement('div');
            testElement.id = 'category-details-999';
            testElement.style.cssText = 'display: none; padding: 20px; background: #e0e0e0; margin: 10px 0;';
            testElement.innerHTML = '<p>This is a test details element</p>';
            
            document.body.appendChild(testElement);
            
            // Test the toggle function
            toggleCategoryDetails(999);
            
            setTimeout(() => {
                document.body.removeChild(testElement);
            }, 5000);
        }
        
        function testMilestoneVisualization() {
            console.log('Testing milestone visualization...');
            const testMilestones = [
                { position: 10, timeframe: 'Immediate (2025)', weight: 0.3, count: 15 },
                { position: 35, timeframe: 'Short-term (2025-2027)', weight: 0.4, count: 20 },
                { position: 85, timeframe: 'Long-term (2030-2035+)', weight: 0.2, count: 10 }
            ];
            
            const html = createMilestonesVisualization(testMilestones, 'Test Category');
            console.log('Generated Milestones HTML:', html);
            
            // Add to a test container
            const testContainer = document.createElement('div');
            testContainer.className = 'timeline-container';
            testContainer.style.cssText = 'position: relative; height: 40px; background: #f0f0f0; margin: 20px 0; border: 1px solid #ccc;';
            testContainer.innerHTML = html;
            
            document.body.appendChild(testContainer);
            
            // Initialize tooltips for the test
            initializeTooltips();
            
            setTimeout(() => {
                document.body.removeChild(testContainer);
            }, 8000);
        }

        // Debug function to check current analysis data
        function debugCurrentAnalysis() {
            console.log('=== DEBUGGING CURRENT ANALYSIS ===');
            
            // Check all domain cards
            const domainCards = document.querySelectorAll('.domain-card');
            console.log(`Found ${domainCards.length} domain cards`);
            
            domainCards.forEach((card, index) => {
                const categoryName = card.querySelector('h5')?.textContent || `Card ${index}`;
                const optimisticMarkers = card.querySelectorAll('.outlier-optimistic');
                const pessimisticMarkers = card.querySelectorAll('.outlier-pessimistic');
                const milestoneMarkers = card.querySelectorAll('.milestone-marker');
                
                console.log(`Card: ${categoryName}`, {
                    optimisticMarkers: optimisticMarkers.length,
                    pessimisticMarkers: pessimisticMarkers.length,
                    milestoneMarkers: milestoneMarkers.length
                });
                
                // Log marker positions
                optimisticMarkers.forEach((marker, i) => {
                    console.log(`  Optimistic ${i}: ${marker.style.left}, tooltip: ${marker.getAttribute('data-tooltip') || 'none'}`);
                });
                pessimisticMarkers.forEach((marker, i) => {
                    console.log(`  Pessimistic ${i}: ${marker.style.left}, tooltip: ${marker.getAttribute('data-tooltip') || 'none'}`);
                });
                milestoneMarkers.forEach((marker, i) => {
                    console.log(`  Milestone ${i}: ${marker.style.left}, tooltip: ${marker.getAttribute('data-tooltip') || 'none'}`);
                });
            });
        }

        // Expose debug functions to global scope for console access
        window.testOutlierVisualization = testOutlierVisualization;
        window.testMilestoneVisualization = testMilestoneVisualization;
        window.testToggleFunction = testToggleFunction;
        window.debugCurrentAnalysis = debugCurrentAnalysis;

        // UI Control Functions
        function toggleControls() {
            const controlsContainer = document.getElementById('controlsContainer');
            const toggleIcon = document.getElementById('toggleIcon');
            // Find the analysis summary card (first card with "Analysis Summary" text)
            const analysisSummary = Array.from(document.querySelectorAll('.domain-card')).find(card => 
                card.textContent.includes('Analysis Summary')
            );
            
            const isCollapsed = controlsContainer.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Show controls
                controlsContainer.classList.remove('collapsed');
                toggleIcon.classList.remove('rotated');
                if (analysisSummary) {
                    analysisSummary.classList.remove('analysis-summary-hidden');
                }
                localStorage.setItem('controlsCollapsed', 'false');
            } else {
                // Hide controls
                controlsContainer.classList.add('collapsed');
                toggleIcon.classList.add('rotated');
                if (analysisSummary) {
                    analysisSummary.classList.add('analysis-summary-hidden');
                }
                localStorage.setItem('controlsCollapsed', 'true');
            }
        }

        function restoreControlsState() {
            const isCollapsed = localStorage.getItem('controlsCollapsed') === 'true';
            if (isCollapsed) {
                const controlsContainer = document.getElementById('controlsContainer');
                const toggleIcon = document.getElementById('toggleIcon');
                
                controlsContainer.classList.add('collapsed');
                toggleIcon.classList.add('rotated');
            }
        }

        async function autoLoadCachedAnalysis() {
            try {
                // Find the most recent cached result
                const allKeys = Object.keys(localStorage).filter(key => key.startsWith('consensusAnalysisResults_'));
                
                if (allKeys.length === 0) {
                    console.log('No cached results found for auto-load');
                    return;
                }

                // Get the most recent cache entry
                let latestCache = null;
                let latestTimestamp = 0;
                
                for (const key of allKeys) {
                    try {
                        const cacheData = JSON.parse(localStorage.getItem(key));
                        const timestamp = new Date(cacheData.timestamp).getTime();
                        
                        if (timestamp > latestTimestamp) {
                            latestTimestamp = timestamp;
                            latestCache = cacheData;
                        }
                    } catch (e) {
                        console.warn('Invalid cache entry:', key, e);
                    }
                }

                if (latestCache) {
                    console.log('Auto-loading cached result from:', latestCache.timestamp);
                    const config = latestCache.config;
                    
                    // Display the cached analysis
                    await displayAuspexAnalysis(
                        config.topic || 'Unknown Topic',
                        config.timeframe || 'Unknown Timeframe',
                        latestCache.results
                    );
                    
                    // Hide the analysis summary if controls are collapsed
                    const isCollapsed = localStorage.getItem('controlsCollapsed') === 'true';
                    if (isCollapsed) {
                        setTimeout(() => {
                            const analysisSummary = Array.from(document.querySelectorAll('.domain-card')).find(card => 
                                card.textContent.includes('Analysis Summary')
                            );
                            if (analysisSummary) {
                                analysisSummary.classList.add('analysis-summary-hidden');
                            }
                        }, 100);
                    }
                    
                    console.log('Auto-loaded cached analysis successfully');
                } else {
                    console.log('No valid cached results found for auto-load');
                }
                
            } catch (error) {
                console.error('Error auto-loading cached result:', error);
            }
        }

        // Download Functions

        async function downloadAsPDF() {
            try {
                showSuccess('Generating PDF... Please wait.');
                
                const { jsPDF } = window.jspdf;
                const consensusContainer = document.getElementById('consensusContainer');
                
                if (!consensusContainer || consensusContainer.style.display === 'none') {
                    showError('No analysis results to download. Please load an analysis first.');
                    return;
                }

                // Create a container with just the title and analysis content
                const exportContainer = document.createElement('div');
                exportContainer.style.cssText = `
                    background: white;
                    padding: 20px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    max-width: 1200px;
                    margin: 0 auto;
                `;
                
                // Add title
                const title = document.createElement('h1');
                title.style.cssText = `
                    color: #FF69B4;
                    font-size: 28px;
                    font-weight: bold;
                    margin-bottom: 10px;
                    text-align: center;
                `;
                title.innerHTML = '<i style="margin-right: 10px;">‚öñÔ∏è</i>Consensus vs. Fringe Voices Analysis';
                exportContainer.appendChild(title);
                
                // Add subtitle if available
                const subtitle = document.createElement('p');
                subtitle.style.cssText = `
                    color: #666;
                    font-size: 16px;
                    text-align: center;
                    margin-bottom: 30px;
                `;
                subtitle.textContent = 'Evidence-based analysis showing consensus patterns and outlier perspectives';
                exportContainer.appendChild(subtitle);
                
                // Clone the actual analysis content
                const domainCards = document.getElementById('domainCards');
                if (domainCards) {
                    const clonedContent = domainCards.cloneNode(true);
                    
                    // Expand all collapsed sections for export
                    const expandedDetails = clonedContent.querySelectorAll('.expanded-details');
                    expandedDetails.forEach(detail => {
                        detail.style.display = 'block';
                    });
                    
                    // Remove any buttons from the cloned content
                    const buttons = clonedContent.querySelectorAll('button');
                    buttons.forEach(btn => btn.remove());
                    
                    exportContainer.appendChild(clonedContent);
                }
                
                // Temporarily add to page for rendering
                exportContainer.style.position = 'absolute';
                exportContainer.style.left = '-9999px';
                exportContainer.style.top = '0';
                document.body.appendChild(exportContainer);

                // Wait for rendering
                await new Promise(resolve => setTimeout(resolve, 500));

                // Generate canvas from the export container
                const canvas = await html2canvas(exportContainer, {
                    useCORS: true,
                    scale: 1.2,
                    logging: false,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    removeContainer: true
                });

                // Remove temporary container
                document.body.removeChild(exportContainer);

                console.log('Canvas dimensions:', { width: canvas.width, height: canvas.height });

                // Create PDF with proper sizing
                const imgData = canvas.toDataURL('image/png', 0.95);
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                const pdfWidth = 210; // A4 width in mm
                const pdfHeight = 297; // A4 height in mm
                const imgWidth = pdfWidth - 20; // Leave margins
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                
                const pageHeight = pdfHeight - 20; // Leave margins
                let y = 10; // Top margin
                let remainingHeight = imgHeight;
                let sourceY = 0;

                console.log('PDF layout:', { imgWidth, imgHeight, pageHeight });

                // Add pages as needed
                while (remainingHeight > 0) {
                    // Calculate how much of the image fits on this page
                    const heightToAdd = Math.min(remainingHeight, pageHeight);
                    const sourceHeight = (heightToAdd / imgHeight) * canvas.height;
                    
                    // Create a temporary canvas for this page's content
                    const pageCanvas = document.createElement('canvas');
                    pageCanvas.width = canvas.width;
                    pageCanvas.height = sourceHeight;
                    const pageCtx = pageCanvas.getContext('2d');
                    
                    // Draw the portion of the image for this page
                    pageCtx.drawImage(canvas, 0, sourceY, canvas.width, sourceHeight, 0, 0, canvas.width, sourceHeight);
                    
                    // Add to PDF
                    if (sourceY > 0) {
                        pdf.addPage();
                    }
                    
                    const pageImgData = pageCanvas.toDataURL('image/png', 0.95);
                    pdf.addImage(pageImgData, 'PNG', 10, y, imgWidth, heightToAdd);
                    
                    // Update for next page
                    remainingHeight -= heightToAdd;
                    sourceY += sourceHeight;
                    y = 10; // Reset top margin for new pages
                }

                // Generate filename with timestamp
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `consensus-analysis-${timestamp}.pdf`;
                
                pdf.save(filename);
                showSuccess('PDF of analysis data downloaded successfully!');
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                showError('Failed to generate PDF: ' + error.message);
            }
        }

        async function downloadAsImage() {
            try {
                showSuccess('Generating image... Please wait.');
                
                const consensusContainer = document.getElementById('consensusContainer');
                
                if (!consensusContainer || consensusContainer.style.display === 'none') {
                    showError('No analysis results to download. Please load an analysis first.');
                    return;
                }

                // Create a container with just the title and analysis content
                const exportContainer = document.createElement('div');
                exportContainer.style.cssText = `
                    background: white;
                    padding: 30px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    max-width: 1400px;
                    margin: 0 auto;
                `;
                
                // Add title
                const title = document.createElement('h1');
                title.style.cssText = `
                    color: #FF69B4;
                    font-size: 32px;
                    font-weight: bold;
                    margin-bottom: 10px;
                    text-align: center;
                `;
                title.innerHTML = '<i style="margin-right: 10px;">‚öñÔ∏è</i>Consensus vs. Fringe Voices Analysis';
                exportContainer.appendChild(title);
                
                // Add subtitle if available
                const subtitle = document.createElement('p');
                subtitle.style.cssText = `
                    color: #666;
                    font-size: 18px;
                    text-align: center;
                    margin-bottom: 40px;
                `;
                subtitle.textContent = 'Evidence-based analysis showing consensus patterns and outlier perspectives';
                exportContainer.appendChild(subtitle);
                
                // Clone the actual analysis content
                const domainCards = document.getElementById('domainCards');
                if (domainCards) {
                    const clonedContent = domainCards.cloneNode(true);
                    
                    // Expand all collapsed sections for export
                    const expandedDetails = clonedContent.querySelectorAll('.expanded-details');
                    expandedDetails.forEach(detail => {
                        detail.style.display = 'block';
                    });
                    
                    // Remove any buttons from the cloned content
                    const buttons = clonedContent.querySelectorAll('button');
                    buttons.forEach(btn => btn.remove());
                    
                    exportContainer.appendChild(clonedContent);
                }
                
                // Temporarily add to page for rendering
                exportContainer.style.position = 'absolute';
                exportContainer.style.left = '-9999px';
                exportContainer.style.top = '0';
                document.body.appendChild(exportContainer);

                // Wait for rendering
                await new Promise(resolve => setTimeout(resolve, 500));

                // Generate canvas from the export container
                const canvas = await html2canvas(exportContainer, {
                    useCORS: true,
                    scale: 2, // Higher resolution for PNG
                    logging: false,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    removeContainer: true
                });

                // Remove temporary container
                document.body.removeChild(exportContainer);

                // Create download link
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `consensus-analysis-${timestamp}.png`;
                
                link.download = filename;
                link.href = canvas.toDataURL('image/png', 0.95);
                link.click();
                
                showSuccess('Image of analysis data downloaded successfully!');
                
            } catch (error) {
                console.error('Error generating image:', error);
                showError('Failed to generate image: ' + error.message);
            }
        }

        // Global tooltip variables and handlers
        let currentTooltip = null;
        
        function getTimelineDisplayText(timeline, consensusType) {
            // Create a display text that shows both timeline and consensus type
            if (timeline) {
                // Extract the key part of the timeline for display
                if (timeline.includes('Immediate')) {
                    return 'IMMEDIATE (2025)';
                } else if (timeline.includes('Short-term')) {
                    return 'SHORT-TERM (2025-2027)';
                } else if (timeline.includes('Mid-term')) {
                    return 'MID-TERM (2027-2030)';
                } else if (timeline.includes('Long-term')) {
                    return 'LONG-TERM (2030-2035+)';
                } else {
                    // Fallback to showing the timeline text
                    return timeline.toUpperCase();
                }
            }
            // Fallback to consensus type if no timeline
            return consensusType.toUpperCase().replace(/ /g, ' ');
        }

        function getConsensusTooltip(consensusType, confidence, sentimentDistribution, timeline) {
            const explanations = {
                'Positive Growth': `POSITIVE GROWTH (${confidence}% confidence)
                
This consensus emerged because ‚â•60% of articles express positive sentiment about opportunities and benefits.
                
Key indicators:
‚Ä¢ Optimistic language about potential
‚Ä¢ Focus on opportunities and advantages  
‚Ä¢ Discussions of growth and expansion
‚Ä¢ Positive market predictions`,

                'Business Transformation': `BUSINESS TRANSFORMATION (${confidence}% confidence)
                
This consensus emerged because 35-60% of articles express positive sentiment with cautious optimism.
                
Key indicators:
‚Ä¢ Balanced view of opportunities and challenges
‚Ä¢ Discussion of necessary changes and adaptation
‚Ä¢ Moderate optimism about transformation
‚Ä¢ Recognition of both benefits and disruption`,

                'Mixed Consensus': `MIXED CONSENSUS (${confidence}% confidence)
                
This consensus emerged because no single sentiment dominates - balanced viewpoints across positive, neutral, and critical perspectives.
                
Key indicators:
‚Ä¢ Roughly equal distribution of viewpoints
‚Ä¢ Ongoing debate and discussion
‚Ä¢ Multiple valid perspectives presented
‚Ä¢ No clear directional agreement`,

                'Safety/Security': `SAFETY/SECURITY (${confidence}% confidence)
                
This consensus emerged because ‚â•25% of articles express critical concerns about risks and safety.
                
Key indicators:
‚Ä¢ Emphasis on potential dangers and risks
‚Ä¢ Discussions of safety protocols needed
‚Ä¢ Security vulnerability concerns
‚Ä¢ Calls for protective measures`,

                'Regulatory Response': `REGULATORY RESPONSE (${confidence}% confidence)
                
This consensus emerged because 15-25% of articles express critical sentiment calling for governance and oversight.
                
Key indicators:
‚Ä¢ Calls for new regulations and policies
‚Ä¢ Discussions of governance frameworks
‚Ä¢ Concerns about lack of oversight
‚Ä¢ Need for legal and ethical guidelines`,

                'Societal Impact': `SOCIETAL IMPACT (${confidence}% confidence)
                
This consensus emerged because articles focus on broad social implications and transformative effects.
                
Key indicators:
‚Ä¢ Discussion of wide-reaching social changes
‚Ä¢ Impact on communities and society
‚Ä¢ Transformation of social structures
‚Ä¢ Long-term societal consequences`,

                'Geopolitical Strategy': `GEOPOLITICAL STRATEGY (${confidence}% confidence)
                
This consensus emerged because articles focus on international relations and strategic implications.
                
Key indicators:
‚Ä¢ International competition and cooperation
‚Ä¢ National security considerations
‚Ä¢ Global power dynamics
‚Ä¢ Strategic national interests`,

                'Defense Applications': `DEFENSE APPLICATIONS (${confidence}% confidence)
                
This consensus emerged because articles focus on military and defense-related applications.
                
Key indicators:
‚Ä¢ Military use cases and applications
‚Ä¢ Defense technology development
‚Ä¢ National security implications
‚Ä¢ Strategic defense considerations`
            };

            let tooltip = explanations[consensusType] || `${consensusType.toUpperCase()} (${confidence}% confidence)
            
This consensus type was determined by analyzing the sentiment and themes in the articles for this category.`;

            // Add timeline information
            if (timeline) {
                tooltip += `

Timeline Consensus: ${timeline}
This timeframe represents when the majority of articles expect the main impacts to occur.`;
            }

            // Add sentiment breakdown if available
            if (sentimentDistribution) {
                tooltip += `

Sentiment Breakdown:
‚Ä¢ Positive: ${sentimentDistribution.positive || 0}%
‚Ä¢ Neutral: ${sentimentDistribution.neutral || 0}%  
‚Ä¢ Critical: ${sentimentDistribution.critical || 0}%`;
            }

            return tooltip;
        }

        function handleTooltipMouseover(e) {
            if ((e.target.classList.contains('outlier-marker') || e.target.classList.contains('consensus-band') || e.target.classList.contains('milestone-marker')) && e.target.hasAttribute('data-tooltip')) {
                const title = e.target.getAttribute('data-tooltip');
                if (!title) return;
                
                // Remove existing tooltip
                if (currentTooltip) {
                    currentTooltip.remove();
                    currentTooltip = null;
                }
                
                // Create new tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'custom-tooltip';
                tooltip.textContent = title;
                document.body.appendChild(tooltip);
                
                // Position tooltip
                const rect = e.target.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                
                // Position above the marker, centered horizontally
                let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
                let top = rect.top - tooltipRect.height - 8;
                
                // Adjust horizontal position if tooltip would go off screen
                if (left < 10) {
                    left = 10;
                } else if (left + tooltipRect.width > window.innerWidth - 10) {
                    left = window.innerWidth - tooltipRect.width - 10;
                }
                
                // If no room above, position below the marker
                if (top < 10) {
                    top = rect.bottom + 8;
                }
                
                // Add scroll offset
                tooltip.style.left = (left + window.scrollX) + 'px';
                tooltip.style.top = (top + window.scrollY) + 'px';
                
                currentTooltip = tooltip;
            }
        }
        
        function handleTooltipMouseout(e) {
            if (e.target.classList.contains('outlier-marker') || e.target.classList.contains('consensus-band') || e.target.classList.contains('milestone-marker')) {
                if (currentTooltip) {
                    currentTooltip.remove();
                    currentTooltip = null;
                }
            }
        }
        
        // Custom tooltip handling for outlier markers and consensus bands
        function initializeTooltips() {
            // Convert title attributes to data-tooltip to prevent default tooltips
            // Use setTimeout to ensure DOM is fully rendered
            setTimeout(() => {
                // Handle outlier markers
                document.querySelectorAll('.outlier-marker[title]').forEach(marker => {
                    const title = marker.getAttribute('title');
                    marker.setAttribute('data-tooltip', title);
                    marker.removeAttribute('title');
                });
                
                // Handle consensus bands (they should already have data-tooltip, but remove any title attributes)
                document.querySelectorAll('.consensus-band[title]').forEach(band => {
                    band.removeAttribute('title');
                });
                
                // Handle milestone markers
                document.querySelectorAll('.milestone-marker[title]').forEach(marker => {
                    const title = marker.getAttribute('title');
                    marker.setAttribute('data-tooltip', title);
                    marker.removeAttribute('title');
                });
            }, 100);
        }
        
        // Initialize tooltips when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeTooltips);
        
        // Modal interaction functions
        function updateLoadButton() {
            const topic = document.getElementById('topic').value;
            const model = document.getElementById('model').value;
            const loadBtn = document.getElementById('loadAnalysisBtn');
            const configureBtn = document.querySelector('[data-bs-target="#topicModal"]');
            
            if (topic && model) {
                loadBtn.disabled = false;
                loadBtn.title = 'Load Analysis';
                configureBtn.innerHTML = '<i class="fas fa-check"></i>';
                configureBtn.title = 'Configured';
                configureBtn.classList.remove('btn-primary');
                configureBtn.classList.add('btn-success');
            } else {
                loadBtn.disabled = true;
                loadBtn.title = 'Load Analysis';
                configureBtn.innerHTML = '<i class="fas fa-cog"></i>';
                configureBtn.title = 'Configure Analysis';
                configureBtn.classList.remove('btn-success');
                configureBtn.classList.add('btn-primary');
            }
        }
        
        function saveConfigurationAndClose() {
            const topic = document.getElementById('topic').value;
            const model = document.getElementById('model').value;
            const sampleSizeMode = document.getElementById('sampleSizeMode').value;
            const customLimit = document.getElementById('customLimit').value;
            const timeframe = document.getElementById('timeframe').value;
            const categoryMode = document.getElementById('categoryMode').value;
            const selectedCategories = getSelectedCategories();
            
            if (!topic) {
                alert('Please select a topic');
                return;
            }
            
            if (!model) {
                alert('Please select a model');
                return;
            }
            
            // Save configuration to localStorage including all form data
            const config = {
                topic,
                model,
                sampleSizeMode,
                customLimit,
                timeframe,
                categoryMode,
                selectedCategories,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('consensusAnalysisConfig', JSON.stringify(config));
            
            // Improved modal cleanup to prevent backdrop issues
            const modalElement = document.getElementById('topicModal');
            
            // Force cleanup of any existing backdrops first
            const existingBackdrops = document.querySelectorAll('.modal-backdrop');
            existingBackdrops.forEach(backdrop => backdrop.remove());
            
            // Get or create modal instance
            let modal = bootstrap.Modal.getInstance(modalElement);
            if (!modal) {
                modal = new bootstrap.Modal(modalElement);
            }
            
            // Set up one-time cleanup listener before hiding
            const cleanup = function() {
                // Force remove any remaining backdrops
                setTimeout(() => {
                    const backdrops = document.querySelectorAll('.modal-backdrop');
                    backdrops.forEach(backdrop => backdrop.remove());
                    
                    // Restore body state
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('overflow');
                    document.body.style.removeProperty('padding-right');
                    
                    // Remove modal-open class from html element too
                    document.documentElement.classList.remove('modal-open');
                }, 100);
                
                // Remove this listener
                modalElement.removeEventListener('hidden.bs.modal', cleanup);
            };
            
            modalElement.addEventListener('hidden.bs.modal', cleanup, { once: true });
            
            // Hide the modal
            modal.hide();
            
            // Update button states
            updateLoadButton();
            
            // Show success message
            showSuccess('Configuration saved! You can now load the analysis.');
        }
        
        async function loadSavedConfiguration() {
            try {
                const savedConfig = localStorage.getItem('consensusAnalysisConfig');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    console.log('Loading saved configuration:', config);
                    
                    // Restore form values
                    if (config.topic) {
                        const topicSelect = document.getElementById('topic');
                        if (topicSelect) {
                            topicSelect.value = config.topic;
                            console.log('Restored topic:', config.topic);
                        }
                    }
                    if (config.model) {
                        const modelSelect = document.getElementById('model');
                        if (modelSelect) {
                            modelSelect.value = config.model;
                            console.log('Restored model:', config.model);
                        }
                    }
                    if (config.sampleSizeMode) {
                        const sampleSizeSelect = document.getElementById('sampleSizeMode');
                        if (sampleSizeSelect) {
                            sampleSizeSelect.value = config.sampleSizeMode;
                            console.log('Restored sample size mode:', config.sampleSizeMode);
                        }
                    }
                    if (config.customLimit) {
                        const customLimitInput = document.getElementById('customLimit');
                        if (customLimitInput) {
                            customLimitInput.value = config.customLimit;
                            console.log('Restored custom limit:', config.customLimit);
                        }
                    }
                    if (config.timeframe) {
                        const timeframeSelect = document.getElementById('timeframe');
                        if (timeframeSelect) {
                            timeframeSelect.value = config.timeframe;
                            console.log('Restored timeframe:', config.timeframe);
                        }
                    }
                    if (config.categoryMode) {
                        const categoryModeSelect = document.getElementById('categoryMode');
                        if (categoryModeSelect) {
                            categoryModeSelect.value = config.categoryMode;
                            console.log('Restored category mode:', config.categoryMode);
                        }
                    }
                    
                    // Update UI state first
                    handleSampleSizeModeChange();
                    handleCategoryModeChange();
                    toggleCustomTimeframe();
                    
                    // Load categories if needed, then restore selections
                    if (config.categoryMode === 'existing' && config.topic) {
                        console.log('Loading categories for topic:', config.topic);
                        await loadExistingCategories();
                        
                        // Wait a bit for categories to load, then restore selections
                        setTimeout(() => {
                            if (config.selectedCategories && Array.isArray(config.selectedCategories)) {
                                console.log('Restoring category selections:', config.selectedCategories);
                                
                                // Clear existing selections
                                document.querySelectorAll('.category-checkbox').forEach(checkbox => {
                                    checkbox.checked = false;
                                });
                                
                                // Restore saved selections
                                let restoredCount = 0;
                                config.selectedCategories.forEach(categoryValue => {
                                    const checkbox = document.querySelector(`.category-checkbox[value="${categoryValue}"]`);
                                    if (checkbox) {
                                        checkbox.checked = true;
                                        restoredCount++;
                                    } else {
                                        console.warn('Category checkbox not found:', categoryValue);
                                    }
                                });
                                
                                console.log(`Restored ${restoredCount} of ${config.selectedCategories.length} category selections`);
                                updateCategoriesText();
                            }
                        }, 500);
                    }
                    
                    updateLoadButton();
                    updateContextInfo();
                    
                    console.log('Configuration loading completed');
                }
            } catch (e) {
                console.error('Failed to load saved configuration:', e);
            }
        }
        
        function clearSavedConfiguration() {
            try {
                // Clear saved configuration
                localStorage.removeItem('consensusAnalysisConfig');
                
                // Clear all cached results (they have dynamic keys now)
                const allKeys = Object.keys(localStorage).filter(key => key.startsWith('consensusAnalysisResults_'));
                allKeys.forEach(key => {
                    localStorage.removeItem(key);
                });
                
                console.log('Cleared all saved configuration and cached results');
                showSuccess(`Configuration and ${allKeys.length} cached result(s) cleared!`);
                
                // Reset UI to initial state
                document.getElementById('topic').value = '';
                document.getElementById('model').value = '';
                document.getElementById('timeframe').value = '30d';
                document.getElementById('categoryMode').value = 'predefined';
                document.getElementById('sampleSize').value = '50';
                document.getElementById('analysisDepth').value = 'standard';
                document.getElementById('customDays').style.display = 'none';
                
                // Hide results container
                const consensusContainer = document.getElementById('consensusContainer');
                if (consensusContainer) {
                    consensusContainer.style.display = 'none';
                }
                
                // Reset category checkboxes
                const categoryInputs = document.querySelectorAll('input[name="categories"]');
                categoryInputs.forEach(input => input.checked = false);
                
                // Clear existing categories dropdown
                const existingCategoriesSelect = document.getElementById('existingCategories');
                if (existingCategoriesSelect) {
                    existingCategoriesSelect.innerHTML = '<option value="">Select categories...</option>';
                }
                
                // Clear custom categories input
                const customCategoriesInput = document.getElementById('customCategories');
                if (customCategoriesInput) {
                    customCategoriesInput.value = '';
                }
                
                // Update category mode display
                handleCategoryModeChange();
                
            } catch (e) {
                console.error('Error clearing configuration:', e);
                showError('Failed to clear configuration. Please try refreshing the page.');
            }
        }
        
        function generateCacheKey(config) {
            // Create a unique cache key based on all configuration parameters
            const keyData = {
                topic: config.topic,
                timeframe: config.timeframe,
                customDays: config.customDays,
                model: config.model,
                categoryMode: config.categoryMode,
                categories: config.categories,
                sampleSize: config.sampleSize,
                analysisDepth: config.analysisDepth
            };
            
            // Create a hash of the configuration for the cache key
            const configString = JSON.stringify(keyData);
            let hash = 0;
            for (let i = 0; i < configString.length; i++) {
                const char = configString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            return `consensusAnalysisResults_${Math.abs(hash)}`;
        }
        
        function getCurrentConfiguration() {
            const timeframe = document.getElementById('timeframe')?.value || '';
            let customDays = null;
            
            if (timeframe === 'custom') {
                customDays = document.getElementById('customDays')?.value || null;
            }
            
            // Get categories based on mode
            let categories = [];
            const categoryMode = document.getElementById('categoryMode')?.value || 'predefined';
            if (categoryMode === 'predefined') {
                const categoryInputs = document.querySelectorAll('input[name="categories"]:checked');
                categories = Array.from(categoryInputs).map(input => input.value);
            } else if (categoryMode === 'existing') {
                const existingSelect = document.getElementById('existingCategories');
                if (existingSelect) {
                    categories = Array.from(existingSelect.selectedOptions).map(option => option.value);
                }
            } else if (categoryMode === 'custom') {
                const customCategoriesInput = document.getElementById('customCategories');
                if (customCategoriesInput && customCategoriesInput.value.trim()) {
                    categories = customCategoriesInput.value.split(',').map(cat => cat.trim()).filter(cat => cat);
                }
            }
            
            return {
                topic: document.getElementById('topic')?.value || '',
                timeframe: timeframe,
                customDays: customDays,
                model: document.getElementById('model')?.value || '',
                categoryMode: categoryMode,
                categories: categories,
                sampleSize: document.getElementById('sampleSize')?.value || '50',
                analysisDepth: document.getElementById('analysisDepth')?.value || 'standard'
            };
        }
        
        function saveAnalysisResults(results, config) {
            try {
                const cacheKey = generateCacheKey(config);
                const cacheData = {
                    results,
                    config,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                console.log('Analysis results cached successfully with key:', cacheKey);
                
                // Clean up old cache entries (keep only the most recent 5)
                const allKeys = Object.keys(localStorage).filter(key => key.startsWith('consensusAnalysisResults_'));
                if (allKeys.length > 5) {
                    // Get timestamps for all cached results
                    const cacheEntries = allKeys.map(key => {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            return { key, timestamp: new Date(data.timestamp) };
                        } catch (e) {
                            return { key, timestamp: new Date(0) }; // Invalid entries get old timestamp
                        }
                    });
                    
                    // Sort by timestamp (newest first) and remove old entries
                    cacheEntries.sort((a, b) => b.timestamp - a.timestamp);
                    cacheEntries.slice(5).forEach(entry => {
                        localStorage.removeItem(entry.key);
                        console.log('Removed old cache entry:', entry.key);
                    });
                }
            } catch (e) {
                console.warn('Failed to cache analysis results:', e);
            }
        }
        
        function loadCachedResults(config) {
            try {
                const cacheKey = generateCacheKey(config);
                const cachedData = localStorage.getItem(cacheKey);
                
                if (cachedData) {
                    const cache = JSON.parse(cachedData);
                    const cacheAge = new Date() - new Date(cache.timestamp);
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    
                    if (cacheAge < maxAge) {
                        // Verify configuration matches
                        const configMatches = JSON.stringify(cache.config) === JSON.stringify(config);
                        if (configMatches) {
                            console.log('Loading cached results from:', cache.timestamp);
                            return cache.results;
                        } else {
                            console.log('Configuration mismatch, cache invalid');
                            localStorage.removeItem(cacheKey);
                        }
                    } else {
                        console.log('Cached results expired, removing...');
                        localStorage.removeItem(cacheKey);
                    }
                }
            } catch (e) {
                console.warn('Failed to load cached results:', e);
            }
            return null;
        }
        
        function showSuccess(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="alert alert-success alert-dismissible fade show" role="alert">
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>`;
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                const alert = errorContainer.querySelector('.alert');
                if (alert) {
                    const bsAlert = new bootstrap.Alert(alert);
                    bsAlert.close();
                }
            }, 3000);
        }
        
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>`;
        }
        
        // Initialize tooltips when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeTooltips);
        
        // Load topics from API
        async function loadTopics() {
            try {
                const response = await fetch('/api/topics');
                const topics = await response.json();
                const topicSelect = document.getElementById('topic');
                
                topicSelect.innerHTML = '<option value="">Select a topic</option>';
                topics.forEach(topic => {
                    const option = document.createElement('option');
                    option.value = topic.name;
                    option.textContent = topic.name;
                    topicSelect.appendChild(option);
                });
                
                return true; // Indicate successful loading
            } catch (error) {
                console.error('Error loading topics:', error);
                showError('Failed to load topics. Please refresh the page.');
                return false;
            }
        }
        
        // Load models from API
        async function loadModels() {
            try {
                const response = await fetch('/api/available_models');
                const models = await response.json();
                const modelSelect = document.getElementById('model');
                
                modelSelect.innerHTML = '<option value="">Select a model</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.textContent = `${model.name} (${model.provider})`;
                    modelSelect.appendChild(option);
                });
                
                return true; // Indicate successful loading
            } catch (error) {
                console.error('Error loading models:', error);
                showError('Failed to load AI models. Please refresh the page.');
                return false;
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', async function() {
            // Clean up only our modal artifacts from previous page loads, not all Bootstrap components
            const consensusBackdrops = document.querySelectorAll('.modal-backdrop:not([data-bs-target])');
            consensusBackdrops.forEach(backdrop => {
                // Only remove if it's not associated with an active dropdown or other component
                if (!backdrop.previousElementSibling || 
                    (backdrop.previousElementSibling.id === 'topicModal' && 
                     !backdrop.previousElementSibling.classList.contains('show'))) {
                    backdrop.remove();
                }
            });
            
            // Only clean up modal-open state if no active modals or dropdowns exist
            const activeModals = document.querySelectorAll('.modal.show');
            const activeDropdowns = document.querySelectorAll('.dropdown-menu.show');
            if (activeModals.length === 0 && activeDropdowns.length === 0) {
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('overflow');
                document.body.style.removeProperty('padding-right');
                document.documentElement.classList.remove('modal-open');
            }
            
            // Add tooltip event listeners
            document.addEventListener('mouseover', handleTooltipMouseover);
            document.addEventListener('mouseout', handleTooltipMouseout);
            
            // Restore controls state
            restoreControlsState();
            
            // Try to auto-load cached analysis
            setTimeout(() => {
                autoLoadCachedAnalysis();
            }, 500);
            
            // Load data and then configuration
            const topicsLoaded = await loadTopics();
            const modelsLoaded = await loadModels();
            
            // Initialize category mode
            handleCategoryModeChange();
            
            // Set up topic change listener
            const topicSelect = document.getElementById('topic');
            if (topicSelect) {
                topicSelect.addEventListener('change', function() {
                    const categoryMode = document.getElementById('categoryMode').value;
                    if (categoryMode === 'existing') {
                        loadExistingCategories();
                    }
                });
            }
            
            // Load saved configuration after all data is loaded
            if (topicsLoaded && modelsLoaded) {
                console.log('Loading saved configuration after data initialization...');
                setTimeout(async () => {
                    await loadSavedConfiguration();
                    
                    // Check if we have a saved configuration to determine modal behavior
                    const savedConfig = localStorage.getItem('consensusAnalysisConfig');
                    if (!savedConfig) {
                        // Show configuration modal only if no saved config
                        setTimeout(() => {
                            const modal = new bootstrap.Modal(document.getElementById('topicModal'));
                            modal.show();
                        }, 500);
                    } else {
                        console.log('Found saved configuration, skipping initial modal');
                    }
                }, 500);
            } else {
                // Show modal if data loading failed
                setTimeout(() => {
                    const modal = new bootstrap.Modal(document.getElementById('topicModal'));
                    modal.show();
                }, 500);
            }
        });
        
        // Add cleanup on page unload for our modals only
        window.addEventListener('beforeunload', function() {
            // Only clean up our modal artifacts before page unload
            const topicModal = document.getElementById('topicModal');
            if (topicModal && !topicModal.classList.contains('show')) {
                const topicBackdrops = document.querySelectorAll('.modal-backdrop');
                topicBackdrops.forEach(backdrop => {
                    if (backdrop.nextElementSibling === topicModal || 
                        backdrop.previousElementSibling === topicModal) {
                        backdrop.remove();
                    }
                });
            }
        });
        
        // Add click event delegation to handle modal backdrop clicks properly
        // BUT be much more specific to avoid interfering with navigation
        document.addEventListener('click', function(event) {
            // ONLY handle our specific modal backdrop - be extremely selective
            if (event.target.classList.contains('modal-backdrop') && 
                event.target.getAttribute('data-bs-backdrop') !== null &&
                event.target.nextElementSibling && 
                event.target.nextElementSibling.id === 'topicModal') {
                
                // This is specifically our topic modal backdrop
                setTimeout(() => {
                    event.target.remove();
                    
                    // Only remove modal-open if no other modals are active
                    const activeModals = document.querySelectorAll('.modal.show');
                    if (activeModals.length === 0) {
                        document.body.classList.remove('modal-open');
                        document.body.style.removeProperty('overflow');
                        document.body.style.removeProperty('padding-right');
                        document.documentElement.classList.remove('modal-open');
                    }
                }, 100);
            }
            
            // Don't handle any other clicks - let Bootstrap handle everything else
        });
    </script>
{% endblock %}

{% block extra_js %}
{% endblock %} 