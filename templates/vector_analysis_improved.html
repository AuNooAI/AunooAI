{% extends 'base.html' %}
{% block title %}Vector Analysis{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.css" />
<style>
    /* Correct Hot Pink theme matching index.html */
    :root {
        --primary-color: #FF69B4;
        --primary-hover: #FF1493;
        --primary-light: #FFE4F1;
        --primary-dark: #FF1493;
        --secondary-color: #6c757d;
        --success-color: #28a745;
        --info-color: #17a2b8;
        --warning-color: #ffc107;
        --danger-color: #dc3545;
        --light-gray: #f8f9fa;
        --border-color: #dee2e6;
        --pink-accent: #FFB3D9;
    }
    
    /* Enhanced responsive layout - fix nested scrollbars */
    .layout {
        display: grid;
        grid-template-columns: 220px 1fr 260px;
        gap: 1rem;
        margin-top: 1.5rem;
        min-height: calc(100vh - 120px);
        overflow: visible; /* Remove overflow constraint */
    }
    
    /* Mobile responsive breakpoints */
    @media (max-width: 1024px) {
        .layout {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto 1fr;
            min-height: auto;
        }
        .sidebar, .meta {
            max-height: none;
        }
    }
    
    @media (max-width: 768px) {
        .layout {
            gap: 0.5rem;
            margin-top: 1rem;
        }
    }

    /* Fixed sidebar styling - remove height constraints */
    .sidebar, .meta {
        background: var(--light-gray);
        padding: 0.75rem;
        border-radius: 8px;
        overflow: visible; /* Remove overflow constraint */
        max-height: none; /* Remove height limit */
        contain: layout;
        font-size: 0.85rem;
    }
    
    .main {
        display: flex;
        flex-direction: column;
        overflow: visible; /* Remove overflow constraint */
        min-height: calc(100vh - 140px);
        max-height: none; /* Remove height limit */
    }
    
    /* Fixed results container - add scrollbar instead of infinite scrolling */
    #results {
        flex: 1;
        margin-top: 1rem;
        max-height: calc(100vh - 400px); /* Set max height for scrollable container */
        overflow-y: auto; /* Add vertical scrollbar */
        min-height: auto;
        padding-right: 10px; /* Space for scrollbar */
    }
    
    /* Custom scrollbar styling */
    #results::-webkit-scrollbar {
        width: 8px;
    }
    
    #results::-webkit-scrollbar-track {
        background: var(--light-gray);
        border-radius: 4px;
    }
    
    #results::-webkit-scrollbar-thumb {
        background: var(--primary-color);
        border-radius: 4px;
    }
    
    #results::-webkit-scrollbar-thumb:hover {
        background: var(--primary-hover);
    }
    
    /* Fixed filter panels - professional styling */
    .filter-panel {
        background: white;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        margin-bottom: 0.5rem;
        font-size: 0.8rem;
        border: 1px solid var(--border-color);
    }
    
    .filter-panel-header {
        padding: 0.4rem 0.6rem;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        background: var(--light-gray);
        border-radius: 6px 6px 0 0;
        font-size: 0.8rem;
        transition: background-color 0.2s ease;
    }
    
    .filter-panel-header:hover {
        background: var(--pink-accent);
    }
    
    .filter-panel-header h5, .filter-panel-header h6 {
        margin: 0;
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--primary-color);
    }
    
    .filter-panel-content {
        padding: 0.5rem;
        overflow: visible; /* Remove height constraints */
        font-size: 0.75rem;
        transition: max-height 0.3s ease;
    }
    
    .filter-panel-content.collapsed {
        max-height: 120px;
        overflow-y: auto;
    }
    
    /* Enhanced Search Interface - lower the query builder button further */
    .sticky-top {
        padding-top: 3.5rem !important;
        position: relative;
    }
    
    /* Fixed query builder positioning - Hot Pink styling */
    .query-builder-toggle {
        position: absolute;
        top: -15px;
        right: 80px;
        background: white;
        border: 2px solid var(--primary-color);
        border-radius: 12px;
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 9999;
        box-shadow: 0 2px 8px rgba(255, 105, 180, 0.2);
        font-weight: 500;
        color: var(--primary-color);
    }
    
    .query-builder-toggle:hover {
        background: var(--primary-color);
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 105, 180, 0.3);
    }
    
    /* Enhanced search bar - Hot Pink styling */
    .search-bar-container {
        position: relative;
        display: grid;
        grid-template-columns: 40px 1fr auto;
        width: 100%;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        overflow: hidden;
        transition: all 0.3s ease;
    }
    
    .search-bar-container:focus-within {
        border-color: var(--primary-color);
        box-shadow: 0 2px 8px rgba(255, 105, 180, 0.15);
    }
    
    .search-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    
    #searchInput {
        border: none;
        box-shadow: none;
        padding: 0.5rem;
        width: 100%;
        font-size: 1rem;
    }
    
    .search-controls {
        display: flex;
        align-items: center;
        padding-right: 0.5rem;
    }
    
    .search-controls button {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 34px;
        width: 34px;
        padding: 0;
        margin-left: 4px;
    }
    
    /* Visual query builder */
    .query-builder {
        display: none;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .query-builder.active {
        display: block;
    }
    
    .query-builder-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    /* Performance indicators */
    .performance-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 10px;
        background: rgba(0,0,0,0.1);
    }
    
    .performance-fast { background: rgba(40, 167, 69, 0.2); color: #28a745; }
    .performance-medium { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
    .performance-slow { background: rgba(220, 53, 69, 0.2); color: #dc3545; }
    
    /* Enhanced loading states */
    .progressive-loader {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 8px;
        padding: 1rem;
        margin: 1rem 0;
        text-align: center;
    }
    
    .progress-steps {
        display: flex;
        justify-content: space-between;
        margin-top: 1rem;
    }
    
    .progress-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 12px;
    }
    
    .progress-step.completed {
        color: #28a745;
    }
    
    .progress-step.active {
        color: #ffc107;
    }
    
    /* Enhanced result cards */
    .result-card {
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        position: relative;
        transition: all 0.2s ease;
        contain: layout;
    }
    
    .result-card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        transform: translateY(-1px);
    }
    
    .result-card.selected {
        border-color: var(--primary-color);
        background: rgba(108, 99, 255, 0.05);
    }
    
    /* View mode styles - fix class selectors to match actual cards */
    .view-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .view-grid .card {
        flex: 0 1 calc(50% - 0.5rem);
        margin-bottom: 1rem;
        margin-right: 0 !important;
    }
    
    /* Compact view - make it more table-like */
    .view-compact .card {
        margin-bottom: 0.25rem;
        border-radius: 4px;
        border: 1px solid #e9ecef;
        box-shadow: none;
        padding-left: 2.5rem; /* Less padding for more compact look */
    }
    
    .view-compact .card .card-body {
        padding: 0.4rem 0.75rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .view-compact .card .form-check-input {
        left: 8px !important;
        top: 50% !important;
        transform: translateY(-50%);
    }
    
    .view-compact .card h6 {
        font-size: 0.85rem;
        margin-bottom: 0;
        flex: 1;
        margin-right: 1rem;
    }
    
    .view-compact .card p {
        display: none; /* Hide all paragraphs in compact mode */
    }
    
    /* List view is the default, but let's be explicit */
    .view-list .card {
        display: block;
        width: 100%;
        margin-right: 0;
    }
    
    /* Grid view responsiveness */
    @media (max-width: 768px) {
        .view-grid .card {
            flex: 1 1 100%;
        }
    }
    
    /* Active filter chips - Hot Pink styling */
    .filter-chip {
        display: inline-block;
        background: var(--primary-color);
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 8px;
        font-size: 0.8rem;
        margin-right: 0.5rem;
        margin-bottom: 0.25rem;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid var(--primary-color);
    }
    
    .filter-chip:hover {
        background: var(--primary-hover);
        border-color: var(--primary-hover);
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(255, 105, 180, 0.2);
    }
    
    /* Quick filter buttons - Hot Pink styling */
    .quick-filter-btn {
        width: 100%;
        text-align: left;
        padding: 0.5rem;
        margin-bottom: 0.25rem;
        border: 1px solid var(--border-color);
        background: white;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.85rem;
        color: var(--secondary-color);
    }
    
    .quick-filter-btn:hover {
        background: var(--primary-light);
        border-color: var(--primary-color);
        color: var(--primary-hover);
        transform: translateX(2px);
    }
    
    /* Facet items - Hot Pink styling */
    .facet-group {
        margin-bottom: 1rem;
    }
    
    .facet-group strong {
        display: block;
        margin-bottom: 0.25rem;
        color: var(--primary-color);
        font-size: 0.9rem;
    }
    
    .facet-item {
        display: block;
        padding: 0.25rem 0.5rem;
        margin-bottom: 0.125rem;
        background: var(--light-gray);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.8rem;
        border: 1px solid transparent;
    }
    
    .facet-item:hover {
        background: var(--primary-light);
        color: var(--primary-hover);
        border-color: var(--primary-color);
        transform: translateX(2px);
    }
    
    /* Metadata table */
    .meta table { width: 100%; font-size: 0.85rem; }
    .meta th { color: var(--primary-color); font-weight: 500; white-space: nowrap; }
    .meta td { word-break: break-word; }
    
    /* Exploration dropdown styling - Hot Pink */
    .exploration-item {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .exploration-item:hover {
        border-color: var(--primary-color);
        background: var(--primary-light);
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(255, 105, 180, 0.1);
    }
    
    .exploration-name {
        font-weight: 500;
        font-size: 0.9rem;
        margin-bottom: 0.25rem;
        color: var(--primary-color);
    }
    
    .exploration-description {
        font-size: 0.8rem;
        color: var(--secondary-color);
    }
    
    /* Impact box styling */
    .impact-box {
        background-color: #f8f9fa;
        border-radius: 4px;
        padding: 8px 10px;
        margin-bottom: 10px;
        border: 1px solid #dee2e6;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        font-size: 0.85rem;
    }
    
    .impact-summary {
        font-weight: 500;
        color: #495057;
    }
    
    /* Enhanced Tab Content - remove all height constraints */
    .tab-content {
        overflow: visible;
        min-height: 200px;
    }
    
    .tab-pane {
        overflow: visible;
        min-height: 200px;
    }
    
    .tab-pane.collapsible {
        max-height: 400px;
        overflow-y: auto;
        transition: max-height 0.3s ease;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        background: #f8f9fa;
    }
    
    .tab-pane.expanded {
        max-height: none;
        overflow: visible;
    }
    
    /* Specific styling for patterns tab - allow full expansion */
    #patternsPane {
        overflow: visible;
        padding: 0.5rem;
        position: relative;
        min-height: 200px;
    }
    
    #patternsPane.collapsible {
        max-height: 400px;
        overflow-y: auto;
    }
    
    #patternsPane.expanded {
        max-height: none;
        overflow: visible;
    }
    
    /* Specific styling for visuals tab - allow full expansion */
    #vizPane {
        overflow: visible;
        padding: 0.5rem;
        position: relative;
        min-height: 200px;
    }
    
    #vizPane.collapsible {
        max-height: 400px;
        overflow-y: auto;
    }
    
    #vizPane.expanded {
        max-height: none;
        overflow: visible;
    }
    
    /* Make pattern cards more flexible */
    .pattern-card-body {
        max-height: 200px;
        overflow-y: auto;
        transition: max-height 0.3s ease;
    }
    
    .pattern-card-body.expanded {
        max-height: none;
        overflow: visible;
    }
    
    /* Pattern list styling - remove height constraints */
    #patternList {
        overflow: visible;
        min-height: auto;
    }
    
    /* Expandable controls - Hot Pink styling */
    .expand-toggle {
        position: absolute;
        top: 5px;
        right: 5px;
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        z-index: 10;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        color: var(--secondary-color);
    }
    
    .expand-toggle:hover {
        background: var(--primary-light);
        color: var(--primary-hover);
        border-color: var(--primary-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(255, 105, 180, 0.2);
    }
    
    .expand-toggle i {
        color: inherit;
        font-size: 10px;
    }
    
    /* Tab expand toggles - Hot Pink styling */
    .nav-link .expand-toggle {
        position: relative;
        top: auto;
        right: auto;
        background: rgba(255,255,255,0.9);
        border: 1px solid var(--border-color);
        border-radius: 3px;
        padding: 2px 4px;
        margin-left: 8px;
        font-size: 10px;
        color: var(--secondary-color);
    }
    
    .nav-link .expand-toggle:hover {
        background: var(--primary-light);
        border-color: var(--primary-color);
        color: var(--primary-hover);
    }
    
    /* Sidebar panels - make them more flexible */
    .filter-panel-content {
        max-height: none; /* Remove fixed height */
        overflow: visible;
        transition: max-height 0.3s ease;
    }
    
    .filter-panel-content.collapsed {
        max-height: 150px;
        overflow-y: auto;
    }
    
    /* Ensure cluster legend has proper height - no nested scrolling */
    #clusterLegend {
        min-height: 60px;
        overflow: visible;
        flex-wrap: wrap;
        display: flex;
    }
    
    /* Fix visualization container - remove overflow constraints */
    #scatter {
        min-height: 300px;
        overflow: visible;
        width: 100% !important;
        height: 450px !important;
        background: white;
        border: 1px solid #e9ecef;
        border-radius: 4px;
    }
    
    /* Ensure scatter plot shows properly when loaded */
    #scatter[style*="display: block"] {
        display: block !important;
    }
    
    /* Card body constraints - allow natural expansion */
    .card-body {
        overflow-wrap: break-word;
        word-wrap: break-word;
    }
    
    /* Add metadata panel restore button - Hot Pink styling */
    .meta-restore-btn {
        position: fixed;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 20px 0 0 20px;
        padding: 10px 8px;
        font-size: 12px;
        cursor: pointer;
        z-index: 1000;
        box-shadow: -2px 0 8px rgba(255, 105, 180, 0.3);
        display: none;
        transition: all 0.2s ease;
    }
    
    .meta-restore-btn:hover {
        background: var(--primary-hover);
        transform: translateY(-50%) translateX(-2px);
        box-shadow: -4px 0 12px rgba(255, 105, 180, 0.4);
    }
    
    /* Enhanced facet styling for show more/less functionality */
    .facet-more-items {
        border-top: 1px solid var(--border-color);
        margin-top: 0.5rem;
        padding-top: 0.5rem;
    }
    
    .facet-group .btn-link {
        color: var(--primary-color);
        text-decoration: none;
        font-size: 0.75rem;
    }
    
    .facet-group .btn-link:hover {
        color: var(--primary-hover);
        text-decoration: underline;
    }
    
    /* Delete button styling - Hot Pink theme */
    .delete-article-btn {
        opacity: 0.7;
        transition: all 0.2s ease;
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .delete-article-btn:hover {
        opacity: 1;
        background-color: #dc3545;
        color: white;
        transform: scale(1.05);
        box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
    }
    
    .delete-article-btn:active {
        transform: scale(0.95);
    }
    
    /* Enhanced badge styling for metadata */
    .badge {
        font-size: 0.75rem;
        padding: 0.35em 0.6em;
        font-weight: 500;
    }
    
    /* Clickable badge styling */
    .clickable-badge {
        transition: all 0.2s ease;
        cursor: pointer !important;
    }
    
    .clickable-badge:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        filter: brightness(1.1);
    }
    
    .clickable-badge:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    .badge.bg-outline-secondary {
        background-color: transparent !important;
        color: var(--secondary-color) !important;
        border: 1px solid var(--secondary-color);
    }
    
    .badge.bg-outline-secondary:hover {
        background-color: var(--secondary-color) !important;
        color: white !important;
    }
    
    /* Success alert styling for delete confirmations */
    .alert-success.position-fixed {
        border: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-left: 4px solid #28a745;
    }
    
    /* Timeline chart container improvements */
    #timelineChart {
        min-height: 80px;
        max-height: 200px;
    }
    
    .tab-pane canvas {
        background: white;
        border-radius: 4px;
    }
    
    /* Load more button improvements */
    .btn-outline-primary.my-3 {
        transition: all 0.2s ease;
        border-width: 2px;
    }
    
    .btn-outline-primary.my-3:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(108, 99, 255, 0.2);
    }
    
    /* Enhanced card hover effects for better UX */
    .card {
        transition: all 0.2s ease;
    }
    
    .card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        transform: translateY(-1px);
    }
    
    .card:hover .delete-article-btn {
        opacity: 1;
    }
</style>

<div class="layout">
    <!-- Enhanced Left Sidebar -->
    <div class="sidebar" role="navigation" aria-label="Search filters and explorations">
        <!-- Saved Searches with enhanced UX -->
        <div class="filter-panel">
            <div class="filter-panel-header" onclick="togglePanel('explorations')">
                <h5><i class="fas fa-bookmark me-2"></i>Explorations</h5>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="filter-panel-content" id="explorationsPanel">
                <div class="mb-3">
                    <select id="explorationsDropdown" class="form-select form-select-sm mb-2" 
                            aria-label="Select saved search">
                        <option value="">Select a saved search...</option>
                    </select>
                </div>
                <div id="explorationsContainer" class="mb-2"></div>
            </div>
        </div>
        
        <!-- Enhanced Active Filters -->
        <div class="filter-panel">
            <div class="filter-panel-header" onclick="togglePanel('filters')">
                <h5><i class="fas fa-filter me-2"></i>Active Filters</h5>
                <div class="d-flex align-items-center">
                    <span id="filterCount" class="badge bg-primary me-2">0</span>
                    <button class="btn btn-sm btn-link p-0" onclick="togglePanelCollapse('filtersPanel', event)" title="Expand/Collapse">
                        <i class="fas fa-expand-alt text-muted"></i>
                    </button>
                </div>
            </div>
            <div class="filter-panel-content" id="filtersPanel">
                <!-- Filter Impact Box -->
                <div id="filterImpact" class="mb-3"></div>
                
                <!-- Dynamic Facets -->
                <div id="facetList" class="mb-3"></div>
            </div>
        </div>
        
        <!-- Enhanced Help Section -->
        <div class="filter-panel">
            <div class="filter-panel-header" onclick="togglePanel('help')">
                <h6><i class="fas fa-question-circle me-2"></i>Search & Filter Help</h6>
                <div class="d-flex align-items-center">
                    <button class="btn btn-sm btn-link p-0" onclick="togglePanelCollapse('helpPanel', event)" title="Expand/Collapse">
                        <i class="fas fa-expand-alt text-muted"></i>
                    </button>
                </div>
            </div>
            <div class="filter-panel-content collapsed" id="helpPanel">
                <p class="small mb-2">Type <em>anything</em> for natural-language search, plus add filters:</p>
                
                <div class="d-grid gap-1 mb-3">
                    <button class="quick-filter-btn" onclick="addQuickFilter('category', 'AI Business')">
                        <i class="fas fa-robot me-2"></i>category="AI Business"
                    </button>
                    <button class="quick-filter-btn" onclick="addQuickFilter('sentiment', 'Positive')">
                        <i class="fas fa-smile me-2"></i>sentiment="Positive"
                    </button>
                    <button class="quick-filter-btn" onclick="addQuickFilter('', 'has:driver_type')">
                        <i class="fas fa-cogs me-2"></i>has:driver_type
                    </button>
                </div>
                
                <h6 class="text-primary mt-3">Operators</h6>
                <p class="mb-1 small">
                    <code>=</code> / <code>equal</code> same as,<br>
                    <code>!=</code> / <code>not&nbsp;equal</code> different from,<br>
                    <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> compare values
                </p>
                <h6 class="text-primary mt-3">Logic Operators</h6>
                <p class="mb-1 small">
                    <code>AND</code> all terms match<br>
                    <code>OR</code> any term matches<br> 
                    <code>NOT</code> exclude following term
                </p>
                <p class="mb-1 small">
                    <code>in(a,b,c)</code> set membership<br>
                    <code>has:field</code> existence check<br>
                    <code>field=min..max</code> range
                </p>
                <h6 class="text-primary mt-3">Pipe Operators</h6>
                <p class="mb-1 small">
                    <code>| HEAD&nbsp;n</code> first n results (default 100)<br>
                    <code>| TAIL&nbsp;n</code> last n results<br>
                    <code>| SAMPLE&nbsp;n</code> random sample of n results
                </p>
                <details class="mt-2">
                    <summary class="small fw-semibold text-primary">Meta Controls &amp; Enhancement Examples</summary>
                    <div class="mt-2 small">
                        <h6 class="text-primary">Meta Controls</h6>
                        <p class="mb-1">
                            <code>sort:field[:asc|desc]</code> — sort results, e.g. <code>sort:publication_date:desc</code><br>
                            <code>limit:n</code> — cap number of results, e.g. <code>limit:50</code><br>
                            <code>similar:id</code> — find items like given id, e.g. <code>similar:abc123</code><br>
                            <code>cluster=n</code> — restrict to cluster, e.g. <code>cluster=4</code>
                        </p>
                        <h6 class="text-primary mt-3">Enhancement</h6>
                        <p class="mb-1">
                            <code>^n</code> — boost term weight, e.g. <code>AI^3</code><br>
                            <code>"exact phrase"</code> — exact match, e.g. <code>"artificial intelligence"</code>
                        </p>
                        <h6 class="text-primary mt-3">Example Queries</h6>
                        <p class="mb-1">
                            <code>AI AND category="AI Business" sentiment=Positive</code><br>
                            <code>AI NOT Google has:driver_type</code><br>
                            <code>"artificial intelligence" sort:publication_date:desc limit:50</code><br>
                        </p>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <!-- Enhanced Center Main Content -->
    <div class="main" role="main">
        <!-- Enhanced Search Interface -->
        <div class="sticky-top bg-white pt-2" style="z-index:2;">
            <!-- Query Builder Toggle -->
            <div class="query-builder-toggle" onclick="toggleQueryBuilder()">
                <i class="fas fa-cogs"></i> Builder
            </div>
            
            <!-- Visual Query Builder -->
            <div class="query-builder" id="queryBuilder">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0">Visual Query Builder</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearQueryBuilder()">
                        Clear All
                    </button>
                </div>
                <div id="queryBuilderRows">
                    <!-- Dynamic query builder rows will be added here -->
                </div>
                <button class="btn btn-sm btn-primary" onclick="addQueryBuilderRow()">
                    <i class="fas fa-plus"></i> Add Condition
                </button>
            </div>
            
            <!-- Enhanced Search Bar -->
            <div class="search-bar-container mb-2" role="search">
                <div class="search-icon" id="searchIcon" onclick="runSearch()" role="button" 
                     tabindex="0" aria-label="Execute search">
                    <i class="fas fa-search"></i>
                </div>
                <input type="text" id="searchInput" class="form-control" 
                       placeholder="Search news articles..." 
                       aria-label="Search query"
                       autocomplete="off">
                <div class="search-controls">
                    <button id="clearSearchBtn" class="btn btn-sm btn-link text-muted" 
                            style="display:none;" title="Clear search" aria-label="Clear search">
                        <i class="fas fa-times"></i>
                    </button>
                    <button id="debugBtn" class="btn btn-sm btn-outline-warning" 
                            title="Debug ID mismatch issues" aria-label="Debug search results vs vector DB"
                            onclick="debugSearchResults()">
                        <i class="fas fa-bug"></i>
                    </button>
                    <button id="saveSearchBtn" class="btn btn-sm btn-outline-secondary" 
                            title="Save Search" aria-label="Save current search">
                        <i class="fas fa-save"></i>
                    </button>
                    <button id="askAuspexBtn" class="btn btn-sm btn-outline-primary" 
                            title="Ask Auspex" aria-label="Generate AI summary">
                        <i class="fas fa-comment-dots"></i>
                    </button>
                </div>
            </div>
            
            <!-- Performance indicator -->
            <div id="performanceIndicator" class="performance-indicator" style="display: none;">
                <i class="fas fa-tachometer-alt"></i>
                <span id="performanceText">Fast</span>
            </div>
            
            <!-- Enhanced active filters -->
            <div id="activeFilters" class="mb-2" role="region" aria-label="Active search filters"></div>
            
            <!-- Enhanced sort controls -->
            <div class="d-flex justify-content-between align-items-center mb-2">
                <div class="btn-group btn-group-sm" role="group" aria-label="View options">
                    <button class="btn btn-outline-secondary active" onclick="toggleView('list')" title="List view">
                        <i class="fas fa-list"></i>
                    </button>
                    <button class="btn btn-outline-secondary" onclick="toggleView('grid')" title="Grid view">
                        <i class="fas fa-th"></i>
                    </button>
                    <button class="btn btn-outline-secondary" onclick="toggleView('compact')" title="Compact view">
                        <i class="fas fa-compress"></i>
                    </button>
                </div>
                
                <div class="dropdown">
                    <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" 
                            id="sortDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="fas fa-sort me-1"></i> Sort
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end">
                        <li><h6 class="dropdown-header">Sort by</h6></li>
                        <li><button class="dropdown-item" onclick="applySortToSearch('publication_date', 'desc')">
                            <i class="fas fa-calendar-alt me-2"></i>Date (newest first)
                        </button></li>
                        <li><button class="dropdown-item" onclick="applySortToSearch('publication_date', 'asc')">
                            <i class="fas fa-calendar-alt me-2"></i>Date (oldest first)
                        </button></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><button class="dropdown-item" onclick="applySortToSearch('sentiment')">
                            <i class="fas fa-smile me-2"></i>Sentiment
                        </button></li>
                        <li><button class="dropdown-item" onclick="applySortToSearch('score', 'desc')">
                            <i class="fas fa-star me-2"></i>Relevance Score
                        </button></li>
                    </ul>
                </div>
            </div>
            
            <!-- Enhanced Tabs with expand/collapse controls -->
            <ul class="nav nav-tabs small mb-2" id="resultTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#eventsPane" 
                            type="button" role="tab" aria-controls="eventsPane" aria-selected="true">
                        <i class="fas fa-chart-line me-1"></i>Data Points
                        <span id="dataPointsCount" class="badge bg-light text-dark ms-1">0</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link position-relative" data-bs-toggle="tab" data-bs-target="#patternsPane" 
                            type="button" role="tab" aria-controls="patternsPane" aria-selected="false">
                        <i class="fas fa-project-diagram me-1"></i>Patterns
                        <span id="patternsCount" class="badge bg-light text-dark ms-1">0</span>
                        <button class="expand-toggle" onclick="togglePaneExpansion('patternsPane', event)" title="Expand/Collapse">
                            <i class="fas fa-expand-alt"></i>
                        </button>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link position-relative" data-bs-toggle="tab" data-bs-target="#vizPane" 
                            type="button" role="tab" aria-controls="vizPane" aria-selected="false">
                        <i class="fas fa-cubes me-1"></i>Visuals
                        <button class="expand-toggle" onclick="togglePaneExpansion('vizPane', event)" title="Expand/Collapse">
                            <i class="fas fa-expand-alt"></i>
                        </button>
                    </button>
                </li>
            </ul>
            
            <!-- Enhanced Tab Content -->
            <div class="tab-content">
                <div class="tab-pane fade show active" id="eventsPane" role="tabpanel">
                    <canvas id="timelineChart" height="80"></canvas>
                </div>
                <div class="tab-pane fade" id="patternsPane" role="tabpanel">
                    <div id="patternList" class="small p-2"></div>
                </div>
                <div class="tab-pane fade" id="vizPane" role="tabpanel">
                    <div class="d-flex align-items-center mb-2 flex-wrap gap-1">
                        <select id="embedMethod" class="form-select form-select-sm" style="width:100px;">
                            <option value="umap">UMAP</option>
                            <option value="tsne">t-SNE</option>
                            <option value="pca">PCA</option>
                        </select>
                        <div class="form-check small">
                            <input class="form-check-input" type="checkbox" id="embed3d">
                            <label class="form-check-label" for="embed3d">3D</label>
                        </div>
                        <select id="clusterMethod" class="form-select form-select-sm" style="width:120px;">
                            <option value="kmeans" selected>K-Means</option>
                            <option value="hierarchical">Hierarchical</option>
                            <option value="dbscan">DBSCAN</option>
                            <option value="gaussian">Gaussian Mix</option>
                        </select>
                        <input type="number" id="nClusters" class="form-control form-control-sm" 
                               style="width:60px;" value="30" min="2" max="100" title="Number of clusters">
                        <select id="colorMode" class="form-select form-select-sm" style="width:140px;">
                            <option value="cluster" selected>Color: cluster</option>
                            <option value="sentiment">Color: sentiment</option>
                            <option value="driver_type">Color: driver_type</option>
                            <option value="category">Color: category</option>
                            <option value="time_to_impact">Color: time_to_impact</option>
                        </select>
                    </div>
                    <div id="clusterLegend" class="small mb-2"></div>
                    <div class="p-2 text-muted small" id="vizLoading">Loading…</div>
                    <div id="scatter" style="width:100%;height:450px;display:none;"></div>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Selection toolbar -->
        <div id="selectionToolbar" class="d-flex align-items-center gap-2 mb-2">
            <button id="selectAllBtn" class="btn btn-sm btn-outline-secondary" 
                    title="Select / Deselect all">
                <i class="fas fa-check-square"></i> Select All
            </button>
            <button id="reportBtn" class="btn btn-sm btn-outline-success" 
                    title="Generate report from selected" disabled>
                <i class="fas fa-file-alt"></i> Report
            </button>
            <div class="ms-auto">
                <small class="text-muted">
                    <span id="selectedCount">0</span> of <span id="totalCount">0</span> selected
                </small>
            </div>
        </div>

        <!-- Enhanced Results Container -->
        <div id="results" class="results-container view-list"></div>
    </div>

    <!-- Enhanced Right Metadata Panel -->
    <div class="meta" id="metaPanel" role="complementary" aria-label="Article metadata">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h5>Metadata</h5>
            <button class="btn btn-sm btn-outline-secondary" onclick="toggleMetaPanel()" 
                    title="Collapse metadata panel">
                <i class="fas fa-compress-alt"></i>
            </button>
        </div>
        <div id="metaContent" class="small"></div>
    </div>
</div>

<!-- Metadata restore button -->
<button class="meta-restore-btn" id="metaRestoreBtn" onclick="toggleMetaPanel()" title="Show metadata panel">
    <i class="fas fa-info-circle"></i><br>
    <span style="writing-mode: vertical-rl; text-orientation: mixed; font-size: 10px;">Meta</span>
</button>

<!-- Auspex summary modal -->
<div class="modal fade" id="auspexModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Auspex Summary</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="auspexContent">
        <div class="text-muted">Waiting for Auspex…</div>
      </div>
      <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="exportSummaryBtn" style="display: none;">Export Markdown</button>
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Save Search Modal -->
<div class="modal fade" id="saveSearchModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Save Search</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <form id="saveSearchForm">
          <div class="mb-3">
            <label for="searchName" class="form-label">Name</label>
            <input type="text" class="form-control" id="searchName" required>
          </div>
          <div class="mb-3">
            <label for="searchDescription" class="form-label">Description</label>
            <textarea class="form-control" id="searchDescription" rows="2"></textarea>
          </div>
          <div class="mb-3">
            <label for="searchTags" class="form-label">Tags (comma separated)</label>
            <input type="text" class="form-control" id="searchTags">
          </div>
          <div class="mb-3">
            <label for="searchQuery" class="form-label">Command</label>
            <textarea class="form-control" id="searchQuery" rows="2" required></textarea>
          </div>
          <input type="hidden" id="searchId">
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="saveSearchSubmitBtn">Save</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.min.js"></script>
<script>
// Global storage for summaries and associated articles
window._clusterSummaries = {};
window._clusterArticles = {};

// Interval IDs for rotating facts
let patternsLoadingIntervalId = null;
let vizLoadingIntervalId = null;
let auspexLoadingIntervalId = null;
// Interval IDs for countdown timers
let patternsCountdownId = null;
let vizCountdownId = null;
let auspexCountdownId = null;
// Fact rotation interval in seconds
const FACT_ROTATION_SECONDS = 18;

// Global storage for news facts
window._newsFacts = [];

const DEFAULT_PAGE_SIZE = 20; // Number of results per page for pagination

// Global variables for search functionality
let currentIndex = 0;
let lastResults = [];
let scatterLoaded = false;
let patternsLoaded = false;

// Selected URIs – retained for potential future actions
const selectedUris = new Set();
// Expose so askAuspex() can read the set via window.selectedUris
window.selectedUris = selectedUris;

async function runSearch() {
    const raw = document.getElementById('searchInput').value;
    if (!raw) return;

    let parsed = parseQuery(raw);
    const metaExtra = extractMetaTokens(parsed);
    parsed.cleaned = metaExtra.cleaned;
    const metadata = parsed.metadata;
    const extra = metaExtra.extra;

    // Also check URL parameters to apply filters from the URL
    const urlParams = new URLSearchParams(window.location.search);
    const urlFilterFields = ['category', 'topic', 'sentiment', 'news_source', 'future_signal'];
    
    // Add URL parameters to metadata if they aren't already there
    urlFilterFields.forEach(field => {
        const urlValue = urlParams.get(field);
        if (urlValue && !metadata[field]) {
            metadata[field] = urlValue;
        }
    });

    // Determine result cap (topK) and pagination size
    let topK = 10000; // default 10000 (effectively unlimited)
    let pageSize = DEFAULT_PAGE_SIZE;

    if (extra.limit !== undefined) {
        topK = extra.limit;
        if (topK === 0) { // treat 0 as unlimited
            topK = 10000;
            pageSize = DEFAULT_PAGE_SIZE; // Use default pagination for unlimited
        } else {
            pageSize = topK; // Fetch N, display N - no pagination needed
        }
    } else if (extra.cluster !== undefined) {
        // If filtering by cluster, fetch more initially to ensure the cluster is likely represented
        // Let pagination handle display limit.
        topK = 1000; // Fetch more if filtering by cluster
        pageSize = DEFAULT_PAGE_SIZE;
    }
    // Store page size globally for pagination rendering
    window._pageSize = pageSize;

    let data;

    try {
        // Keyword operator – runs full-text keyword search pathway
        if(parsed.metadata.keyword){
            const kw = parsed.metadata.keyword;
            delete parsed.metadata.keyword; // do not forward as vector filter

            const params=new URLSearchParams({
                keyword: kw,
                per_page: topK, // Use topK for API limit
                search_fields: 'title,summary,tags',
            });
            const res=await fetch(`/api/search_articles?${params.toString()}`);
            const raw=await res.json();
            const kwResults = raw.articles.map(a=>({id:a.uri,score:0,metadata:a}));
            // Build facets and simple timeline (by category & date)
            const facets = {};
            const timeline = {};
            kwResults.forEach(res=>{
                const m=res.metadata;
                ["topic","category","news_source","driver_type","sentiment"].forEach(f=>{
                    if(m[f]){
                        facets[f]??={};
                        facets[f][m[f]] = (facets[f][m[f]]||0)+1;
                    }
                });
                if(m.publication_date){
                    const d=new Date(m.publication_date).toISOString().split('T')[0];
                    const cat=m.category||'Uncategorized';
                    timeline[cat]??={};
                    timeline[cat][d]=(timeline[cat][d]||0)+1;
                }
            });
            data={results:kwResults,facets,timeline};
        }else{
            // Preserve the full original query for KISSQL processing
            const params = new URLSearchParams({ q: raw, top_k: topK }); // Use raw query for KISSQL 
            
            // Add any parameters from metadata
            Object.entries(metadata).forEach(([k, v]) => params.append(k, v));
            
            // Add cluster parameter if present
            if (extra.cluster !== undefined) {
                params.append('cluster', extra.cluster);
            }
            
            const res = await fetch(`/api/vector-search?${params.toString()}`);
            data = await res.json();
            console.log("Received data from API:", data); // Debug: Log received data
            
            // Store the complete search query and params for other components
            // This is critical for sharing the filtered dataset
            window._lastSearchParams = params.toString();
            window._lastSearchQuery = raw;
        }
        
        currentIndex=0;
        window.lastResults=data.results;
        selectedUris.clear();
        updateActionButtons();
        renderNextPage();
        const facets=data.facets || {};
        renderFacets(facets);
        
        // Display filter impact if available
        if (data.comparison) {
            console.log("Rendering filter impact:", data.comparison); // Debug: Log comparison data
            renderFilterImpact(data.comparison, data.filtered_facets || {});
        } else {
            console.log("No comparison data received"); // Debug: Log missing comparison
            // Still show a placeholder impact message
            const impactContainer = document.getElementById('filterImpact');
            if (impactContainer) {
                impactContainer.innerHTML = `<div class="impact-box">
                    <div class="text-center text-muted small">
                        <i class="fas fa-filter me-1"></i> No filter impact data available
                    </div>
                </div>`;
            }
        }
        
        updateAttrSuggestions(facets);
        renderTimeline(data.timeline || {});
        updateActiveChips();
        
        // Update counts for enhanced UI
        if (document.getElementById('dataPointsCount')) {
            document.getElementById('dataPointsCount').textContent = data.results.length;
        }
        if (document.getElementById('totalCount')) {
            document.getElementById('totalCount').textContent = data.results.length;
        }
        
        // Force Patterns and Visuals to refresh if they've been loaded
        if (scatterLoaded) {
            console.log("Refreshing scatter plot with new filtered dataset");
            updateScatter(true); // Force refresh
        }
        
        if (patternsLoaded) {
            console.log("Refreshing patterns with new filtered dataset");
            loadPatterns(true); // Force refresh
        }
    } catch (error) {
        console.error("Search error:", error);
        alert("An error occurred during search. Please try again.");
    }
}

// -------------
// Filter parser
// -------------
function parseQuery(q){
    const metadata = {};
    const filterRegex = /filter\(([^)]+)\)/g;
    let cleaned=q;
    let m;
    
    console.log("Parsing query:", q);
    
    while((m=filterRegex.exec(q))!==null){
        cleaned=cleaned.replace(m[0],'').trim();
        const inner=m[1];
        // Find every key="value" (quotes required to allow spaces)
        const pairRe=/(\w+)\s*=\s*"([^"]+)"/g;
        let p;
        while((p=pairRe.exec(inner))!==null){
            metadata[p[1]]=p[2];
            console.log("Found filter (legacy format):", p[1], "=", p[2]);
        }
    }
    
    // ---------------------------------------------------
    // Natural-language operator synonyms → symbolic form
    // Ex: "status equal active" → "status = active"
    //     "status not equal inactive" → "status != inactive"
    // We normalise textual operators before regex parsing.
    cleaned = cleaned
        .replace(/(\b\w+)\s+not\s+equal(?:s)?\b/gi, '$1 !=')
        .replace(/(\b\w+)\s+(?:equals?|equal|is|compare)\b/gi, '$1 =');
    
    // ----------------------------------------------
    // 2. Simple attribute operators (field op value)
    // ----------------------------------------------
    // Supported ops: = != >= <= > <
    // We only forward equality to the backend for now – others stay in *cleaned* for full-text search / future use.
    // Copy of the query to safely scan attribute tokens without mutating in-place
    const scan = cleaned;
    // Fix: Improved regex to properly handle quoted values and prevent trailing quotes
    const attrRe = /(\b\w+)\s*(=|!=|>=|<=|>|<)\s*(?:"([^"]*)"|([^\s"]+))/g;
    let match;
    
    while((match = attrRe.exec(scan)) !== null){
        const [full, field, op, quotedVal, unquotedVal] = match;
        // Use the quoted value if it exists, otherwise use the unquoted value
        const val = quotedVal !== undefined ? quotedVal : unquotedVal;
        
        if(op === '='){
            metadata[field] = val;
            cleaned = cleaned.replace(full,'').trim();
            console.log("Found filter:", field, "=", val);
        }
    }
    
    console.log("Extracted metadata:", metadata);
    
    // cluster:n or cluster=n
    cleaned=cleaned.replace(/\bcluster(?:=|:)(\d+)\b/i,(m,n)=>{extra.cluster=parseInt(n);return '';});
    return {cleaned, metadata};
}

// Helper to extract limit & sort tokens; augment parseQuery externally
function extractMetaTokens(qObj){
  const extra = {};
  let {cleaned} = qObj;
  
  console.log("Extracting meta tokens from:", cleaned);
  
  // limit:n
  cleaned = cleaned.replace(/\blimit:(\d+)\b/i, (m, n) => {
    extra.limit = parseInt(n);
    console.log("Found limit token:", n);
    return '';
  });
  
  // sort:field[:dir]
  cleaned = cleaned.replace(/\bsort:([\w_]+)(?::(asc|desc))?/i, (m, f, d) => {
    extra.sort = [f, d || 'asc'];
    console.log("Found sort token:", f, d || 'asc');
    return '';
  });
  
  // cluster:n or cluster=n
  cleaned = cleaned.replace(/\bcluster(?:=|:)(\d+)\b/i, (m, n) => {
    extra.cluster = parseInt(n);
    console.log("Found cluster token:", n);
    return '';
  });
  
  console.log("Extracted meta tokens:", extra);
  
  return {cleaned: cleaned.trim(), extra};
}

function renderResults(results, reset = false) {
    const container = document.getElementById('results');
    if (reset) {
        container.innerHTML = '';
    }
    
    // Check current view mode
    const isCompactView = container.classList.contains('view-compact');
    
    results.forEach(r => {
        const card = document.createElement('div');
        card.className = 'card mb-2 position-relative ps-5';
        
        // Selection checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-check-input position-absolute';
        checkbox.style.left = '12px';
        checkbox.style.top = '18px';
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                selectedUris.add(r.id);
            } else {
                selectedUris.delete(r.id);
            }
            updateActionButtons();
        });

        const body = document.createElement('div');
        body.className = 'card-body';
        const title = r.metadata.title || 'Untitled';
        const link = r.metadata.uri ? `<a href="${r.metadata.uri}" target="_blank" rel="noopener">${title}</a>` : title;
        const summary = (r.metadata.summary || '').slice(0, 160);
        const pub = r.metadata.publication_date ? new Date(r.metadata.publication_date).toISOString().split('T')[0] : '';

        if (isCompactView) {
            // Compact layout - more table-like (no delete button)
            body.innerHTML = `
                <div class="d-flex align-items-center justify-content-between w-100">
                    <h6 class="mb-0 flex-grow-1 me-3">${link}</h6>
                    <div class="d-flex align-items-center gap-3 flex-shrink-0">
                        <small class="text-muted">${pub}</small>
                        <small class="text-muted">${r.metadata.news_source || ''}</small>
                        <small class="text-muted">${r.metadata.category || ''}</small>
                        <small class="badge bg-light text-dark">${r.score.toFixed(2)}</small>
                    </div>
                </div>`;
        } else {
            // Regular layout (list and grid) - enhanced badges without delete button
            const metadata = r.metadata;
            
            // Create comprehensive badges for all metadata - make them clickable
            let badgesHtml = '<div class="mb-2">';
            
            // Primary badges (always visible if present) - add click handlers
            if (metadata.category) {
                badgesHtml += `<span class="badge bg-primary me-1 mb-1 clickable-badge" data-field="category" data-value="${metadata.category}" style="cursor: pointer;" title="Category: ${metadata.category} (click to filter)">${metadata.category}</span>`;
            }
            if (metadata.sentiment) {
                const sentimentClass = metadata.sentiment.toLowerCase() === 'positive' ? 'bg-success' : 
                                     metadata.sentiment.toLowerCase() === 'negative' ? 'bg-danger' : 
                                     metadata.sentiment.toLowerCase() === 'critical' ? 'bg-dark' :
                                     metadata.sentiment.toLowerCase() === 'mixed' ? 'bg-warning text-dark' : 'bg-secondary';
                badgesHtml += `<span class="badge ${sentimentClass} me-1 mb-1 clickable-badge" data-field="sentiment" data-value="${metadata.sentiment}" style="cursor: pointer;" title="Sentiment: ${metadata.sentiment} (click to filter)">${metadata.sentiment}</span>`;
            }
            if (metadata.time_to_impact) {
                const timeClass = metadata.time_to_impact.toLowerCase() === 'immediate' ? 'bg-danger' :
                                metadata.time_to_impact.toLowerCase() === 'short-term' ? 'bg-warning text-dark' :
                                metadata.time_to_impact.toLowerCase() === 'mid-term' ? 'bg-info' : 'bg-secondary';
                badgesHtml += `<span class="badge ${timeClass} me-1 mb-1 clickable-badge" data-field="time_to_impact" data-value="${metadata.time_to_impact}" style="cursor: pointer;" title="Time to Impact: ${metadata.time_to_impact} (click to filter)">${metadata.time_to_impact}</span>`;
            }
            if (metadata.driver_type) {
                badgesHtml += `<span class="badge bg-dark me-1 mb-1 clickable-badge" data-field="driver_type" data-value="${metadata.driver_type}" style="cursor: pointer;" title="Driver Type: ${metadata.driver_type} (click to filter)">${metadata.driver_type}</span>`;
            }
            if (metadata.future_signal) {
                badgesHtml += `<span class="badge bg-info me-1 mb-1 clickable-badge" data-field="future_signal" data-value="${metadata.future_signal}" style="cursor: pointer;" title="Future Signal: ${metadata.future_signal} (click to filter)">${metadata.future_signal}</span>`;
            }
            
            // Secondary badges (additional metadata)
            if (metadata.topic) {
                badgesHtml += `<span class="badge bg-outline-secondary border me-1 mb-1 clickable-badge" data-field="topic" data-value="${metadata.topic}" style="cursor: pointer;" title="Topic: ${metadata.topic} (click to filter)">${metadata.topic}</span>`;
            }
            
            badgesHtml += '</div>';
            
            body.innerHTML = `
                <div class="flex-grow-1">
                    <h6 class="ms-4">${link}</h6>
                    <p class='mb-1 ms-4'><small>${pub} · ${metadata.news_source || ''}</small></p>
                    <p class='mb-1 text-muted small ms-4'>${summary}</p>
                    <div class="ms-4">${badgesHtml}</div>
                    <p class='mb-1 ms-4'><small>Score: ${r.score.toFixed(3)}</small></p>
                </div>`;
        }
            
        card.appendChild(checkbox);
        card.appendChild(body);
        
        // Add click handlers for badges after the card is created
        card.querySelectorAll('.clickable-badge').forEach(badge => {
            badge.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent card click event
                const field = badge.dataset.field;
                const value = badge.dataset.value;
                const input = document.getElementById('searchInput');
                const cleanValue = value.replace(/["']/g, '');
                const token = `${field}="${cleanValue}"`;
                
                if (input.value.includes(token)) {
                    // Remove filter if already present
                    input.value = input.value.replace(token, '').trim();
                } else {
                    // Add filter
                    input.value = `${input.value} ${token}`.trim();
                }
                runSearch();
            });
        });
        
        card.addEventListener('click', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'A' || e.target.closest('a') || e.target.closest('button') || e.target.classList.contains('clickable-badge')) return;
            renderMetadata(r.metadata);
        });
        
        container.appendChild(card);
    });
}

function renderFacets(facets) {
    const el = document.getElementById('facetList');
    el.innerHTML = '';
    
    Object.entries(facets).forEach(([field, values]) => {
        const group = document.createElement('div');
        group.className = 'facet-group';
        group.innerHTML = `<strong>${field}</strong>`;
        
        const entries = Object.entries(values).sort((a, b) => b[1] - a[1]);
        
        // Show first 10 items instead of 5, with show more/less functionality
        entries.slice(0, 10).forEach(([val, count]) => {
            const item = document.createElement('div');
            item.className = 'facet-item';
            item.innerHTML = `${val} (${count})`;
            item.addEventListener('click', () => {
                const input = document.getElementById('searchInput');
                const cleanValue = val.replace(/["']/g, '');
                const token = `${field}="${cleanValue}"`;
                
                if (input.value.includes(token)) {
                    input.value = input.value.replace(token, '').trim();
                } else {
                    input.value = `${input.value} ${token}`.trim();
                }
                runSearch();
            });
            group.appendChild(item);
        });
        
        // Add "show more" functionality if there are more than 10 items
        if (entries.length > 10) {
            const hiddenItems = entries.slice(10);
            const moreContainer = document.createElement('div');
            moreContainer.className = 'facet-more-items';
            moreContainer.style.display = 'none';
            
            hiddenItems.forEach(([val, count]) => {
                const item = document.createElement('div');
                item.className = 'facet-item';
                item.innerHTML = `${val} (${count})`;
                item.addEventListener('click', () => {
                    const input = document.getElementById('searchInput');
                    const cleanValue = val.replace(/["']/g, '');
                    const token = `${field}="${cleanValue}"`;
                    
                    if (input.value.includes(token)) {
                        input.value = input.value.replace(token, '').trim();
                    } else {
                        input.value = `${input.value} ${token}`.trim();
                    }
                    runSearch();
                });
                moreContainer.appendChild(item);
            });
            
            const toggleButton = document.createElement('button');
            toggleButton.className = 'btn btn-sm btn-link text-primary p-0 mt-1';
            toggleButton.innerHTML = `<i class="fas fa-chevron-down me-1"></i>Show ${hiddenItems.length} more`;
            toggleButton.addEventListener('click', () => {
                const isVisible = moreContainer.style.display === 'block';
                moreContainer.style.display = isVisible ? 'none' : 'block';
                toggleButton.innerHTML = isVisible ? 
                    `<i class="fas fa-chevron-down me-1"></i>Show ${hiddenItems.length} more` :
                    `<i class="fas fa-chevron-up me-1"></i>Show less`;
            });
            
            group.appendChild(moreContainer);
            group.appendChild(toggleButton);
        }
        
        el.appendChild(group);
    });
}

function renderMetadata(meta) {
    const pre = document.getElementById('metaContent');
    const rows = Object.entries(meta).map(([k, v]) => {
        let val = v;
        if (k === 'uri' || k === 'url') {
            val = `<a href="${v}" target="_blank">link</a>`;
        }
        if (['topic', 'category', 'news_source', 'sentiment', 'driver_type'].includes(k)) {
            val = `<a href="#" class="meta-filter" data-field="${k}" data-val="${v}">${v}</a>`;
        }
        return `<tr><th class='text-end pe-2'>${k}</th><td>${val ?? ''}</td></tr>`;
    }).join('');
    pre.innerHTML = `<table class='table table-sm'>${rows}</table>`;

    // Related articles
    const relDiv = document.createElement('div');
    relDiv.innerHTML = '<h6 class="mt-3">Related</h6>';
    const relList = document.createElement('ul');
    relList.className = 'list-unstyled small';
    
    fetch(`/api/vector-similar?uri=${encodeURIComponent(meta.uri)}&top_k=5`).then(r => r.json()).then(d => {
        d.results.forEach(r => {
            const li = document.createElement('li');
            li.innerHTML = `<a href="#" class="related-link" data-id="${r.id}">${r.metadata.title}</a>`;
            relList.appendChild(li);
        });
    });
    relDiv.appendChild(relList);
    pre.appendChild(relDiv);

    // Event handlers
    pre.querySelectorAll('.related-link').forEach(a => {
        a.addEventListener('click', e => {
            e.preventDefault();
            const id = a.dataset.id;
            const target = (window.lastResults || []).find(r => r.id === id);
            if (target) renderMetadata(target.metadata);
        });
    });

    pre.querySelectorAll('.meta-filter').forEach(a => {
        a.addEventListener('click', e => {
            e.preventDefault();
            const { field, val } = a.dataset;
            const input = document.getElementById('searchInput');
            const token = `${field}="${val}"`;
            if (!input.value.includes(token)) {
                input.value = `${input.value} ${token}`.trim();
            }
            runSearch();
        });
    });
}

// Simple bar chart with Chart.js (use CDN)
let timelineChart;
async function renderTimeline(timeline){
    if(!timeline || !Object.keys(timeline).length){
        console.log('No timeline data available');
        return;
    }

    // Build date axis
    const dateSet=new Set();
    Object.values(timeline).forEach(catObj=>{
        Object.keys(catObj).forEach(d=>dateSet.add(d));
    });
    const labels=Array.from(dateSet).sort();
    
    if (labels.length === 0) {
        console.log('No timeline labels found');
        return;
    }

    const palette=[
        '#6c63ff','#ff6384','#36a2eb','#ff9f40','#4bc0c0','#9966ff','#c9cbcf',
    ];
    const datasets=Object.entries(timeline).map(([cat,obj],idx)=>({
        label:cat,
        data:labels.map(d=>obj[d]||0),
        backgroundColor:palette[idx%palette.length],
        stack:'stack1'
    }));

    if(!window.Chart){
        console.log('Loading Chart.js...');
        await loadChartJs();
    }
    
    const canvas = document.getElementById('timelineChart');
    if (!canvas) {
        console.error('Timeline chart canvas not found');
        return;
    }
    
    const ctx = canvas.getContext('2d');
    if(timelineChart){
        timelineChart.destroy();
    }
    
    try {
        timelineChart=new Chart(ctx,{
            type:'bar',
            data:{labels,datasets},
            options:{
                responsive: true,
                maintainAspectRatio: false,
                plugins:{legend:{display:true,position:'bottom'}},
                scales:{
                    x:{stacked:true,ticks:{autoSkip:true,maxTicksLimit:10}},
                    y:{stacked:true,beginAtZero:true},
                }
            }
        });
        console.log('Timeline chart rendered successfully');
    } catch (error) {
        console.error('Error creating timeline chart:', error);
    }
}

function loadChartJs(){
    return new Promise(res=>{
        if (window.Chart) {
            res();
            return;
        }
        const s=document.createElement('script');
        s.src='https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
        s.onload=()=>{
            console.log('Chart.js loaded successfully');
            res();
        };
        s.onerror=()=>{
            console.error('Failed to load Chart.js');
            res(); // Still resolve to prevent hanging
        };
        document.head.appendChild(s);
    });
}

// Pagination helpers - Fixed to ensure proper functionality
const loadMoreBtn=document.createElement('button');
loadMoreBtn.textContent='Load more';
loadMoreBtn.className='btn btn-outline-primary my-3 d-block mx-auto';
loadMoreBtn.style.display='none';
loadMoreBtn.addEventListener('click',()=>renderNextPage());

// Ensure the button is added to the DOM after results container
document.addEventListener('DOMContentLoaded', () => {
    const resultsContainer = document.getElementById('results');
    if (resultsContainer && !resultsContainer.nextElementSibling?.classList.contains('btn-outline-primary')) {
        resultsContainer.after(loadMoreBtn);
    }
});

function renderNextPage(){
    const per = window._pageSize || DEFAULT_PAGE_SIZE;
    const slice=window.lastResults.slice(currentIndex, currentIndex + per);
    
    if(!slice.length){
        loadMoreBtn.style.display='none';
        return;
    }
    
    renderResults(slice, currentIndex===0);
    currentIndex+=slice.length;
    
    // Update load more button visibility
    if(currentIndex>=window.lastResults.length){
        loadMoreBtn.style.display='none';
    } else {
        loadMoreBtn.style.display='block';
        // Update button text to show progress
        const remaining = window.lastResults.length - currentIndex;
        loadMoreBtn.textContent = `Load ${Math.min(remaining, per)} more (${remaining} remaining)`;
    }
    
    console.log(`Rendered page: ${currentIndex}/${window.lastResults.length} articles`);
}

function updateActionButtons(){
  const reportBtn = document.getElementById('reportBtn');
  if(reportBtn){
    reportBtn.disabled = selectedUris.size === 0;
  }
  
  // Update selected count
  if (document.getElementById('selectedCount')) {
    document.getElementById('selectedCount').textContent = selectedUris.size;
  }
}

// Toggle all checkboxes in the current result list
function toggleSelectAll(){
  const checkboxes = document.querySelectorAll('#results .card input[type="checkbox"]');
  if(!checkboxes.length) return;
  const allSelected = [...checkboxes].every(cb=>cb.checked);
  checkboxes.forEach(cb=>{
      cb.checked = !allSelected;
      // Fire change so the regular handler updates the Set & buttons
      cb.dispatchEvent(new Event('change'));
  });
}

// Enhanced view toggle functionality
function toggleView(viewType) {
    const resultsContainer = document.getElementById('results');
    
    if (!resultsContainer) return;
    
    // Update container class
    resultsContainer.className = `view-${viewType}`;
    
    // Update button states - find all view toggle buttons
    const viewButtons = document.querySelectorAll('[onclick*="toggleView"]');
    viewButtons.forEach(btn => {
        btn.classList.remove('active');
        // Check if this button corresponds to the current view
        if (btn.getAttribute('onclick').includes(`'${viewType}'`)) {
            btn.classList.add('active');
        }
    });
    
    // Re-render current results with new view if we have results
    if (window.lastResults && window.lastResults.length > 0) {
        // Reset pagination and re-render from the beginning
        currentIndex = 0;
        renderResults(window.lastResults.slice(0, window._pageSize || DEFAULT_PAGE_SIZE), true);
        
        // Update load more button visibility
        const loadMoreBtn = document.querySelector('.btn-outline-primary.my-3');
        if (loadMoreBtn) {
            if (currentIndex + (window._pageSize || DEFAULT_PAGE_SIZE) < window.lastResults.length) {
                loadMoreBtn.style.display = 'block';
            } else {
                loadMoreBtn.style.display = 'none';
            }
        }
        
        // Update pagination index
        currentIndex = Math.min(window._pageSize || DEFAULT_PAGE_SIZE, window.lastResults.length);
    }
    
    console.log(`Switched to ${viewType} view`);
}

// Enhanced active filters with clickable chips
function updateActiveChips() {
    const container = document.getElementById('activeFilters');
    const { metadata } = parseQuery(document.getElementById('searchInput').value);
    container.innerHTML = '';

    // Get URL search params to detect filters added via URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const urlFilterFields = ['category', 'topic', 'sentiment', 'news_source', 'future_signal'];
    
    // Check for sort controls in the search input
    const sortMatch = document.getElementById('searchInput').value.match(/sort:(\w+)(?::(\w+))?/);
    if (sortMatch) {
        const sortField = sortMatch[1];
        const sortDir = sortMatch[2] || 'asc';
        const sortChip = document.createElement('span');
        sortChip.className = 'filter-chip';
        sortChip.innerHTML = `<i class="fas fa-sort-amount-${sortDir === 'asc' ? 'up' : 'down'}"></i> ${sortField} <i class="fas fa-times ms-1"></i>`;
        sortChip.addEventListener('click', () => {
            const input = document.getElementById('searchInput');
            input.value = input.value.replace(sortMatch[0], '').trim();
            runSearch();
        });
        container.appendChild(sortChip);
    }
    
    // Check for pipe operators 
    const pipeMatches = Array.from(document.getElementById('searchInput').value.matchAll(/\|\s*(HEAD|TAIL|SAMPLE)(?:\s+(\d+))?/g));
    pipeMatches.forEach(match => {
        const [fullMatch, operation, count] = match;
        const pipeChip = document.createElement('span');
        pipeChip.className = 'filter-chip';
        pipeChip.style.background = '#ffc107';
        pipeChip.style.color = '#000';
        const displayText = count ? `${operation}(${count})` : operation;
        pipeChip.innerHTML = `<i class="fas fa-filter me-1"></i>${displayText} <i class="fas fa-times ms-1"></i>`;
        pipeChip.addEventListener('click', () => {
            const input = document.getElementById('searchInput');
            input.value = input.value.replace(fullMatch, '').trim();
            runSearch();
        });
        container.appendChild(pipeChip);
    });

    // Add chips for metadata from the query input
    Object.entries(metadata).forEach(([field, value]) => {
        const chip = document.createElement('span');
        chip.className = 'filter-chip';
        chip.innerHTML = `${field}: ${value} <i class="fas fa-times ms-1"></i>`;
        chip.addEventListener('click', () => {
            const raw = document.getElementById('searchInput').value;
            // Carefully remove filter tokens
            const quotedPattern = `${field}="${value}"`;
            const unquotedPattern = `${field}=${value}`;
            const legacyPattern = `filter(${field}="${value}")`;
            
            let updated = raw;
            if (raw.includes(quotedPattern)) {
                updated = updated.replace(quotedPattern, '');
            } else if (raw.includes(unquotedPattern)) {
                updated = updated.replace(unquotedPattern, '');
            } else if (raw.includes(legacyPattern)) {
                updated = updated.replace(legacyPattern, '');
            }
            
            document.getElementById('searchInput').value = updated.trim();
            runSearch();
        });
        container.appendChild(chip);
    });
    
    // Add chips for URL parameters that aren't already shown
    urlFilterFields.forEach(field => {
        const urlValue = urlParams.get(field);
        if (urlValue && !metadata[field]) {
            const chip = document.createElement('span');
            chip.className = 'filter-chip';
            chip.style.background = '#17a2b8';
            chip.innerHTML = `${field}: ${urlValue} <i class="fas fa-times ms-1"></i>`;
            chip.addEventListener('click', () => {
                // Remove from URL and refresh
                urlParams.delete(field);
                window.location.search = urlParams.toString();
            });
            container.appendChild(chip);
            
            // Also add to the search input if not already there
            const input = document.getElementById('searchInput');
            if (!input.value.includes(`${field}=`) && !input.value.includes(`${field}"`)) {
                input.value = `${input.value} ${field}="${urlValue}"`.trim();
            }
        }
    });
    
    // Update filter count
    const filterCount = Object.keys(metadata).length + (sortMatch ? 1 : 0) + pipeMatches.length;
    if (document.getElementById('filterCount')) {
        document.getElementById('filterCount').textContent = filterCount;
    }
    
    if (container.childNodes.length === 0) {
        container.innerHTML = '<small class="text-muted">No filters applied</small>';
    }
}

// ---------------------------
// Autosuggest / autocomplete helpers (Awesomplete)
// ---------------------------
let awesomplete;

function initializeAwesomplete() {
    if (document.getElementById('searchInput') && !awesomplete) {
        awesomplete = new Awesomplete(
            document.getElementById('searchInput'),
            { minChars: 1, maxItems: 20, autoFirst: true }
        );
        // Seed with base tokens so autocomplete works before first search
        updateAttrSuggestions({});
    }
}

function updateAttrSuggestions(facets){
  if (!awesomplete) return;
  
  const seen=new Set();
  const addVal=v=>{if(!seen.has(v)){seen.add(v);} };
  
  // Add basic operators and field names
  ['keyword=','topic=','category=','sentiment=','driver_type=','future_signal=',
   'news_source=','has:','similar:','cluster=',
   'sort:','limit:','AND','OR','NOT',
   '^','!=','>=','<=','>','<'].forEach(addVal);
  
  // Add properly formatted facet values with quotes
  Object.entries(facets||{}).forEach(([field,vals])=>{
    Object.keys(vals).slice(0,50).forEach(val => {
      // Ensure values with spaces are properly quoted
      const cleanVal = val.trim().replace(/["']/g, ''); // Remove any existing quotes
      const formattedToken = `${field}="${cleanVal}"`;
      addVal(formattedToken);
    });
  });
  
  awesomplete.list=[...seen];
}

// Event handlers
document.getElementById('selectAllBtn').addEventListener('click',toggleSelectAll);
document.getElementById('reportBtn').addEventListener('click',()=>{
  const ids = Array.from(selectedUris);
  if(!ids.length){return;}
  // Re-use the Auspex summary generator as a simple report for now
  askAuspex(ids,null);
});

document.getElementById('searchIcon').addEventListener('click', runSearch);
// Trigger search on Enter key inside input
document.getElementById('searchInput').addEventListener('keydown',e=>{if(e.key==='Enter'){runSearch();}});

// Handle clear search button
document.getElementById('clearSearchBtn').addEventListener('click', () => {
    document.getElementById('searchInput').value = '';
    document.getElementById('clearSearchBtn').style.display = 'none';
    // Reset results
    document.getElementById('results').innerHTML = '';
});

// Show/hide clear button based on search input content
document.getElementById('searchInput').addEventListener('input', function() {
    document.getElementById('clearSearchBtn').style.display = this.value ? 'block' : 'none';
});

// Fetch news facts once on page load
async function fetchNewsFacts() {
   try {
       const res = await fetch('/api/news-facts');
       if (res.ok) {
           const data = await res.json();
           if (data && data.facts && Array.isArray(data.facts)) {
               window._newsFacts = data.facts;
               console.log(`Fetched ${window._newsFacts.length} news facts.`);
           } else {
               console.error('Invalid format received from /api/news-facts');
           }
       } else {
           console.error('Failed to fetch news facts:', res.status);
       }
   } catch (err) {
       console.error('Error fetching news facts:', err);
   }
}

// Initialize page elements
function initializePageElements() {
    // Set up filter impact box with initial placeholder
    const impactContainer = document.getElementById('filterImpact');
    if (impactContainer) {
        impactContainer.innerHTML = `<div class="impact-box">
            <div class="text-center text-muted small">
                <i class="fas fa-filter me-1"></i> 0 of 0 results (0%)
            </div>
        </div>`;
    }
    
    // Initialize collapsible panels
    initializeCollapsiblePanels();
    
    // Check if URL has any search parameters that should trigger a search
    const urlParams = new URLSearchParams(window.location.search);
    const urlFilterFields = ['category', 'topic', 'sentiment', 'news_source', 'future_signal', 'q'];
    const hasSearchParams = urlFilterFields.some(field => urlParams.has(field));
    
    if (hasSearchParams) {
        console.log('Found search parameters in URL, running initial search');
        
        // If q parameter exists, set it as the search input
        if (urlParams.has('q')) {
            document.getElementById('searchInput').value = urlParams.get('q');
        }
        
        // Add filter tokens to search input for each filter parameter
        urlFilterFields.filter(f => f !== 'q').forEach(field => {
            if (urlParams.has(field)) {
                const value = urlParams.get(field);
                const input = document.getElementById('searchInput');
                if (!input.value.includes(`${field}=`) && !input.value.includes(`${field}"`)) {
                    input.value = `${input.value} ${field}="${value}"`.trim();
                }
            }
        });
        
        // Run search with the constructed input
        setTimeout(() => runSearch(), 100); // Small delay to ensure DOM is ready
    } else {
        // No URL parameters - set default search to "*" and run search
        console.log('No URL parameters found, setting default search to "*"');
        document.getElementById('searchInput').value = '*';
        
        // Run search with default query after a small delay
        setTimeout(() => runSearch(), 200); // Small delay to ensure DOM is ready
    }
    
    // Load saved searches
    loadSavedSearches();
}

// Initialize collapsible panels
function initializeCollapsiblePanels() {
    // Set initial state for sidebar panels - start with active filters expanded by default
    const expandedPanels = ['filtersPanel']; // Start with filters expanded
    const collapsedPanels = ['helpPanel']; // Start with help collapsed
    
    expandedPanels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel) {
            panel.classList.remove('collapsed');
        }
    });
    
    collapsedPanels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel) {
            panel.classList.add('collapsed');
        }
    });
    
    // Initialize tab panes to be collapsible by default
    const tabPanes = ['patternsPane', 'vizPane'];
    tabPanes.forEach(paneId => {
        const pane = document.getElementById(paneId);
        if (pane) {
            pane.classList.add('collapsible');
        }
    });
    
    // Ensure expand buttons have correct initial icons
    document.querySelectorAll('.expand-toggle i').forEach(icon => {
        if (icon.closest('.tab-pane') || icon.closest('.filter-panel-content.collapsed')) {
            icon.className = 'fas fa-expand-alt';
        }
    });
}

// --------------------------
// Saved Searches Management
// --------------------------

// Initialize saved searches
let savedSearches = [];
let currentlySelectedSearchId = null;

// Load saved searches from server
async function loadSavedSearches() {
    try {
        const res = await fetch('/api/saved-searches');
        if (res.ok) {
            savedSearches = await res.json();
            renderSavedSearches();
        }
    } catch (err) {
        console.error('Error loading saved searches:', err);
    }
}

// Render saved searches in the sidebar
function renderSavedSearches() {
    const container = document.getElementById('explorationsContainer');
    const dropdown = document.getElementById('explorationsDropdown');
    
    // Clear existing options except the first placeholder
    while (dropdown.options.length > 1) {
        dropdown.remove(1);
    }
    
    if (!savedSearches || savedSearches.length === 0) {
        container.innerHTML = '<div class="text-muted small">No saved searches yet</div>';
        return;
    }
    
    // Populate dropdown
    savedSearches.forEach(search => {
        const option = document.createElement('option');
        option.value = search.id;
        option.textContent = search.name;
        dropdown.appendChild(option);
    });
    
    // Set dropdown to currently selected search
    if (currentlySelectedSearchId) {
        dropdown.value = currentlySelectedSearchId;
    }
    
    // Only display the currently selected search
    if (currentlySelectedSearchId) {
        const selectedSearch = savedSearches.find(s => s.id === currentlySelectedSearchId);
        if (selectedSearch) {
            const searchHtml = `
                <div class="exploration-item">
                    <div class="exploration-name">${selectedSearch.name}</div>
                    <div class="exploration-description">${selectedSearch.description || ''}</div>
                </div>
            `;
            container.innerHTML = searchHtml;
        } else {
            container.innerHTML = '<div class="text-muted small">No search selected</div>';
        }
    } else {
        container.innerHTML = '<div class="text-muted small">Select a saved search from the dropdown</div>';
    }
}

// Apply a saved search to the current search input
function applySavedSearch(id) {
    const search = savedSearches.find(s => s.id === id);
    if (search) {
        currentlySelectedSearchId = id; // Track the selected search
        document.getElementById('searchInput').value = search.query;
        renderSavedSearches(); // Update the display to show only the selected search
        runSearch();
    }
}

// Save search handler
document.getElementById('saveSearchBtn').addEventListener('click', () => {
    const query = document.getElementById('searchInput').value.trim();
    
    if (!query) {
        alert('Please enter a search query first');
        return;
    }
    
    // Reset form
    document.getElementById('searchId').value = '';
    document.getElementById('searchName').value = '';
    document.getElementById('searchDescription').value = '';
    document.getElementById('searchTags').value = '';
    document.getElementById('searchQuery').value = query;
    
    // Show modal
    bootstrap.Modal.getOrCreateInstance(document.getElementById('saveSearchModal')).show();
});

// Save search submit handler
document.getElementById('saveSearchSubmitBtn').addEventListener('click', async () => {
    const form = document.getElementById('saveSearchForm');
    
    // Basic form validation
    if (!document.getElementById('searchName').value.trim()) {
        alert('Please enter a name for your search');
        return;
    }
    
    // Gather form data
    const search = {
        id: document.getElementById('searchId').value || generateId(),
        name: document.getElementById('searchName').value.trim(),
        description: document.getElementById('searchDescription').value.trim(),
        tags: document.getElementById('searchTags').value.trim(),
        query: document.getElementById('searchQuery').value.trim(),
        created_at: new Date().toISOString()
    };
    
    try {
        const res = await fetch('/api/saved-searches', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(search)
        });
        
        if (res.ok) {
            // Add to local cache or update existing
            const existingIndex = savedSearches.findIndex(s => s.id === search.id);
            if (existingIndex >= 0) {
                savedSearches[existingIndex] = search;
            } else {
                savedSearches.push(search);
            }
            
            renderSavedSearches();
            bootstrap.Modal.getInstance(document.getElementById('saveSearchModal')).hide();
        } else {
            alert('Failed to save search. Please try again.');
        }
    } catch (err) {
        console.error('Error saving search:', err);
        alert('An error occurred while saving your search');
    }
});

// Helper to generate a unique ID for new searches
function generateId() {
    return 'search_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
}

function renderFilterImpact(comparison, filteredFacets) {
    // Get impact box (it's now a permanent element in the DOM)
    const impactContainer = document.getElementById('filterImpact');
    
    const totalBefore = comparison.total_before;
    const totalAfter = comparison.total_after;
    const percentRetained = totalBefore ? Math.round((totalAfter / totalBefore) * 100) : 0;
    
    // Determine impact class based on percentage retained
    const impactClass = percentRetained > 75 ? 'impact-positive' : 
                       percentRetained < 25 ? 'impact-negative' : '';
    
    // Simplified view - just show X of Y (X%)
    const simpleSummary = `${totalAfter} of ${totalBefore} results (${percentRetained}%)`;
    
    // Build the HTML with debug toggle
    let impactHtml = `
        <div class="impact-box">
            <div class="impact-summary ${impactClass}">
                <span><i class="fas fa-filter me-1"></i> ${simpleSummary}</span>
                <button id="toggleDebugBtn" class="btn btn-sm btn-link p-0 ms-2" title="Toggle debug info">
                    <i class="fas fa-bug"></i>
                </button>
            </div>`;
    
    // Add detailed impact info (initially hidden)
    impactHtml += `<div class="impact-details" id="impactDebugDetails" style="display:none;">`;
    
    // For each facet type, show the top impacted values
    Object.entries(comparison.facet_impact).forEach(([field, values]) => {
        const sortedImpacts = Object.entries(values)
            .sort((a, b) => Math.abs(b[1].diff) - Math.abs(a[1].diff))
            .slice(0, 5); // Show top 5 most impacted values
        
        if (sortedImpacts.length > 0) {
            impactHtml += `<div class="mb-2"><strong>${field}</strong>: `;
            sortedImpacts.forEach(([value, impact]) => {
                const diffClass = impact.diff === 0 ? 'neutral' : 
                                 impact.diff > 0 ? 'positive' : 'negative';
                const diffText = impact.diff === 0 ? '0' : 
                                impact.diff > 0 ? `+${impact.diff}` : impact.diff;
                
                impactHtml += `<span class="me-2">${value} <span class="impact-badge ${diffClass}">${diffText}</span></span>`;
            });
            impactHtml += `</div>`;
        }
    });
    
    impactHtml += `</div></div>`;
    impactContainer.innerHTML = impactHtml;
    
    // Add event listener for debug toggle button
    document.getElementById('toggleDebugBtn')?.addEventListener('click', function() {
        const debugDetails = document.getElementById('impactDebugDetails');
        if (debugDetails) {
            const isVisible = debugDetails.style.display !== 'none';
            debugDetails.style.display = isVisible ? 'none' : 'block';
        }
    });
}

// Add a helper function to apply sorts
function applySortToSearch(field, dir) {
    const input = document.getElementById('searchInput');
    
    // Check if we're already sorting by this field
    const currentSortMatch = input.value.match(
        new RegExp(`\\bsort:${field}(?::(?:asc|desc))?\\b`, 'i')
    );
    
    if (currentSortMatch) {
        // We're already sorting by this field, toggle direction if not specified
        if (!dir) {
            const currentSort = currentSortMatch[0];
            // Check if a direction is specified
            if (currentSort.includes(':asc')) {
                dir = 'desc';
            } else if (currentSort.includes(':desc')) {
                dir = 'asc';
            } else {
                // Default was asc, switch to desc
                dir = 'desc';
            }
        }
        
        // Remove the current sort token
        input.value = input.value.replace(currentSortMatch[0], '').trim();
    } else {
        // Remove any existing sort tokens for other fields
        input.value = input.value.replace(/\bsort:[\w_]+(?::(?:asc|desc))?\b/i, '').trim();
    }
    
    // Use the specified direction or default to asc
    const direction = dir || 'asc';
    
    // Add the new sort token
    const sortToken = `sort:${field}:${direction}`;
    input.value = `${input.value} ${sortToken}`.trim();
    
    // Run the search with the updated sort
    runSearch();
    
    // Add a visual indicator that sorting has been applied
    const sortDropdown = document.getElementById('sortDropdown');
    if (sortDropdown) {
        sortDropdown.classList.add('active');
        
        // Update dropdown text to show active sort
        const iconClass = direction === 'asc' ? 'fa-sort-amount-up' : 'fa-sort-amount-down';
        sortDropdown.innerHTML = `<i class="fas ${iconClass} me-1"></i> ${field}`;
    }
}

// Enhanced expand/collapse functionality
function togglePaneExpansion(paneId, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    
    const pane = document.getElementById(paneId);
    const button = event ? event.target.closest('.expand-toggle') : null;
    const icon = button ? button.querySelector('i') : null;
    
    if (pane) {
        const isCollapsed = pane.classList.contains('collapsible');
        
        if (isCollapsed) {
            // Expand
            pane.classList.remove('collapsible');
            pane.classList.add('expanded');
            if (icon) {
                icon.className = 'fas fa-compress-alt';
            }
        } else {
            // Collapse
            pane.classList.add('collapsible');
            pane.classList.remove('expanded');
            if (icon) {
                icon.className = 'fas fa-expand-alt';
            }
        }
    }
}

function toggleCardExpansion(cardBody) {
    const isExpanded = cardBody.classList.contains('expanded');
    
    if (isExpanded) {
        cardBody.classList.remove('expanded');
    } else {
        cardBody.classList.add('expanded');
    }
}

// Enhanced panel toggle functionality
function togglePanel(panelName) {
    const panel = document.getElementById(`${panelName}Panel`);
    if (!panel) return;
    
    const header = panel.previousElementSibling;
    const icon = header ? header.querySelector('.fas:last-child') : null;
    
    const isVisible = panel.style.display !== 'none';
    
    if (isVisible) {
        // Collapse
        panel.style.display = 'none';
        panel.classList.add('collapsed');
    } else {
        // Expand
        panel.style.display = 'block';
        panel.classList.remove('collapsed');
    }
    
    if (icon) {
        icon.classList.toggle('fa-chevron-down');
        icon.classList.toggle('fa-chevron-up');
    }
}

function togglePanelCollapse(panelId, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    
    const panel = document.getElementById(panelId);
    const button = event ? event.target.closest('button') : null;
    const icon = button ? button.querySelector('i') : null;
    
    if (panel) {
        const isCollapsed = panel.classList.contains('collapsed');
        
        if (isCollapsed) {
            // Expand
            panel.classList.remove('collapsed');
            if (icon) {
                icon.className = 'fas fa-compress-alt text-muted';
            }
        } else {
            // Collapse
            panel.classList.add('collapsed');
            if (icon) {
                icon.className = 'fas fa-expand-alt text-muted';
            }
        }
    }
}

function toggleMetaPanel() {
    const panel = document.getElementById('metaPanel');
    const restoreBtn = document.getElementById('metaRestoreBtn');
    
    if (panel && restoreBtn) {
        const isVisible = panel.style.display !== 'none';
        
        if (isVisible) {
            // Hide panel, show restore button
            panel.style.display = 'none';
            restoreBtn.style.display = 'block';
        } else {
            // Show panel, hide restore button
            panel.style.display = 'block';
            restoreBtn.style.display = 'none';
        }
    }
}

// Query builder functions
function toggleQueryBuilder() {
    const builder = document.getElementById('queryBuilder');
    if (!builder) return;
    
    builder.classList.toggle('active');
    
    if (builder.classList.contains('active') && !builder.querySelector('.query-builder-row')) {
        addQueryBuilderRow();
    }
}

function addQueryBuilderRow() {
    const container = document.getElementById('queryBuilderRows');
    if (!container) return;
    
    const rowId = `qb-row-${Date.now()}`;
    
    const row = document.createElement('div');
    row.className = 'query-builder-row';
    row.id = rowId;
    
    row.innerHTML = `
        <select class="form-select form-select-sm" onchange="updateQueryFromBuilder()">
            <option value="">Select field...</option>
            <option value="category">Category</option>
            <option value="sentiment">Sentiment</option>
            <option value="topic">Topic</option>
            <option value="news_source">News Source</option>
            <option value="driver_type">Driver Type</option>
        </select>
        <select class="form-select form-select-sm" onchange="updateQueryFromBuilder()">
            <option value="=">=</option>
            <option value="!=">≠</option>
        </select>
        <input type="text" class="form-control form-control-sm" 
               placeholder="Value..." onchange="updateQueryFromBuilder()">
        <button class="btn btn-sm btn-outline-danger" onclick="removeQueryBuilderRow('${rowId}')">
            <i class="fas fa-times"></i>
        </button>
    `;
    
    container.appendChild(row);
}

function removeQueryBuilderRow(rowId) {
    const row = document.getElementById(rowId);
    if (row) {
        row.remove();
        updateQueryFromBuilder();
    }
}

function updateQueryFromBuilder() {
    const rows = document.querySelectorAll('.query-builder-row');
    const conditions = [];
    
    rows.forEach(row => {
        const [field, operator, value] = row.querySelectorAll('select, input');
        if (field && operator && value && field.value && operator.value && value.value) {
            conditions.push(`${field.value}${operator.value}"${value.value}"`);
        }
    });
    
    const input = document.getElementById('searchInput');
    if (input) {
        input.value = conditions.join(' AND ');
    }
}

function clearQueryBuilder() {
    const container = document.getElementById('queryBuilderRows');
    if (container) {
        container.innerHTML = '';
    }
    const input = document.getElementById('searchInput');
    if (input) {
        input.value = '';
    }
}

// Quick filter functionality
function addQuickFilter(field, value) {
    const input = document.getElementById('searchInput');
    if (!input) return;
    
    const currentQuery = input.value;
    const filterString = field ? `${field}="${value}"` : value;
    const newQuery = currentQuery ? `${currentQuery} ${filterString}` : filterString;
    
    input.value = newQuery;
    runSearch();
}

// Stub functions that will be replaced with actual implementations
function loadPatterns(forceRefresh = false) {
    console.log('Patterns loading - full implementation will be added next');
}

function updateScatter(forceRefresh = false) {
    console.log('Visualization loading - full implementation will be added next');
}

async function askAuspex(idsToSummarize = null, clusterId = null, modelName = null) {
    console.log('Auspex functionality - full implementation will be added next');
}

// Initialize everything when DOM is ready - moved here to run before function definitions
document.addEventListener('DOMContentLoaded', () => {
    fetchNewsFacts();
    initializePageElements();
    initializeAwesomplete(); // Initialize autocomplete
    
    // Add dropdown handler for saved searches
    document.getElementById('explorationsDropdown').addEventListener('change', function() {
        const selectedId = this.value;
        if (selectedId) {
            applySavedSearch(selectedId);
        } else {
            currentlySelectedSearchId = null;
            renderSavedSearches();
        }
    });
    
    // Add event handler to check for sort state on page load
    const input = document.getElementById('searchInput');
    if (input && input.value) {
        const sortMatch = input.value.match(/\bsort:([\w_]+)(?::(?:asc|desc))?\b/i);
        if (sortMatch) {
            const field = sortMatch[1];
            const direction = sortMatch[0].includes(':asc') ? 'asc' : 
                              sortMatch[0].includes(':desc') ? 'desc' : 'asc';
            
            const sortDropdown = document.getElementById('sortDropdown');
            if (sortDropdown) {
                sortDropdown.classList.add('active');
                const iconClass = direction === 'asc' ? 'fa-sort-amount-up' : 'fa-sort-amount-down';
                sortDropdown.innerHTML = `<i class="fas ${iconClass} me-1"></i> ${field}`;
            }
        }
    }
});

// ---------------------------
// Embedding visualisation (Plotly)
// ---------------------------
// Load and render once when the tab first becomes visible
document.querySelector('button[data-bs-target="#vizPane"]').addEventListener('shown.bs.tab',()=>{
    if(scatterLoaded) return;
    scatterLoaded=true;
    initScatter();
});

async function initScatter(){
    const loading=document.getElementById('vizLoading');
    const div=document.getElementById('scatter');

    // Bring in plotly if missing
    if(!window.Plotly){
        await new Promise(res=>{
            const s=document.createElement('script');
            s.src='https://cdn.plot.ly/plotly-2.27.0.min.js';
            s.onload=res;
            document.head.appendChild(s);
        });
    }

    // Initial fetch - removed event handler (moved to updateScatter)
    window.scatterPoints=[];
    await updateScatter();

    loading.style.display='none';
    div.style.display='block';
}

// Refresh scatter with current filters
async function updateScatter(forceRefresh = false){
    const loading=document.getElementById('vizLoading');
    const div=document.getElementById('scatter');

    // Show spinner and random fact
    let randomFact = window._newsFacts.length > 0 ? window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)] : 'Generating visualization...';
    // Clear previous interval if any
    if (vizLoadingIntervalId) clearInterval(vizLoadingIntervalId);
    // Clear any existing countdown
    if (vizCountdownId) {
      clearInterval(vizCountdownId);
      vizCountdownId = null;
    }

    loading.innerHTML = `
        <div class="d-flex justify-content-center align-items-center p-4 my-4">
            <div class="spinner-border text-primary me-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div id="viz-loading-fact" class="fs-6">
                <strong>Did you know?...</strong> ${randomFact}
                <span id="viz-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>
            </div>
        </div>`;
    loading.style.display = 'block';
    div.style.display = 'none'; // Hide plot while loading

    // Start countdown timer (updates every second)
    let secondsLeft = FACT_ROTATION_SECONDS;
    vizCountdownId = setInterval(() => {
      secondsLeft -= 1;
      const countdownEl = document.getElementById('viz-countdown');
      if (countdownEl) {
        countdownEl.textContent = `${secondsLeft}s`;
      }
      if (secondsLeft <= 0) {
        secondsLeft = FACT_ROTATION_SECONDS; // Reset when a new fact appears
      }
    }, 1000);

    // Start interval to rotate facts
    vizLoadingIntervalId = setInterval(() => {
        const factElement = document.getElementById('viz-loading-fact');
        if (factElement && window._newsFacts.length > 0) {
            let newFact = window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)];
            factElement.innerHTML = `<strong>Did you know?...</strong> ${newFact}
                <span id="viz-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>`;
            // Reset the countdown
            secondsLeft = FACT_ROTATION_SECONDS;
        }
    }, FACT_ROTATION_SECONDS * 1000);

    // Use same query params as main search for consistency with filtering
    let params = new URLSearchParams(window._lastSearchParams || "");
    if (!params.toString()) {
        params = buildQueryParams();
    }
    
    console.log("Loading visualization with params:", params.toString());
    
    // Add visualization specific parameters
    const dims3d = document.getElementById('embed3d').checked;
    const colorMode = document.getElementById('colorMode').value;
    const clusterMethod = document.getElementById('clusterMethod') ? document.getElementById('clusterMethod').value : 'kmeans';
    const nClusters = document.getElementById('nClusters') ? parseInt(document.getElementById('nClusters').value) || 30 : 30;
    
    params.append('method', document.getElementById('embedMethod').value);
    params.append('dims', dims3d ? '3' : '2');
    if (clusterMethod) params.append('cluster_method', clusterMethod);
    if (nClusters) params.append('n_clusters', nClusters);
    
    try {
        const res = await fetch(`/api/embedding_projection?${params.toString()}`);
        if (!res.ok) {
            loading.innerHTML = `<div class="alert alert-danger">Error: ${res.status} ${res.statusText}</div>`;
            return;
        }
        const data = await res.json();
        
        const pts = data.points || data;
        if(!pts.length){
            loading.textContent='No data';
            return;
        }

        window.scatterPoints=pts;
        window.clusterExplain=data.explain||{};
        window.clusterCentroids=data.centroids||{};

        const custom=pts.map(p=>(window.clusterExplain[p.cluster]||[]).join(', '));

        let legendItems;
        let colourMap=new Map();
        let pointColors;

        if(colorMode!=='cluster'){
            legendItems=[...new Set(pts.map(p=>(p[colorMode]||'unknown')))].sort();
            const colours=palette(legendItems.length);
            legendItems.forEach((s,idx)=>colourMap.set(s,colours[idx]));
            pointColors=pts.map(p=>colourMap.get(p[colorMode]||'unknown'));
        }else{
            legendItems=[...new Set(pts.map(p=>p.cluster))].sort((a,b)=>a-b);
            const colours=palette(legendItems.length);
            legendItems.forEach((c,idx)=>colourMap.set(c,colours[idx]));
            pointColors=pts.map(p=>colourMap.get(p.cluster));
        }

        // Debug logging
        console.log('🎨 Visualization Debug Info:');
        console.log('Points:', pts.length);
        console.log('Color mode:', colorMode);
        console.log('Legend items:', legendItems);
        console.log('Point colors length:', pointColors.length);
        console.log('Sample point colors:', pointColors.slice(0, 5));
        
        // Validate pointColors array
        if (!pointColors || pointColors.length === 0) {
            console.error('❌ pointColors array is empty!');
            pointColors = new Array(pts.length).fill('#6c63ff'); // fallback color
        }
        
        // Ensure all colors are valid
        pointColors = pointColors.map(color => color || '#6c63ff');

        let trace;
        let layout;
        if(dims3d){
            trace={
              type:'scatter3d',mode:'markers',
              x:pts.map(p=>p.x),
              y:pts.map(p=>p.y),
              z:pts.map(p=>p.z||0),
              marker:{
                size:3, // Half the previous size for very subtle dots
                color:pointColors,
                opacity:0.75, // Semi-transparent for softer look
                symbol: 'circle'
              },
              text:pts.map(p=>p.title||''),
              customdata:custom,
              hovertemplate:'%{text}<br><small>%{customdata}</small><extra></extra>'
            };
            layout={
                margin:{t:0,l:0,r:0,b:0},
                scene:{
                    aspectmode:'data',
                    camera: {eye: {x: 1.2, y: 1.2, z: 1.2}}
                }
            };
        }else{
            trace={
              type:'scatter',mode:'markers',
              x:pts.map(p=>p.x),
              y:pts.map(p=>p.y),
              marker:{
                size:4, // Half the previous size for very subtle dots
                color:pointColors,
                opacity:0.75, // Semi-transparent for softer look
                symbol: 'circle'
              },
              text:pts.map(p=>p.title||''),
              customdata:custom,
              hovertemplate:'%{text}<br><small>%{customdata}</small><extra></extra>'
            };
            layout={
                margin:{t:20,l:20,r:20,b:20},
                hovermode:'closest',
                showlegend: false,
                xaxis: {showgrid: true, zeroline: true},
                yaxis: {showgrid: true, zeroline: true}
            };
        }
        
        console.log('📊 Creating plot with trace:', trace);
        console.log('📊 Layout:', layout);
        
        // Create the plot with error handling
        try {
            await Plotly.react(div,[trace],layout);
            console.log('✅ Plotly chart created successfully');
        } catch (plotError) {
            console.error('❌ Plotly.react failed:', plotError);
            loading.innerHTML = `<div class="alert alert-danger">Chart rendering failed: ${plotError.message}</div>`;
            return;
        }

        // Now attach click event after the plot is initialized
        div.removeAttribute('on');  // Clear any existing handlers
        div.onclick = null;  // Also clear standard handlers
        
        // Attach the click handler to the plot
        div.addEventListener('plotly_click', async (ev) => {
            if (!ev || !ev.points || ev.points.length === 0) return;
            const idx = ev.points[0].pointIndex;
            if (!window.scatterPoints || !window.scatterPoints[idx]) return;
            
            const selId = window.scatterPoints[idx].id;
            try {
                const response = await fetch(`/api/embedding_neighbours?id=${encodeURIComponent(selId)}&top_k=5`);
                const neighbours = await response.json();
                const ids = [selId, ...neighbours.map(n => n.id)];
                const style = window.scatterPoints.map(p => ids.includes(p.id) ? 1 : 0.15);
                Plotly.restyle(div, {'marker.opacity': [style]});
            } catch (error) {
                console.error("Error fetching neighbours:", error);
            }
        });

        // Build legend after fetching points
        rebuildLegend(legendItems, colourMap, colorMode!=='cluster', colorMode);

    } catch (error) {
        console.error("Error in visualization:", error);
        loading.innerHTML = `<div class="alert alert-danger">Error loading visualization: ${error.message}</div>`;
    } finally {
        loading.style.display='none';
        // Clear the interval timer now that viz is loaded
        if (vizLoadingIntervalId) {
           clearInterval(vizLoadingIntervalId);
           vizLoadingIntervalId = null;
        }
        // Also clear the countdown
        if (vizCountdownId) {
          clearInterval(vizCountdownId);
          vizCountdownId = null;
        }
        div.style.display = 'block'; // Show plot again
    }
}

// Utility to build filter params object
function buildQueryParams(){
  // Use the raw query to preserve pipe operators
  const rawQuery = document.getElementById('searchInput').value;
  const p = new URLSearchParams();
  
  // Pass the complete raw query to ensure pipe operators are included
  if (rawQuery) {
    p.append('q', rawQuery);
  }
  
  // Also extract metadata filters for backward compatibility
  const { metadata } = parseQuery(rawQuery);
  Object.entries(metadata).forEach(([k,v]) => p.append(k, v));
  
  return p;
}

function buildFilterParams(){
  const { metadata } = parseQuery(document.getElementById('searchInput').value);
  return metadata;
}

// ---------------------------
// Patterns and Statistics loaders
// ---------------------------
document.querySelector('button[data-bs-target="#patternsPane"]').addEventListener('shown.bs.tab',()=>{
  if(patternsLoaded) return;
  loadPatterns();
  patternsLoaded=true;
});

async function loadPatterns(forceRefresh = false){
  const list = document.getElementById('patternList');
  
  // If patterns already loaded and not a forced refresh, just return
  if (patternsLoaded && !forceRefresh) {
    console.log("Patterns already loaded, skipping.");
    return;
  }
  
  // Show spinner and random fact
  let randomFact = window._newsFacts.length > 0 ? 
      window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)] : 
      'Generating patterns...';
  
  // Clear any existing interval
  if (patternsLoadingIntervalId) {
    clearInterval(patternsLoadingIntervalId);
    patternsLoadingIntervalId = null;
  }
  // Clear any existing countdown
  if (patternsCountdownId) {
    clearInterval(patternsCountdownId);
    patternsCountdownId = null;
  }
  
  // Set loading indicator with spinner and fact
  list.innerHTML = `
    <div class="d-flex justify-content-center align-items-center p-4 my-4">
      <div class="spinner-border text-primary me-3" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div id="patterns-loading-fact" class="fs-6">
        <strong>Did you know?...</strong> ${randomFact}
        <span id="patterns-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>
      </div>
    </div>`;
  
  // Start countdown timer (updates every second)
  let secondsLeft = FACT_ROTATION_SECONDS;
  patternsCountdownId = setInterval(() => {
    secondsLeft -= 1;
    const countdownEl = document.getElementById('patterns-countdown');
    if (countdownEl) {
      countdownEl.textContent = `${secondsLeft}s`;
    }
    if (secondsLeft <= 0) {
      secondsLeft = FACT_ROTATION_SECONDS; // Reset when a new fact appears
    }
  }, 1000);

  // Start interval to rotate facts
  patternsLoadingIntervalId = setInterval(() => {
    const factElement = document.getElementById('patterns-loading-fact');
    if (factElement && window._newsFacts.length > 0) {
      let newFact = window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)];
      factElement.innerHTML = `<strong>Did you know?...</strong> ${newFact}
        <span id="patterns-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>`;
      // Reset the countdown
      secondsLeft = FACT_ROTATION_SECONDS;
    }
  }, FACT_ROTATION_SECONDS * 1000);
  
  try {
    // Use the same query parameters as the main search for consistency
    const queryParams = window._lastSearchParams || buildQueryParams().toString();
    console.log("Loading patterns with params:", queryParams);
    
    // Fetch ngrams and outliers (existing logic)
    const patternsRes = await fetch(`/api/patterns?${queryParams}`);
    const patternsData = await patternsRes.json();
    
    // Fetch cluster data
    const clusterRes = await fetch(`/api/embedding_projection?dims=2&${queryParams}`);
    const clusterData = await clusterRes.json();
    const clusterExplain = clusterData.explain || {};
    const points = clusterData.points || [];
    const clusterCounts = {};
    // Store article IDs per cluster for actions
    const clusterMemberIds = {};
    
    points.forEach(p => {
      clusterCounts[p.cluster] = (clusterCounts[p.cluster] || 0) + 1;
      if (!clusterMemberIds[p.cluster]) {
        clusterMemberIds[p.cluster] = [];
      }
      clusterMemberIds[p.cluster].push(p.id);
    });
    
    // Card for Top Keywords
    let keywordsHtml = '<div class="card mb-3 position-relative"><div class="card-header d-flex justify-content-between align-items-center">Top Keywords <button class="expand-toggle" onclick="toggleCardExpansion(this.parentElement.nextElementSibling)" title="Expand/Collapse"><i class="fas fa-expand-alt"></i></button></div><div class="card-body pattern-card-body">';
    (patternsData.ngrams||[]).slice(0,20).forEach(ng => {
      keywordsHtml += `<span class="badge bg-secondary me-1 mb-1">${ng.text} (${ng.count})</span>`;
    });
    keywordsHtml += '</div></div>'; // Close keywords card
    
    // Card for Cluster Summary
    let clustersHtml = '<div class="card mb-3 position-relative"><div class="card-header d-flex justify-content-between align-items-center">Cluster Summary <button class="expand-toggle" onclick="toggleCardExpansion(this.parentElement.nextElementSibling)" title="Expand/Collapse"><i class="fas fa-expand-alt"></i></button></div><div class="card-body pattern-card-body">';
    if (Object.keys(clusterExplain).length > 0) {
      clustersHtml += '<div class="list-group list-group-flush">';
      Object.entries(clusterExplain).sort(([idA], [idB]) => parseInt(idA) - parseInt(idB)).forEach(([id, keywords]) => {
        const count = clusterCounts[id] || 0;
        const hasSummary = window._clusterSummaries && window._clusterSummaries[id];
        clustersHtml += `
          <div class="list-group-item d-flex justify-content-between align-items-start py-1 px-0">
            <div class="ms-2 me-auto flex-grow-1">
              <div class="fw-bold">Cluster ${id} 
                <span class="badge bg-light text-dark rounded-pill me-1">${count} items</span>
                ${hasSummary ? '<span class="badge bg-success-subtle text-success-emphasis rounded-pill">Summarized</span>' : ''}
              </div>
              <small class="text-muted d-block mb-1">${keywords.slice(0, 5).join(', ')}</small>
            </div>
            <div class="ms-2">
              <button class="btn btn-sm btn-outline-secondary p-1 filter-cluster-btn" data-cluster-id="${id}" title="Filter by this cluster">
                <i class="fas fa-filter fa-xs"></i>
              </button>
              <button class="btn btn-sm btn-outline-primary p-1 summarize-cluster-btn" data-cluster-id="${id}" title="Summarize with Auspex">
                <i class="fas fa-comment-dots fa-xs"></i>
              </button>
            </div>
          </div>`;
      });
      clustersHtml += '</div>';
    } else {
      clustersHtml += '<small class="text-muted">No cluster data available.</small>';
    }
    clustersHtml += '</div></div>'; // Close clusters card
    
    // Card for Outliers
    let outliersHtml = '<div class="card mb-3 position-relative"><div class="card-header d-flex justify-content-between align-items-center">Outliers <button class="expand-toggle" onclick="toggleCardExpansion(this.parentElement.nextElementSibling)" title="Expand/Collapse"><i class="fas fa-expand-alt"></i></button></div><div class="card-body pattern-card-body">';
    // Fetch top anomalies – ensure top_k stays within API limits (≤200)
    const anoParams = new URLSearchParams(queryParams);
    const currentTopK = parseInt(anoParams.get('top_k') || '20', 10);
    if (isNaN(currentTopK) || currentTopK > 200) {
      anoParams.set('top_k', '200');
    }
    const anoRes = await fetch(`/api/embedding_anomalies?${anoParams.toString()}`);
    const anomalies = await anoRes.json();
    if (anomalies.length > 0) {
      outliersHtml += anomalies.map(a => `
        <div class="border-bottom py-1">
          <a href="#" class="outlier-link" data-id="${a.id}">${a.metadata.title || 'Untitled'}</a>
          <small class="text-muted">score ${a.score.toFixed(3)}</small>
        </div>`).join('');
    } else {
      outliersHtml += '<small class="text-muted">No outliers found.</small>';
    }
    outliersHtml += '</div></div>'; // Close outliers card
    
    // Combine HTML for all cards
    list.innerHTML = keywordsHtml + clustersHtml + outliersHtml;
    
    // Update patterns count
    if (document.getElementById('patternsCount')) {
        document.getElementById('patternsCount').textContent = (patternsData.ngrams||[]).length;
    }
    
    // Store cluster member IDs globally for event handlers
    window._clusterMemberIds = clusterMemberIds;
    
    // click to open metadata
    list.querySelectorAll('.outlier-link').forEach(link => {
      link.addEventListener('click', async e => {
        e.preventDefault();
        const id = link.dataset.id;
        let target = (window.lastResults || []).find(r => r.id === id);
        if (!target) {
          const res = await fetch(`/api/article?uri=${encodeURIComponent(id)}`);
          if (res.ok) {
            const meta = await res.json();
            renderMetadata(meta);
            return;
          }
        }
        if (target) renderMetadata(target.metadata);
      });
    });
  } catch (error) {
    console.error("Error loading patterns:", error);
    list.innerHTML = `<div class="alert alert-danger">Error loading patterns: ${error.message}</div>`;
  } finally {
    // Always clear the interval, even on error
    if (patternsLoadingIntervalId) {
      clearInterval(patternsLoadingIntervalId);
      patternsLoadingIntervalId = null;
    }
    // Also clear the countdown
    if (patternsCountdownId) {
      clearInterval(patternsCountdownId);
      patternsCountdownId = null;
    }
  }
}

// ---------------------------
// Visualization helpers – method dropdown & legend
// ---------------------------
document.getElementById('embedMethod').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

document.getElementById('embed3d').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

document.getElementById('colorMode').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

document.getElementById('clusterMethod').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

document.getElementById('nClusters').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

function rebuildLegend(items, colourMap, nonCluster=false, colorMode='cluster'){
  const container=document.getElementById('clusterLegend');
  container.innerHTML='';
  items.forEach(idx=>{
    const span=document.createElement('span');
    span.className='badge me-1';
    span.style.background=colourMap.get(idx)||'#6c63ff';
    span.style.cursor='pointer';
    let label;
    if(nonCluster){
      label=idx;
    }else{
      const kw=(window.clusterExplain||{})[idx]||[];
      label=kw.length?kw.slice(0,2).join(', '):`Cluster ${idx}`;
      if(kw.length){span.title=kw.join(', ');}  // tooltip for cluster mode
    }
    span.textContent=label;
    span.addEventListener('click',()=>{
      window._activeLabel=window._activeLabel||null;
      if(window._activeLabel===idx){
        // toggle off – reset all
        Plotly.restyle('scatter',{'marker.opacity':[window.scatterPoints.map(()=>0.9)]});
        window._activeLabel=null;
        return;
      }
      const style=window.scatterPoints.map(p=>{
        if(colorMode!=='cluster'){
            return (p[colorMode]||'unknown')===idx?1:0.15;
        }
        return p.cluster===idx?1:0.15;
      });
      Plotly.restyle('scatter',{'marker.opacity':[style]});
      window._activeLabel=idx;
    });
    container.appendChild(span);
  });
}

// Enhanced palette with many more distinct colors for better cluster visualization
function palette(n){
  const base = [
    // Primary vibrant colors
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8',
    '#F7DC6F', '#BB8FCE', '#85C1E9', '#F8C471', '#82E0AA', '#F1948A', '#AED6F1',
    
    // Secondary rich colors
    '#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6', '#1ABC9C', '#E67E22',
    '#34495E', '#95A5A6', '#F1C40F', '#8E44AD', '#16A085', '#D35400', '#2C3E50',
    
    // Tertiary distinctive colors
    '#FF9F43', '#10AC84', '#5F27CD', '#00D2D3', '#FF6348', '#FF9FF3', '#54A0FF',
    '#5F27CD', '#00D2D3', '#FF9F43', '#1DD1A1', '#FD79A8', '#6C5CE7', '#A29BFE',
    
    // Additional vibrant colors
    '#FD79A8', '#FDCB6E', '#6C5CE7', '#74B9FF', '#00B894', '#E17055', '#81ECEC',
    '#FAB1A0', '#00CEC9', '#55A3FF', '#FF7675', '#A29BFE', '#FD79A8', '#FDCB6E',
    
    // More distinctive colors
    '#FF3838', '#FF9500', '#FFDD59', '#3742FA', '#2F3542', '#FF6348', '#1E90FF',
    '#FFB142', '#78E08F', '#60A3BC', '#EE5A6F', '#D63031', '#74B9FF', '#0984E3',
    
    // Extended palette for very large cluster counts
    '#E84393', '#00B894', '#FDCB6E', '#6C5CE7', '#FD79A8', '#00CEC9', '#FF7675',
    '#74B9FF', '#55A3FF', '#A29BFE', '#FD79A8', '#81ECEC', '#FAB1A0', '#E17055'
  ];
  
  const colours = [];
  for (let i = 0; i < n; i++) {
    colours.push(base[i % base.length]);
  }
  return colours;
}

// ---------------------------
// Auspex integration – summarise results
// ---------------------------
document.getElementById('askAuspexBtn').addEventListener('click', () => askAuspex()); // Call without args for general summary

async function askAuspex(idsToSummarize = null, clusterId = null, modelName = null) {
    // If no specific IDs are passed, use selection or all results
    let ids = idsToSummarize;
    if (!ids) {
        if(!window.lastResults || !window.lastResults.length){alert('Run a search first');return;}
        const idsSelected = Array.from(window.selectedUris || []);
        ids = (idsSelected.length ? idsSelected : window.lastResults.map(r => r.id)).slice(0, 100);
        clusterId = null; // Ensure clusterId is null for general summary
    }

    const auspexContent = document.getElementById('auspexContent');
    const exportBtn = document.getElementById('exportSummaryBtn');
    const modalElement = document.getElementById('auspexModal');
    modalElement.dataset.clusterId = clusterId; // Store clusterId for export
    exportBtn.style.display = 'none'; // Hide export button initially

    try{
        // Show progress indicator with rotating fact
        let randomFact = window._newsFacts.length > 0 ? window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)] : 'Querying Auspex...';
        auspexContent.innerHTML = `
            <div class="d-flex justify-content-center align-items-center p-4 my-4">
                <div class="spinner-border text-primary me-3" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div id="auspex-loading-fact" class="fs-6">
                    <strong>Did you know?...</strong> ${randomFact}
                </div>
            </div>`;

        const modalObj=new bootstrap.Modal(document.getElementById('auspexModal'));
        modalObj.show();

        const res=await fetch('/api/vector-summary',{
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({ids:ids, model: modelName}) // Pass model name if provided
        });

        if(!res.ok){throw new Error(await res.text());}
        const json=await res.json();
        const txt=json.response||json.error||'No response';

        // Store summary if it came from a cluster request
        if (clusterId !== null) {
            window._clusterSummaries[clusterId] = txt;
            // Find and store articles for this cluster
            const memberIds = (window._clusterMemberIds || {})[clusterId] || [];
            
            window._clusterArticles[clusterId] = (window.lastResults || []).filter(r => memberIds.includes(r.id))
                .map(r => ({ title: r.metadata.title || 'Untitled', uri: r.metadata.uri }));

            console.log(`[askAuspex] Summary received for clusterId: ${clusterId}`);
            console.log(`[askAuspex] Stored ${window._clusterArticles[clusterId].length} articles for cluster ${clusterId}`);

            // Find the specific cluster list item and add the badge directly
            const patternList = document.getElementById('patternList');
            if (patternList) {
                const summaryButton = patternList.querySelector(`.summarize-cluster-btn[data-cluster-id="${clusterId}"]`);
                const clusterItem = summaryButton?.closest('.list-group-item');
                if (clusterItem) {
                    const titleDiv = clusterItem.querySelector('.fw-bold');
                    if (titleDiv && !titleDiv.querySelector('.badge.bg-success-subtle')) { // Avoid adding duplicate badges
                        titleDiv.insertAdjacentHTML('beforeend', ' <span class="badge bg-success-subtle text-success-emphasis rounded-pill">Summarized</span>');
                    }
                }
            }
        }

        // Use the helper function to render the modal content
        renderAuspexModalContent(txt, window._clusterArticles[clusterId] || [], clusterId);

    }catch(err){
        auspexContent.innerHTML=`<div class="text-danger">${err}</div>`;
        exportBtn.style.display = 'none';
    }
}

function downloadMarkdown(filename, text) {
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

document.getElementById('exportSummaryBtn').addEventListener('click', () => {
    const modalElement = document.getElementById('auspexModal');
    const clusterId = modalElement.dataset.clusterId;
    if (clusterId === null || clusterId === undefined || clusterId === 'null') {
        console.warn('No cluster ID found for export.');
        return;
    }
    const summary = window._clusterSummaries[clusterId] || 'No summary available.';
    const articles = window._clusterArticles[clusterId] || [];

    let markdownContent = `# Cluster ${clusterId} Summary\n\n`;
    markdownContent += `${summary}\n\n`;
    markdownContent += `## Articles\n\n`;
    if (articles.length > 0) {
        articles.forEach(article => {
            markdownContent += `- [${article.title}](${article.uri})\n`;
        });
    } else {
        markdownContent += `No articles found for this cluster.\n`;
    }

    downloadMarkdown(`cluster_${clusterId}_summary.md`, markdownContent);
});

// Event delegation for cluster actions within the patterns tab
document.getElementById('patternsPane').addEventListener('click', async (e) => {
    const filterBtn = e.target.closest('.filter-cluster-btn');
    const summarizeBtn = e.target.closest('.summarize-cluster-btn');

    if (filterBtn) {
        e.preventDefault(); // Prevent potential default button actions
        const clusterId = filterBtn.dataset.clusterId;
        const input = document.getElementById('searchInput');
        let currentQuery = input.value;
        // Remove existing cluster filter (regex handles cluster:n or cluster=n)
        currentQuery = currentQuery.replace(/\bcluster(?:=|:)\d+\b/i, '').trim();
        // Add new cluster filter
        input.value = `${currentQuery} cluster=${clusterId}`.trim();
        runSearch();
        // Optionally switch back to Data Points tab
        bootstrap.Tab.getOrCreateInstance(document.querySelector('button[data-bs-target="#eventsPane"]')).show();
    }

    if (summarizeBtn) {
        const clusterId = summarizeBtn.dataset.clusterId;
        const ids = (window._clusterMemberIds || {})[clusterId] || [];

        // Check if summary already exists
        if (window._clusterSummaries && window._clusterSummaries[clusterId]) {
            const existingSummary = window._clusterSummaries[clusterId];
            const existingArticles = window._clusterArticles[clusterId] || [];
            renderAuspexModalContent(existingSummary, existingArticles, clusterId);
        } else {
            // No summary exists, proceed to fetch
            if (ids.length > 0) {
                askAuspex(ids, clusterId); // Pass IDs and clusterId
            } else {
                alert('Could not find members for this cluster.');
            }
        }
    }
});

// Helper function to render content in the Auspex modal
function renderAuspexModalContent(summaryText, articles = [], clusterId = null) {
   const auspexContent = document.getElementById('auspexContent');
   const exportBtn = document.getElementById('exportSummaryBtn');
   const modalElement = document.getElementById('auspexModal');
   modalElement.dataset.clusterId = clusterId; // Store clusterId for export

   let modalHtml = marked.parse(summaryText || 'No summary available.');

   // Add article list if provided
   if (clusterId !== null && articles && articles.length > 0) {
       modalHtml += '<hr><h6>Cluster Articles</h6><div style="max-height: 200px; overflow-y: auto; font-size: 0.9rem;">';
       articles.forEach(article => {
           modalHtml += `<div><a href="${article.uri}" target="_blank" rel="noopener">${article.title}</a></div>`;
       });
       modalHtml += '</div>';
       exportBtn.style.display = 'block'; // Show export button
   } else {
       exportBtn.style.display = 'none'; // Hide if not a cluster or no articles
   }

   auspexContent.innerHTML = modalHtml;
   // Ensure the modal is shown if not already
   const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
   modalInstance.show();
}

// Add listener to handle focus after modal closes (Accessibility fix)
document.getElementById('auspexModal').addEventListener('hidden.bs.modal', function () {
   // Return focus to a sensible element, e.g., the search input
   document.getElementById('searchInput')?.focus();
});

// Delete article from vector database
async function deleteArticleFromVector(articleId) {
    console.log('🔍 DELETE REQUEST DEBUG:');
    console.log('ArticleId passed to delete function:', articleId);
    console.log('ArticleId length:', articleId.length);
    console.log('ArticleId type:', typeof articleId);
    
    if (!confirm('Are you sure you want to delete this article from the vector database? This action cannot be undone.')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/vector-delete/${encodeURIComponent(articleId)}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            const error = await response.json();
            console.error('❌ DELETE FAILED:');
            console.error('Status:', response.status);
            console.error('Error details:', error);
            throw new Error(error.detail || 'Failed to delete article');
        }
        
        const result = await response.json();
        console.log('✅ Delete result:', result);
        
        // Remove the article from the current results
        window.lastResults = window.lastResults.filter(r => r.id !== articleId);
        
        // Remove from selected URIs if it was selected
        selectedUris.delete(articleId);
        updateActionButtons();
        
        // Re-render the current page
        currentIndex = 0;
        renderNextPage();
        
        // Update counts
        if (document.getElementById('totalCount')) {
            document.getElementById('totalCount').textContent = window.lastResults.length;
        }
        if (document.getElementById('dataPointsCount')) {
            document.getElementById('dataPointsCount').textContent = window.lastResults.length;
        }
        
        // Show success message
        const Toast = Swal ? Swal.mixin({
            toast: true,
            position: 'top-end',
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true
        }) : null;
        
        if (Toast) {
            Toast.fire({
                icon: 'success',
                title: 'Article deleted successfully'
            });
        } else {
            // Fallback if SweetAlert is not available
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-success alert-dismissible fade show position-fixed';
            alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            alertDiv.innerHTML = `
                <i class="fas fa-check-circle me-2"></i>Article deleted successfully
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.body.appendChild(alertDiv);
            setTimeout(() => alertDiv.remove(), 3000);
        }
        
    } catch (error) {
        console.error('❌ Error deleting article:', error);
        alert(`Error deleting article: ${error.message}`);
    }
}

// Add debug function to inspect search results
function debugSearchResults() {
    if (!window.lastResults || window.lastResults.length === 0) {
        console.log('No search results to debug');
        return;
    }
    
    console.log('🔍 SEARCH RESULTS DEBUG:');
    console.log('Total results:', window.lastResults.length);
    
    window.lastResults.slice(0, 5).forEach((result, index) => {
        console.log(`\n--- Result ${index + 1} ---`);
        console.log('ID:', result.id);
        console.log('ID length:', result.id ? result.id.length : 'undefined');
        console.log('ID type:', typeof result.id);
        console.log('Title:', result.metadata?.title || 'No title');
        console.log('URI in metadata:', result.metadata?.uri || 'No URI in metadata');
        console.log('ID === metadata.uri:', result.id === result.metadata?.uri);
        
        // Check for any truncation or encoding issues
        if (result.id && result.id.includes('…')) {
            console.warn('⚠️ ID contains ellipsis - possible truncation!');
        }
        if (result.id && result.metadata?.uri && result.id !== result.metadata?.uri) {
            console.warn('⚠️ ID mismatch: result.id !== metadata.uri');
        }
    });
    
    // Check what's actually in the vector database
    fetch('/api/vector-debug')
        .then(response => response.json())
        .then(vectorData => {
            console.log('\n🔍 VECTOR DATABASE DEBUG:');
            console.log('Vector DB data:', vectorData);
            
            if (vectorData.sample_articles) {
                console.log('Sample vector DB IDs:');
                vectorData.sample_articles.slice(0, 5).forEach((article, index) => {
                    console.log(`Vector ${index + 1}: ${article.id}`);
                });
                
                // Compare search results with vector DB
                const searchIds = window.lastResults.slice(0, 5).map(r => r.id);
                const vectorIds = vectorData.sample_articles.slice(0, 5).map(a => a.id);
                
                console.log('\n🔍 ID COMPARISON:');
                console.log('Search result IDs:', searchIds);
                console.log('Vector DB IDs:', vectorIds);
                
                const matches = searchIds.filter(searchId => 
                    vectorIds.some(vectorId => vectorId === searchId)
                );
                console.log('Exact matches:', matches.length);
                
                if (matches.length === 0) {
                    console.warn('⚠️ NO EXACT MATCHES FOUND BETWEEN SEARCH AND VECTOR DB!');
                    console.log('This explains why delete fails - ID format mismatch');
                }
            }
        })
        .catch(error => {
            console.error('Error fetching vector debug info:', error);
        });
}
</script>
{% endblock %} 
