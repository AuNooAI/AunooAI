{% extends 'base.html' %}
{% block title %}Topic Dashboard{% endblock %}

{% block content %}
{# Include Chart.js CDN #}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
{# Include TagCloud.js CDN - use direct TagCloud script #}
<script src="https://www.goat1000.com/tagcanvas.min.js"></script>
{# Add D3 for word cloud visualization - Keep for other potential D3 uses #}
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
{# <script src="https://cdn.jsdelivr.net/npm/d3-cloud@1.2.7/build/d3.layout.cloud.min.js"></script> #} {# Commented out D3 Cloud #}
{# Add WordCloud2.js CDN #}
<script src="https://cdn.jsdelivr.net/npm/wordcloud@1.2.2/src/wordcloud2.js"></script>

{# Add Bootstrap Icons for podcast player #}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
{# Add marked.js for markdown rendering #}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<style>
    /* Basic layout styling */
    .dashboard-container-grid {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        padding: 1rem 1.5rem;
        box-sizing: border-box;
        min-height: calc(100vh - 80px);
        max-width: 100%;
        overflow-y: auto;
        background-color: #f4f7f9; /* Lighter background for the page */
    }
    .dashboard-header {
        /* background-color: #fff; */ /* Original */
        background-color: #ffffff; /* Keep it white but add other enhancements */
        padding: 1.25rem 1.75rem; /* Slightly increased padding */
        border-radius: 8px;
        /* box-shadow: 0 2px 4px rgba(0,0,0,0.05); */ /* Original */
        box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* More pronounced shadow */
        width: 100%;
        box-sizing: border-box;
        border-bottom: 3px solid var(--bs-primary); /* Accent border */
        margin-bottom: 1rem; /* Ensure some space below header before main content */
    }
    .dashboard-sidebar {
        background-color: #f8f9fa; 
        padding: 1.5rem;
        border-radius: 8px;
        height: 100%; 
        display: none; /* Hide the sidebar column entirely */
    }
    .dashboard-main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        width: 100%;
        box-sizing: border-box;
    }
    .dashboard-section {
        background-color: #fff;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
    }
    .dashboard-section:last-child {
        margin-bottom: 0;
    }
    .chart-container {
        height: 280px; /* Slightly smaller charts */
        position: relative;
        width: 100%;
    }
    #articles-list {
         max-height: 500px; /* Adjust max height */
         overflow-y: auto;
         border-top: 1px solid #dee2e6;
         border-bottom: 1px solid #dee2e6;
         width: 100%;
         box-sizing: border-box;
    }
     #articles-list .list-group-item {
        border-left: 0;
        border-right: 0;
        padding-left: 0;
        padding-right: 0;
        width: 100%;
        box-sizing: border-box;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }
     #articles-list .list-group-item:first-child {
        border-top: 0;
    }
     #articles-list .list-group-item:last-child {
        border-bottom: 0;
    }
    #outliers-list {
        max-height: 250px; /* Adjust height */
        overflow-y: auto;
    }
    .loading-indicator {
        text-align: center;
        padding: 2rem;
        color: #6c757d;
    }
    .sentiment-badge {
        font-size: 0.75em;
        padding: 0.25em 0.5em;
        margin-left: 0.5em;
        vertical-align: middle;
    }
    .sentiment-positive { background-color: #d1e7dd; color: #0a5132; border: 1px solid #a3cfbb; }
    .sentiment-negative { background-color: #f8d7da; color: #842029; border: 1px solid #f1aeb5; }
    .sentiment-neutral { background-color: #e2e3e5; color: #41464b; border: 1px solid #c3c6ca; }
    .sentiment-unknown { background-color: #f8f9fa; color: #6c757d; border: 1px solid #dee2e6; }
    .ticker-wrap {
        width: 100%;
        overflow: hidden;
        background: transparent; 
        padding: 8px 0; 
        border-radius: 6px; 
        /* border: 1px solid #ced4da; */ /* Kept border for definition, can be removed if desired - NOW REMOVED */
        margin-top: 0.75rem; 
    }
    .ticker-move {
        display: inline-block;
        white-space: nowrap;
        padding-left: 100%;
        animation: ticker 60s linear infinite; 
    }
    .ticker-item {
        display: inline-block;
        padding: 0 1.5rem; 
        color: #343a40; /* Darker base text color for contrast */
        font-size: 0.9rem; 
        text-shadow: 0px 0px 1px rgba(255,255,255,0.5); /* Subtle white text shadow for pop */
    }
    /* Removed .ticker-item strong as it's replaced by .ticker-prefix logic */
    
    .ticker-prefix {
        /* font-weight: bold; */
        /* color: var(--bs-primary); */ /* Original */
        background-color: var(--bs-primary); /* Primary color background */
        color: #fff; /* White text */
        padding: 3px 8px; /* Padding to make it look like a badge */
        border-radius: 4px; /* Rounded corners for the badge */
        font-weight: 500;
        font-size: 0.85rem; /* Slightly smaller font for the badge text */
        margin-right: 0.75em;
        text-transform: uppercase; /* Uppercase LATEST */
    }
    .ticker-item a {
        color: #0056b3; 
        text-decoration: none;
        font-weight: 500; 
        padding: 2px 6px; 
        border: 1px solid #ff7eb9; /* NEW Pink */
        border-radius: 4px; 
        background-color: rgba(255, 126, 185, 0.07); /* NEW Light Pink fill */
        transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, color 0.2s ease-in-out;
    }
    .ticker-item a:hover {
        color: #003875; 
        text-decoration: underline;
        border-color: #ff55a5; /* NEW Saturated Pink on hover */
        background-color: rgba(255, 85, 165, 0.12); /* NEW More saturated light pink fill on hover */
    }
    .ticker-separator {
        color: #868e96; /* Medium gray for separator */
        margin: 0 0.75em; /* Spacing around separator */
        font-weight: bold;
    }

    @keyframes ticker {
        0% { transform: translate3d(0, 0, 0); }
        100% { transform: translate3d(-100%, 0, 0); }
    }
    .ticker-wrap:hover .ticker-move {
        animation-play-state: paused; /* Pause animation on hover */
    }

    /* Add styles for the trend insights container */
    #trend-insights-flex-container {
        gap: 1rem; 
        width: 100%;
        box-sizing: border-box;
        /* display: flex; flex-wrap: wrap; align-items: stretch; */ /* Ensure these are set if overridden elsewhere */
    }
    
    /* Add styles for the insights container */
    .insight-card {
        word-wrap: break-word;
        overflow-wrap: break-word;
        max-width: 100%;
    }

    /* Styles for horizontally aligned insight cards */
    .insight-item-card {
        border: 1px solid #e0e0e0; /* Slightly more visible border */
        border-radius: 6px; /* Consistent rounded corners */
        padding: 1.25rem; /* Standardized padding */
        margin-bottom: 1rem; 
        flex: 1 1 320px; /* Adjusted flex-basis for better wrapping */
        box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Softer shadow */
        display: flex; 
        flex-direction: column; 
        background-color: #fff; /* Ensure cards have a white background */
    }
    .insight-item-card h6 {
        font-size: 1rem; /* Slightly larger heading */
        color: var(--bs-primary);
    }
    .insight-item-card p {
        font-size: 0.9rem;
        flex-grow: 1; /* Allow paragraph to take available space */
        max-height: 200px; /* Maximum height before scrolling */
        overflow-y: auto;  /* Enable vertical scroll if content exceeds max-height */
        word-wrap: break-word; /* Ensure long words break */
        margin-bottom: 0; /* Adjust as needed */
    }

    /* Ensure the flex container for trend insights has a gap */
    #trend-insights-flex-container {
        gap: 1rem; /* Add gap between insight cards */
        width: 100%;
        box-sizing: border-box;
    }

    /* Styles for horizontally aligned highlight cards */
    #key-articles-list {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 1rem; /* Space between highlight cards */
        justify-content: flex-start; /* Align cards to the start */
        align-items: stretch; /* Make cards in a row equal height if needed */
    }
    /* Adjustments for highlight cards within the flex layout */
    #key-articles-list .card {
        flex: 0 0 calc(33.333% - 1rem); /* Example: 3 cards per row, considering the gap */
        /* Adjust calc if you want different number of cards per row, e.g., 50% - 0.5rem for 2 cards */
        min-width: 280px; /* Minimum width before wrapping */
        margin-bottom: 0 !important; /* Remove original margin-bottom if using gap */
    }
    
    /* Add style to ensure markdown renders properly in insight cards */
    .insight-content {
        width: 100%;
    }
    .insight-content ul, .insight-content ol {
        padding-left: 1.5rem;
    }
    .insight-content p {
        margin-bottom: 0.5rem;
    }

    /* Podcast wave visualizer styles */
    .podcast-visualizer {
        display: flex;
        align-items: flex-end; /* Align bars to the bottom */
        justify-content: center; /* Center bars */
        height: 20px; /* Height of the visualizer area */
        gap: 3px; /* Space between bars */
        margin-top: 5px; /* Space above visualizer */
        visibility: hidden; /* Hidden by default */
        opacity: 0;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }
    .podcast-visualizer.playing {
        visibility: visible;
        opacity: 1;
    }
    .podcast-visualizer span {
        width: 4px; /* Width of each bar */
        background-color: var(--bs-primary); /* Use primary color */
        display: inline-block;
        animation: wavePulse 0.8s infinite ease-in-out alternate;
    }
    .podcast-visualizer span:nth-child(1) { height: 10px; animation-delay: 0s; }
    .podcast-visualizer span:nth-child(2) { height: 15px; animation-delay: 0.2s; }
    .podcast-visualizer span:nth-child(3) { height: 12px; animation-delay: 0.4s; }

    @keyframes wavePulse {
        0% { transform: scaleY(0.3); opacity: 0.7; }
        100% { transform: scaleY(1); opacity: 1; }
    }

    /* Word Cloud styles */
    .word-cloud-fallback {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
    .word-cloud-fallback span {
        padding: 5px 10px;
        background-color: #f0f0f0;
        border-radius: 15px;
        font-size: 14px;
        color: #333;
    }
    .chart-controls {
        text-align: right;
        margin-bottom: 0.5rem;
    }
    .chart-controls label {
        margin-right: 0.5rem;
        font-size: 0.85rem;
        color: #6c757d;
    }
    .chart-controls .form-select-sm {
        display: inline-block;
        width: auto;
        vertical-align: middle;
    }
    #radarChartContainer {
        height: 400px; /* Or your desired height */
        position: relative;
        width: 100%;
    }

    /* Improved layout for Category Insights - Using Grid */
    #category-insights-flex-container {
        display: grid;
        /* grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); */ /* Responsive columns */
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* auto-fit is often better */
        gap: 1.25rem; /* Consistent gap */
        width: 100%;
        box-sizing: border-box;
    }
    /* Ensure insight cards within the grid take full height of their row if desired, or behave as blocks */
    #category-insights-flex-container .insight-item-card {
        /* flex-basis will be ignored by grid, but keep other styles */
         margin-bottom: 0; /* Gap is handled by grid, remove margin if it causes double spacing */
    }

    /* Styles for Previous Briefings list improvements */
    #previous-podcasts-list .list-group-item {
        transition: background-color 0.2s ease-in-out;
        /* display: flex;
        justify-content: space-between;
        align-items: center; */ /* Keep flex for internal alignment if needed */
    }
    #previous-podcasts-list .list-group-item:hover {
        background-color: #f8f9fa; /* Light hover effect */
    }
    .podcast-actions a {
        color: #6c757d; /* Muted color for icons */
        text-decoration: none;
        margin-left: 0.5rem;
        font-size: 0.9rem; /* Slightly smaller icon actions */
    }
    .podcast-actions a:hover {
        color: var(--bs-primary); /* Primary color on hover */
    }

    /* New styles for prominent podcast panel */
    #podcast-briefing-section {
        position: relative; /* For positioning overlay elements if needed */
        padding: 0; /* Remove padding if image is to fill */
    }
    .podcast-hero-image {
        width: 100%;
        max-height: 300px; /* Adjust as needed */
        object-fit: cover;
        border-radius: 8px 8px 0 0; /* Rounded top corners if section has rounded bottom */
        display: block;
    }
    .podcast-content-overlay {
        /* position: absolute; */ /* If you want to overlay on image */
        /* bottom: 0; */
        /* left: 0; */
        /* width: 100%; */
        background-color: rgba(255, 255, 255, 0.95); /* Semi-transparent white for readability if overlaying */
        padding: 1rem; /* Add padding back for content */
        border-radius: 0 0 8px 8px; /* If image is top part */
    }
    #latest-podcast-section .card { /* Ensure card within has no extra margin if panel padding is 0 */
        margin-bottom: 0 !important;
    }


    /* New styles for "Top Stories" (formerly Highlights) */
    #highlights-section { /* Keep ID for now, but treat as Top Stories */
        /* background-color: #f8f9fa; */ /* Optional: different background */
        /* padding: 1rem; */
    }
    #key-articles-list {
        display: flex;
        flex-direction: column; /* Stack stories vertically */
        gap: 0; /* Remove gap, use borders for separation */
    }
    .top-story-item {
        padding: 0.75rem 0;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        flex-direction: column;
    }
    .top-story-item:last-child {
        border-bottom: none;
    }
    .top-story-item .category-badge {
        font-size: 0.7rem;
        padding: 0.2em 0.5em;
        margin-bottom: 0.3rem;
        align-self: flex-start; /* Badge at the start of the line */
        text-transform: uppercase;
        font-weight: bold;
    }
    .top-story-item h6 {
        font-size: 0.95rem;
        margin-bottom: 0.25rem;
    }
    .top-story-item h6 a {
        text-decoration: none;
        color: #212529;
    }
    .top-story-item h6 a:hover {
        color: var(--bs-primary);
    }
    .top-story-item .summary {
        font-size: 0.85rem;
        color: #6c757d;
        margin-bottom: 0.3rem;
        line-height: 1.4;
    }
    .top-story-item .timestamp {
        font-size: 0.75rem;
        color: #6c757d;
        margin-bottom: 0.3rem;
    }
    .top-story-item .read-more {
        font-size: 0.8rem;
        font-weight: bold;
        color: var(--bs-primary);
        text-decoration: none;
        align-self: flex-start;
    }
    .top-story-item .read-more:hover {
        text-decoration: underline;
    }

    /* Styles for Top Story hover details */
    .top-story-item {
        position: relative; /* Needed for absolute positioning of details */
    }
    .top-story-hover-details {
        display: none;
        position: fixed; /* Changed to fixed positioning */
        width: 300px; /* Fixed width */
        background-color: #ffffff;
        border: 1px solid #ced4da;
        border-radius: 0.25rem;
        padding: 1rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        z-index: 1050; /* Even higher z-index */
        font-size: 0.85rem;
        line-height: 1.5;
        max-height: 500px; /* Maximum height to prevent overflow */
        overflow-y: auto; /* Add scrolling if needed */
    }
    .top-story-hover-details h6 {
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        color: var(--bs-primary);
        font-weight: bold;
    }
    .top-story-hover-details p {
        margin-bottom: 0.5rem;
    }
    .top-story-hover-details .meta-item {
        display: block; /* Each meta item on new line */
        margin-bottom: 0.25rem;
    }
    .top-story-hover-details .meta-item strong {
        color: #343a40;
    }
    
    /* Arrow pointing to the item */
    .tooltip-arrow {
        position: absolute;
        width: 0;
        height: 0;
        border-style: solid;
    }
    
    /* Media query for mobile/smaller screens */
    @media (max-width: 768px) {
        .top-story-hover-details {
            width: 90%; /* Almost full width on small screens */
            max-width: 300px;
        }
    }

    /* Styles for button-like tabs */
    .nav-tabs.nav-fill .nav-link {
        background-color: #e9ecef;
        border: 1px solid #dee2e6;
        color: #495057;
        border-radius: 0.25rem; /* Rounded corners */
        margin: 0 2px; /* Small gap between tabs */
        transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out, border-color 0.15s ease-in-out;
    }
    .nav-tabs.nav-fill .nav-link.active {
        background-color: var(--bs-primary);
        color: #fff;
        border-color: var(--bs-primary);
    }
    .nav-tabs.nav-fill .nav-link:hover:not(.active) {
        background-color: #ced4da;
        border-color: #adb5bd;
    }

</style>

<div class="container-fluid dashboard-container-grid">

    {# Header Section (Topic Selector, Date Range) #}
    <div class="dashboard-header">
        {# Combined Row for Title, Topic Selector, and Date Range #}
        <div class="row align-items-center gy-2 mb-3"> 
            {# Column for Title #}
            <div class="col-md-auto">
                <h4 id="dashboard-title" class="text-primary fw-bold mb-0">Topic Dashboard</h4> 
            </div>
            
            {# Column for Topic Selector - push to the right #}
            <div class="col-md ms-md-auto" style="max-width: 300px;"> 
                 <select id="topicSelector" class="form-select form-select-sm">
                    <option value="" selected disabled>Select a Topic...</option>
                    {% for topic in topics %}
                    <option value="{{ topic }}">{{ topic }}</option>
                    {% endfor %}
                </select>
            </div>
        </div>
        
        {# Row for Date Range Controls (now below the title/topic row) #}
        <div class="row align-items-center gy-2">
            <div class="col-auto">
                <label class="form-label mb-0 small">Date Range:</label>
             </div>
             <div class="col-auto btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="1">Today</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="7">Week</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn active" data-days="30">Month</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="90">Quarter</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="365">Year</button>
            </div>
            {# Hidden original date inputs - kept for potential future re-enablement via JS #}
            <div class="col-auto" style="display: none;">
                 <input type="date" id="startDateInput" class="form-control form-control-sm" style="width: auto;">
            </div>
             <div class="col-auto px-0" style="display: none;">-</div>
            <div class="col-auto" style="display: none;">
                 <input type="date" id="endDateInput" class="form-control form-control-sm" style="width: auto;">
            </div>
            <div class="col-auto" style="display: none;">
                <button id="applyDateRangeBtn" class="btn btn-sm btn-primary">Apply</button>
            </div>
        </div>
        {# Ticker used to be here - MOVED #}
        {# <div id="newsTicker" class="ticker-wrap mt-2" style="display: none;"> 
            <div class="ticker-move"></div>
        </div> #}
    </div>

    {# News Ticker Panel - NEW PLACEMENT #}
    <div class="dashboard-section" id="news-ticker-section" style="padding: 0.5rem 0;"> {# Reduced padding for ticker panel #}
        <div id="newsTicker" class="ticker-wrap" style="display: none; margin-top: 0;"> 
            <div class="ticker-move"></div>
        </div>
    </div>

    {# Sidebar - Kept in HTML for now but hidden with CSS, content moved to main #}
    <div class="dashboard-sidebar" style="display: none;">
        {# Content that was here (like Highlights) has been moved to dashboard-main #}
        {# Example: Old highlights structure (now moved)
        <h5 class="mb-3">Highlights</h5> 
        <div id="key-articles-list-sidebar-version" class="mb-4 flex-grow-1" style="overflow-y: auto;">
             <div class="loading-indicator">Loading highlights...</div>
        </div> 
        #}
    </div>

    {# Main Content Area (Single Column Flow) #}
    <div class="dashboard-main">
        {# AI Trends Today's Briefing - Modified for Prominent Image #}
        <div class="dashboard-section" id="podcast-briefing-section">
            <img src="/static/trend_daily_briefing.gif" alt="AI Trends Daily Briefing" class="podcast-hero-image">
            <div class="podcast-content-overlay">
                <h5 class="mb-3 mt-2"><i class="bi bi-mic-fill me-2"></i>AI Trends Today's Briefing</h5>
                <div id="latest-podcast-section" class="mb-3">
                    <div class="loading-indicator">Loading today's briefing...</div>
                </div>
                <div id="podcast-visualizer-latest" class="podcast-visualizer">
                    <span></span><span></span><span></span>
                </div>
                <h6 class="mb-2 small text-muted">Previous Briefings</h6>
                <div id="previous-podcasts-list" class="list-group list-group-flush small" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px;">
                    <div class="loading-indicator">Loading previous briefings...</div>
                </div>
            </div>
        </div>

        {# Highlights Section (Top Stories) - MOVED UP #}
        <div class="dashboard-section" id="highlights-section"> 
            <h5 class="mb-3">Top Stories</h5> {# Renamed from Highlights #}
            <div id="key-articles-list" class="mb-0">
                 <div class="loading-indicator">Loading top stories...</div>
            </div>
        </div>

        {# Generated Insights (Tabbed) - NOW AFTER TOP STORIES #}
        <div class="dashboard-section" id="generated-insights-tab-section">
            <h5 class="mb-3">Generated Insights</h5>
            <ul class="nav nav-tabs nav-fill nav-sm mb-3" id="insightsTab" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="trend-insights-tab" data-bs-toggle="tab" data-bs-target="#trend-insights-content" type="button" role="tab" aria-controls="trend-insights-content" aria-selected="true">Trend Insights</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="article-insights-tab" data-bs-toggle="tab" data-bs-target="#article-insights-content" type="button" role="tab" aria-controls="article-insights-content" aria-selected="false">Article Insights</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="category-insights-tab" data-bs-toggle="tab" data-bs-target="#category-insights-content" type="button" role="tab" aria-controls="category-insights-content" aria-selected="false">Category Insights</button>
                </li>
            </ul>
            <div class="tab-content" id="insightsTabContent">
                <div class="tab-pane fade show active" id="trend-insights-content" role="tabpanel" aria-labelledby="trend-insights-tab">
                    {# The .d-flex container should always be present. Loading/content goes inside it. #}
                    <div class="d-flex flex-row flex-wrap justify-content-start align-items-stretch" id="trend-insights-flex-container">
                        <div class="loading-indicator w-100 text-center">Loading trend insights...</div>
                    </div>
                </div>
                <div class="tab-pane fade" id="article-insights-content" role="tabpanel" aria-labelledby="article-insights-tab">
                    <div class="d-flex flex-row flex-wrap justify-content-start align-items-stretch" id="article-insights-flex-container">
                        <div class="text-muted p-2 small w-100 text-center">Article-specific insights will be shown here. (Coming soon)</div>
                    </div>
                </div>
                <div class="tab-pane fade" id="category-insights-content" role="tabpanel" aria-labelledby="category-insights-tab">
                    {# Use the grid container for category insights #}
                    <div id="category-insights-flex-container"> 
                        <div class="text-muted p-2 small w-100 text-center">Category-based insights will be shown here.</div>
                    </div>
                </div>
            </div>
        </div>

        {# Trends (Tabbed) #}
        <div class="dashboard-section">
            <h5 class="mb-3">Trends</h5>
            <ul class="nav nav-tabs nav-fill nav-sm mb-3" id="trendsTab" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="statistical-analysis-tab" data-bs-toggle="tab" data-bs-target="#statistical-analysis-content" type="button" role="tab" aria-controls="statistical-analysis-content" aria-selected="true">Statistical Analysis</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="vector-analysis-tab" data-bs-toggle="tab" data-bs-target="#vector-analysis-content" type="button" role="tab" aria-controls="vector-analysis-content" aria-selected="false">Lexical Analysis</button> {# Renamed from Vector Analysis #}
                </li>
            </ul>
            <div class="tab-content" id="trendsTabContent">
                <div class="tab-pane fade show active" id="statistical-analysis-content" role="tabpanel" aria-labelledby="statistical-analysis-tab">
                    <div class="row">
                        <div class="col-md-6 mb-4">
                            <div class="d-flex justify-content-between align-items-center">
                                <h6>Volume Over Time</h6>
                                <div class="chart-controls">
                                    <label for="volumeStackBy">Stack by:</label>
                                    <select id="volumeStackBy" class="form-select form-select-sm">
                                        <option value="category" selected>Category</option>
                                        <option value="sentiment">Sentiment</option>
                                    </select>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="volumeChart"></canvas>
                            </div>
                            <div id="volume-loading" class="loading-indicator d-none">Loading...</div>
                        </div>
                        <div class="col-md-6 mb-4">
                            <h6>Sentiment Over Time</h6>
                            <div class="chart-container">
                                <canvas id="sentimentChart"></canvas>
                            </div>
                            <div id="sentiment-loading" class="loading-indicator d-none">Loading...</div>
                        </div>
                    </div>
                    {# New Row for Radar Chart #}
                    <div class="row mt-4"> {# Removed mb-4 from this row to reduce potential bottom space if it's the last one #}
                        <div class="col-md-12"> {# Removed mb-4 from this col as well #}
                            <h6>Distribution by Future Signal, Sentiment & TTI</h6>
                             <div id="radarChartContainer" class="chart-container">
                                <canvas id="radarChart"></canvas>
                            </div>
                            <div id="radar-loading" class="loading-indicator d-none">Loading Radar Chart...</div>
                        </div>
                    </div>
                </div>
                <div class="tab-pane fade" id="vector-analysis-content" role="tabpanel" aria-labelledby="vector-analysis-tab">
                    <div class="row">
                        <div class="col-md-6 mb-4">
                            <h6>Top Tags</h6>
                            <div id="tagsCloudContainer" style="height: 280px; width: 100%; border: 1px solid #eee; border-radius: 4px;">
                                 <div id="tags-loading" class="loading-indicator">Loading Tags...</div>
                            </div>
                            <div id="topTagsList" class="mt-2" style="max-height: 150px; overflow-y: auto;"></div>
                        </div>
                        <div class="col-md-6 mb-4">
                            <h6>Word Frequency</h6>
                            <div id="wordCloudContainer" style="height: 280px; width: 100%; border: 1px solid #eee; border-radius: 4px;">
                                <div id="wordcloud-loading" class="loading-indicator">Loading Word Cloud...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        {# Articles Section - Remains as is, but now follows new sections #}
        <div class="dashboard-section">
            <div class="d-flex justify-content-between align-items-center">
                <h5 id="articles-section-title">Articles</h5>
                <button id="reset-article-filter-btn" class="btn btn-sm btn-outline-secondary" style="display: none;">Show All Articles</button>
            </div>
            <div id="articles-list" class="list-group list-group-flush mt-2">
                <div class="loading-indicator">Select a topic to view articles.</div>
            </div>
            <nav aria-label="Article navigation">
                <ul class="pagination pagination-sm justify-content-center mt-3" id="articles-pagination">
                    {# Pagination controls will be added by JS #}
                </ul>
            </nav>
        </div>
    </div>

</div> {# End dashboard-container-grid #}

<script>
    // Chart instances - declare globally to manage updates/destruction
    let volumeChartInstance = null;
    let sentimentChartInstance = null;
    let radarChartInstance = null; // Added for radar chart
    let tagCloudInstance = null;
    let currentPage = 1;
    const articlesPerPage = 10;
    let currentStartDate = null; // Store current date range state
    let currentEndDate = null;
    let tickerIntervalId = null; // ID for the ticker polling interval
    const TICKER_UPDATE_INTERVAL = 60000; // Update ticker every 60 seconds
    const DEFAULT_TOPIC_KEY = 'dashboardDefaultTopic'; // localStorage key

    // API Fetch Functions
    async function fetchData(url) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Fetch error:', error);
            // Display error to user? 
            return null;
        }
    }

    // --- Rendering Functions ---

    function renderSummaryMetrics(data) {
        const container = document.getElementById('topic-summary-metrics');
        if (!data) {
            container.innerHTML = '<div class="alert alert-warning">Could not load summary metrics.</div>';
            return;
        }
        container.innerHTML = `
            <div class="col-md-3 col-6 mb-2"><strong>Total Articles:</strong><br>${data.total_articles}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Last 24h:</strong><br>${data.new_articles_last_24h}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Last 7d:</strong><br>${data.new_articles_last_7d}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Dominant Source (30d):</strong><br>${data.dominant_news_source || 'N/A'}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Frequent TTI (30d):</strong><br>${data.most_frequent_time_to_impact || 'N/A'}</div>
            {# Add placeholders for future metrics if needed #}
        `;
    }

    function getSentimentBadge(sentiment, explanation) {
        if (!sentiment) return '';
        const sentimentLower = sentiment.toLowerCase();
        let badgeClass = 'sentiment-unknown';
        if (sentimentLower === 'positive') badgeClass = 'sentiment-positive';
        else if (sentimentLower === 'negative') badgeClass = 'sentiment-negative';
        else if (sentimentLower === 'neutral') badgeClass = 'sentiment-neutral';
        
        const displaySentiment = sentiment.charAt(0).toUpperCase() + sentiment.slice(1);
        const tooltipText = explanation ? ` title="${explanation.replace(/"/g, '&quot;')}"` : '';
        
        return `<span class="badge rounded-pill sentiment-badge ${badgeClass}" data-bs-toggle="tooltip" data-bs-placement="top"${tooltipText}>${displaySentiment}</span>`;
    }

    function renderArticles(data) {
        const listContainer = document.getElementById('articles-list');
        const paginationContainer = document.getElementById('articles-pagination');
        listContainer.innerHTML = ''; // Clear previous articles or loading indicator
        paginationContainer.innerHTML = ''; // Clear pagination

        if (!data || !data.items || data.items.length === 0) {
            listContainer.innerHTML = '<div class="list-group-item text-muted">No articles found for this topic.</div>';
            return;
        }

        data.items.forEach(article => {
            const articleItem = document.createElement('div');
            articleItem.className = 'list-group-item';
            const pubDate = article.publication_date ? new Date(article.publication_date).toLocaleDateString() : 'N/A';
            const tagsHtml = article.tags && article.tags.length > 0 
                ? article.tags.map(tag => `<span class="badge bg-secondary me-1">${tag}</span>`).join('') 
                : '';
            const sentimentBadgeHtml = getSentimentBadge(article.sentiment, article.sentiment_explanation);
            
            articleItem.innerHTML = `
                <div class="d-flex w-100 justify-content-between">
                    <h6 class="mb-1"><a href="${article.uri}" target="_blank" rel="noopener">${article.title || 'Untitled'}</a> ${sentimentBadgeHtml}</h6>
                    <small>${pubDate}</small>
                </div>
                <p class="mb-1"><small class="text-muted">${article.news_source || 'Unknown Source'}</small></p>
                <p class="mb-1 small">${(article.summary || 'No summary available.').substring(0, 150)}...</p>
                <div>${tagsHtml}</div>
            `;
            listContainer.appendChild(articleItem);
        });

        // Initialize Bootstrap tooltips after rendering articles
        const tooltipTriggerList = [].slice.call(listContainer.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        });
        
        renderPagination(data.total_pages, data.page);
    }
    
    function renderPagination(totalPages, currentPage) {
        const paginationContainer = document.getElementById('articles-pagination');
        paginationContainer.innerHTML = ''; // Clear previous pagination

        if (totalPages <= 1) return; // No pagination needed for 1 or 0 pages

        // Previous Button
        const prevLi = document.createElement('li');
        prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
        prevLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage - 1}">Previous</a>`;
        paginationContainer.appendChild(prevLi);

        // Page Number Buttons (simplified version)
        // Show current page and +/- 1-2 pages around it
        const startPage = Math.max(1, currentPage - 2);
        const endPage = Math.min(totalPages, currentPage + 2);

        if (startPage > 1) {
             const firstLi = document.createElement('li');
             firstLi.className = 'page-item';
             firstLi.innerHTML = `<a class="page-link" href="#" data-page="1">1</a>`;
             paginationContainer.appendChild(firstLi);
             if (startPage > 2) {
                 const ellipsisLi = document.createElement('li');
                 ellipsisLi.className = 'page-item disabled';
                 ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
                 paginationContainer.appendChild(ellipsisLi);
             }
        }

        for (let i = startPage; i <= endPage; i++) {
            const pageLi = document.createElement('li');
            pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
            pageLi.innerHTML = `<a class="page-link" href="#" data-page="${i}">${i}</a>`;
            paginationContainer.appendChild(pageLi);
        }
        
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                const ellipsisLi = document.createElement('li');
                ellipsisLi.className = 'page-item disabled';
                ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
                paginationContainer.appendChild(ellipsisLi);
            }
             const lastLi = document.createElement('li');
             lastLi.className = 'page-item';
             lastLi.innerHTML = `<a class="page-link" href="#" data-page="${totalPages}">${totalPages}</a>`;
             paginationContainer.appendChild(lastLi);
        }

        // Next Button
        const nextLi = document.createElement('li');
        nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
        nextLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage + 1}">Next</a>`;
        paginationContainer.appendChild(nextLi);

        // Add event listeners to pagination links
        paginationContainer.querySelectorAll('.page-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const page = parseInt(e.target.dataset.page);
                if (page && page !== currentPage) {
                    const selectedTopic = document.getElementById('topicSelector').value;
                    loadArticles(selectedTopic, page);
                }
            });
        });
    }

    function renderVolumeChart(data, stackBy = 'category') {
        const ctx = document.getElementById('volumeChart').getContext('2d');
        document.getElementById('volume-loading').classList.add('d-none');
        if (volumeChartInstance) volumeChartInstance.destroy();
        
        if (!data || data.length === 0) {
            document.getElementById('volumeChart').style.display = 'none';
            document.getElementById('volume-loading').textContent = 'No volume data available.';
            document.getElementById('volume-loading').classList.remove('d-none');
            return;
        }
        document.getElementById('volumeChart').style.display = 'block';

        const dates = data.map(d => d.date);
        const stackValues = new Set(); // To get all unique categories or sentiments
        data.forEach(d => {
            Object.keys(d.values).forEach(val => stackValues.add(val));
        });
        const sortedStackValues = Array.from(stackValues).sort();

        // Define a color palette (extend if more than 7 unique stack values expected)
        const palette = [
            'rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(255, 206, 86, 0.6)',
            'rgba(75, 192, 192, 0.6)', 'rgba(153, 102, 255, 0.6)', 'rgba(255, 159, 64, 0.6)',
            'rgba(199, 199, 199, 0.6)'
        ];
        const colorMap = {};
        sortedStackValues.forEach((val, index) => {
            colorMap[val] = palette[index % palette.length];
        });

        const datasets = sortedStackValues.map(stackVal => ({
            label: stackVal,
            data: data.map(d => d.values[stackVal] || 0),
            backgroundColor: colorMap[stackVal],
            borderColor: colorMap[stackVal].replace('0.6', '1'), // Make border solid
            borderWidth: 1
        }));

        volumeChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: dates,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'bottom' },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: { stacked: true },
                    y: { 
                        stacked: true,
                        beginAtZero: true,
                        ticks: { precision: 0 }
                    }
                },
                onClick: (event, elements) => {
                    // Optional: handle click to filter by date and stack_value if needed
                    if (elements.length > 0) {
                        const chartElement = elements[0];
                        const dateClicked = dates[chartElement.index];
                        const datasetClicked = datasets[chartElement.datasetIndex];
                        const stackValueClicked = datasetClicked.label;
                        console.log(`Volume chart clicked: Date=${dateClicked}, ${stackBy}=${stackValueClicked}, Count=${datasetClicked.data[chartElement.index]}`);
                        // Potentially call loadArticles with additional filters
                    }
                }
            }
        });
    }

    function renderSentimentChart(data) {
        const ctx = document.getElementById('sentimentChart').getContext('2d');
        document.getElementById('sentiment-loading').classList.add('d-none');
        if (sentimentChartInstance) sentimentChartInstance.destroy();
        
        if (!data || data.length === 0) {
             document.getElementById('sentimentChart').style.display = 'none';
             document.getElementById('sentiment-loading').textContent = 'No sentiment data available.';
             document.getElementById('sentiment-loading').classList.remove('d-none');
             return;
        }
        document.getElementById('sentimentChart').style.display = 'block';

        // Define colors for all potential sentiments
        const sentimentColors = {
            positive: 'rgba(75, 192, 192, 0.6)',
            neutral: 'rgba(201, 203, 207, 0.6)',
            negative: 'rgba(255, 99, 132, 0.6)',
            mixed: 'rgba(255, 159, 64, 0.6)',    // Orange for Mixed
            critical: 'rgba(153, 102, 255, 0.6)', // Purple for Critical
            hyperbolic: 'rgba(255, 205, 86, 0.6)' // Yellow for Hyperbolic
        };

        const sentimentFields = ['positive', 'neutral', 'negative', 'mixed', 'critical', 'hyperbolic'];
        
        const datasets = sentimentFields.map(field => {
            // Check if any data point actually has this field with a count > 0
            const hasData = data.some(d => d[field] && d[field] > 0);
            if (!hasData && field !== 'positive' && field !== 'neutral' && field !== 'negative') {
                 // Optionally, always include pos/neu/neg even if zero, but hide others if no data
                 // For now, only create dataset if there's data for it, unless it's the main three.
                 // return null; // This would require filtering out nulls later
            }
            return {
                label: field.charAt(0).toUpperCase() + field.slice(1), // Capitalize first letter
                data: data.map(d => d[field] || 0), // Default to 0 if field is missing for a day
                borderColor: sentimentColors[field] ? sentimentColors[field].replace('0.6', '1') : 'rgba(0,0,0,1)',
                backgroundColor: sentimentColors[field] || 'rgba(0,0,0,0.1)',
                type: 'line',
                yAxisID: 'yCount',
                fill: false, 
                tension: 0.4, 
                borderWidth: 1
            };
        }); //.filter(ds => ds !== null); // Filter out null datasets if we chose to return null for empty ones

        sentimentChartInstance = new Chart(ctx, {
            data: {
                labels: data.map(d => d.date),
                datasets: datasets.filter(ds => ds.data.some(val => val > 0)) // Only include datasets with some data
            },
            options: {
// ... existing options, ensure yCount is the only y-axis if avg_score was fully removed
                responsive: true,
                maintainAspectRatio: false,
                interaction: { 
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    yCount: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        beginAtZero: true,
                         ticks: { precision: 0 },
                         title: { display: true, text: 'Count' }
                    }
                },
                 plugins: { 
                     legend: { position: 'bottom' },
                     tooltip: { 
                         mode: 'index',
                         intersect: false,
                     }
                },
                 onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const index = elements[0].index;
                        const clickedDate = data[index].date; 
                        const selectedTopic = document.getElementById('topicSelector').value;
                        if (selectedTopic && clickedDate) {
                             console.log(`Sentiment chart clicked. Filtering articles for date: ${clickedDate}`);
                             document.getElementById('articles-section-title').textContent = `Articles for ${clickedDate}`;
                             document.getElementById('reset-article-filter-btn').style.display = 'inline-block';
                             loadArticles(selectedTopic, 1, clickedDate, clickedDate); 
                        }
                    }
                }
            }
        });
    }

    function renderTagsCloud(data) {
        const container = document.getElementById('tagsCloudContainer');
        const loadingIndicator = document.getElementById('tags-loading');
        
        if (loadingIndicator) {
            loadingIndicator.classList.add('d-none');
        }
        
        if (!container) {
            console.error("TagCloud container not found: #tagsCloudContainer");
            return;
        }
        
        // Clear the container
        container.innerHTML = '';
        
        if (!data || data.length === 0) {
            container.innerHTML = '<div class="text-muted p-2">No tag data available.</div>';
            return;
        }

        // Create a new canvas-based tag cloud using TagCanvas library
        try {
            // Create structure for TagCanvas
            container.innerHTML = `
                <div style="width: 100%; height: 100%;">
                    <canvas id="tagsCanvas" width="500" height="270">
                        <ul id="tagsList">
                            ${data.map(tag => `<li><a href="#" data-weight="${tag.count}">${tag.tag}</a></li>`).join('')}
                        </ul>
                    </canvas>
                </div>
            `;
            
            // Get the canvas element and set willReadFrequently attribute
            const canvas = document.getElementById('tagsCanvas');
            if (canvas) {
                // Create a temporary context with willReadFrequently set to true
                // This signals to the browser that this canvas will have multiple read operations
                const tempCtx = canvas.getContext('2d', { willReadFrequently: true });
            }
            
            // Check if TagCanvas is available
            if (typeof window.TagCanvas !== 'undefined') {
                console.log("Initializing TagCanvas...");
                
                // Initialize TagCanvas with additional options for performance
                window.TagCanvas.Start('tagsCanvas', 'tagsList', {
                    textColour: '#007bff',
                    outlineColour: '#f8f9fa',
                    reverse: true,
                    depth: 0.8,
                    maxSpeed: 0.05,
                    weight: true,
                    weightFrom: 'data-weight',
                    weightMode: 'both',
                    weightSize: 1.5,
                    weightSizeMax: 30,
                    weightSizeMin: 8,
                    outlineMethod: 'none',
                    wheelZoom: false,
                    freezeActive: true,
                    initial: [0.2, -0.1],
                    decel: 0.95,
                    minBrightness: 0.1,
                    shuffleTags: true,
                    shadow: '#cccccc',
                    shadowBlur: 3
                });
                
                console.log("TagCanvas initialized successfully");
            } else {
                // Fallback if TagCanvas not available
                console.error("TagCanvas library not found");
                renderFallbackTags(data, container);
            }
        } catch (e) {
            console.error("Error initializing TagCanvas:", e);
            renderFallbackTags(data, container);
        }
    }
    
    // Simple fallback for tag rendering
    function renderFallbackTags(data, container) {
        // Create badges for tags
        let html = '<div class="p-3"><h6>Top Tags:</h6><div class="d-flex flex-wrap">';
        
        data.forEach(tag => {
            const fontSize = 10 + Math.min(16, tag.count / 2); // Cap the size
            html += `<span class="badge bg-info m-1" style="font-size: ${fontSize}px;">${tag.tag} (${tag.count})</span>`;
        });
        
        html += '</div></div>';
        container.innerHTML = html;
    }

    function renderOutliers(data) {
        const listContainer = document.getElementById('outliers-list');
        listContainer.innerHTML = ''; // Clear loading or previous data

        if (!data || data.length === 0) {
            listContainer.innerHTML = '<div class="text-muted p-2">No significant outliers detected.</div>';
            return;
        }
        
        const ul = document.createElement('ul');
        ul.className = 'list-group list-group-flush';
        
        data.forEach(outlier => {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center small py-1';
            const sentimentBadgeHtml = getSentimentBadge(outlier.sentiment, outlier.sentiment_explanation);
            li.innerHTML = `
                <span><a href="${outlier.uri}" target="_blank" rel="noopener">${(outlier.title || 'Untitled').substring(0, 50)}...</a> ${sentimentBadgeHtml}</span>
                <span class="badge bg-warning text-dark rounded-pill">Score: ${outlier.anomaly_score.toFixed(2)}</span>
            `;
            ul.appendChild(li);
        });
        listContainer.appendChild(ul);
    }

    function renderKeyArticles(data) {
        const listContainer = document.getElementById('key-articles-list');
        listContainer.innerHTML = ''; // Clear loading or previous data

        if (!data || data.length === 0) {
            listContainer.innerHTML = '<div class="text-muted p-2 small">No top stories identified for this period.</div>';
            return;
        }
        
        // Create a single tooltip element for reuse
        const tooltipElement = document.createElement('div');
        tooltipElement.className = 'top-story-hover-details';
        tooltipElement.style.display = 'none';
        document.body.appendChild(tooltipElement);
        
        // Create arrow element
        const arrowElement = document.createElement('div');
        arrowElement.className = 'tooltip-arrow';
        tooltipElement.appendChild(arrowElement);
        
        let currentVisibleItem = null;
        
        data.forEach(article => {
            // Create the main container for the story item
            const storyItem = document.createElement('div');
            storyItem.className = 'top-story-item';
            
            // Set up the category badge
            let categoryBadgeClass = 'bg-secondary'; 
            let categoryText = article.highlight_category || 'General';
            const hc = categoryText.toLowerCase();

            if (hc === 'breaking') { categoryBadgeClass = 'bg-danger'; }
            else if (hc === 'developing') { categoryBadgeClass = 'bg-warning text-dark'; }
            else if (hc === 'technology') { categoryBadgeClass = 'bg-primary'; }
            else if (hc === 'insight') { categoryBadgeClass = 'bg-info text-dark'; }
            else if (hc === 'analysis') { categoryBadgeClass = 'bg-success'; }
            else { categoryBadgeClass = 'bg-secondary'; }

            // Create the HTML for the main content
            const categoryBadge = document.createElement('span');
            categoryBadge.className = `badge category-badge ${categoryBadgeClass}`;
            categoryBadge.textContent = categoryText;
            storyItem.appendChild(categoryBadge);
            
            // Add the title
            const titleWrapper = document.createElement('h6');
            const titleLink = document.createElement('a');
            titleLink.href = article.uri;
            titleLink.target = '_blank';
            titleLink.rel = 'noopener';
            titleLink.textContent = article.title || 'Untitled';
            titleWrapper.appendChild(titleLink);
            storyItem.appendChild(titleWrapper);
            
            // Add the summary snippet
            const fullSummaryText = article.highlight_summary || article.summary || 'No summary available.';
            const summaryP = document.createElement('p');
            summaryP.className = 'summary';
            if (fullSummaryText.length > 100) {
                summaryP.textContent = fullSummaryText.substring(0, 100) + '...';
            } else {
                summaryP.textContent = fullSummaryText;
            }
            storyItem.appendChild(summaryP);
            
            // Add the timestamp
            const pubDate = article.publication_date ? new Date(article.publication_date) : null;
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'timestamp';
            timestampDiv.textContent = pubDate ? 
                pubDate.toLocaleDateString() + ' ' + pubDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 
                'N/A';
            storyItem.appendChild(timestampDiv);
            
            // Add the read more link
            const readMoreLink = document.createElement('a');
            readMoreLink.href = article.uri;
            readMoreLink.target = '_blank';
            readMoreLink.rel = 'noopener';
            readMoreLink.className = 'read-more';
            readMoreLink.innerHTML = 'Read More <i class="fas fa-arrow-right fa-xs"></i>';
            storyItem.appendChild(readMoreLink);
            
            // Store tooltip content in a data attribute
            storyItem.dataset.title = article.title || 'Untitled';
            storyItem.dataset.summary = fullSummaryText;
            storyItem.dataset.source = article.news_source || 'N/A';
            storyItem.dataset.category = article.category || 'N/A';
            storyItem.dataset.sentiment = article.sentiment || 'N/A';
            storyItem.dataset.sentimentExplanation = article.sentiment_explanation || '';
            storyItem.dataset.timeToImpact = article.time_to_impact || 'N/A';
            
            // Add mouse events for tooltip
            storyItem.addEventListener('mouseenter', function(e) {
                // Populate tooltip content
                tooltipElement.innerHTML = '';
                
                const hoverTitle = document.createElement('h6');
                hoverTitle.textContent = this.dataset.title;
                tooltipElement.appendChild(hoverTitle);
                
                const hoverSummary = document.createElement('p');
                hoverSummary.textContent = this.dataset.summary;
                tooltipElement.appendChild(hoverSummary);
                
                // Helper function to create metadata items
                function createMetaItem(label, value) {
                    const span = document.createElement('span');
                    span.className = 'meta-item';
                    const strong = document.createElement('strong');
                    strong.textContent = label + ': ';
                    span.appendChild(strong);
                    span.append(value);
                    return span;
                }
                
                tooltipElement.appendChild(createMetaItem('Source', this.dataset.source));
                tooltipElement.appendChild(createMetaItem('Category (Original)', this.dataset.category));
                
                // Create sentiment badge if applicable
                if (typeof getSentimentBadge === 'function' && this.dataset.sentiment !== 'N/A') {
                    const sentimentSpan = document.createElement('span');
                    sentimentSpan.className = 'meta-item';
                    const sentimentLabel = document.createElement('strong');
                    sentimentLabel.textContent = 'Sentiment: ';
                    sentimentSpan.appendChild(sentimentLabel);
                    
                    const sentimentBadge = document.createElement('span');
                    sentimentBadge.innerHTML = getSentimentBadge(this.dataset.sentiment, this.dataset.sentimentExplanation);
                    sentimentSpan.appendChild(sentimentBadge);
                    
                    tooltipElement.appendChild(sentimentSpan);
                } else {
                    tooltipElement.appendChild(createMetaItem('Sentiment', this.dataset.sentiment));
                }
                
                tooltipElement.appendChild(createMetaItem('Time to Impact', this.dataset.timeToImpact));
                
                // Add arrow
                const arrowElement = document.createElement('div');
                arrowElement.className = 'tooltip-arrow';
                tooltipElement.appendChild(arrowElement);
                
                // Position the tooltip
                const rect = this.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                
                // Reset any previous styles
                tooltipElement.style.left = '';
                tooltipElement.style.right = '';
                tooltipElement.style.top = '';
                arrowElement.style = '';
                
                // Check which side has more space
                if (rect.left > 320) { // Enough space on the left
                    // Position to the left
                    tooltipElement.style.left = (rect.left - 320) + 'px';
                    tooltipElement.style.top = rect.top + 'px';
                    
                    // Style arrow pointing right
                    arrowElement.style.right = '-10px';
                    arrowElement.style.top = '15px';
                    arrowElement.style.borderWidth = '10px 0 10px 10px';
                    arrowElement.style.borderColor = 'transparent transparent transparent #ced4da';
                } 
                else if (windowWidth - rect.right > 320) { // Enough space on the right
                    // Position to the right
                    tooltipElement.style.left = (rect.right + 10) + 'px';
                    tooltipElement.style.top = rect.top + 'px';
                    
                    // Style arrow pointing left
                    arrowElement.style.left = '-10px';
                    arrowElement.style.top = '15px';
                    arrowElement.style.borderWidth = '10px 10px 10px 0';
                    arrowElement.style.borderColor = 'transparent #ced4da transparent transparent';
                }
                else { // Default to below
                    tooltipElement.style.left = Math.max(10, rect.left) + 'px';
                    tooltipElement.style.top = (rect.bottom + 10) + 'px';
                    tooltipElement.style.width = Math.min(300, rect.width) + 'px';
                    
                    // Style arrow pointing up
                    arrowElement.style.left = '20px';
                    arrowElement.style.top = '-10px';
                    arrowElement.style.borderWidth = '0 10px 10px 10px';
                    arrowElement.style.borderColor = 'transparent transparent #ced4da transparent';
                }
                
                // Show the tooltip
                tooltipElement.style.display = 'block';
                currentVisibleItem = this;
            });
            
            storyItem.addEventListener('mouseleave', function(e) {
                // Only hide if mouse isn't moving to the tooltip
                setTimeout(() => {
                    if (currentVisibleItem === this) {
                        tooltipElement.style.display = 'none';
                        currentVisibleItem = null;
                    }
                }, 100);
            });
            
            // Handle tooltip hover to prevent it from disappearing when mouse moves to tooltip
            tooltipElement.addEventListener('mouseenter', function() {
                // Keep tooltip visible when hovering over it
                tooltipElement.style.display = 'block';
            });
            
            tooltipElement.addEventListener('mouseleave', function() {
                // Hide tooltip when mouse leaves it
                tooltipElement.style.display = 'none';
                currentVisibleItem = null;
            });
            
            // Append the completed story item to the list container
            listContainer.appendChild(storyItem);
        });
    }

    // Fix the renderGeneratedInsights function to properly render markdown
    function renderGeneratedInsights(data) {
        // Target the specific flex container for trend insights
        const trendInsightsFlexContainer = document.getElementById('trend-insights-flex-container');
        if (!trendInsightsFlexContainer) {
            console.error("Critical Error: #trend-insights-flex-container not found!");
            return;
        }
        trendInsightsFlexContainer.innerHTML = ''; // Clear loading or previous data

        if (!data || data.length === 0) {
            trendInsightsFlexContainer.innerHTML = '<div class="text-muted p-2 small w-100 text-center">No insights generated for this period.</div>';
            return;
        }
        
        // Log data for debugging
        console.log(`Rendering ${data.length} insights:`, data);

        data.forEach((insight, index) => {
            const insightCard = document.createElement('div');
            insightCard.className = 'insight-item-card'; // Use new class for styling
            
            // Parse markdown using marked library
            const parsedText = marked.parse(insight.text);
            
            insightCard.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0 text-primary">Insight ${index + 1}</h6>
                    <span class="badge bg-info text-dark">Trend</span>
                </div>
                <div class="insight-content small">${parsedText}</div>
            `;
            trendInsightsFlexContainer.appendChild(insightCard);
        });
    }

    function renderLatestPodcast(data) {
        const container = document.getElementById('latest-podcast-section');
        const visualizer = document.getElementById('podcast-visualizer-latest');
        container.innerHTML = ''; // Clear loading or previous data
        if (visualizer) visualizer.classList.remove('playing');

        if (!data || !data.podcast_id) {
            // Clear the hero image if no podcast
            // const heroImage = document.querySelector('#podcast-briefing-section .podcast-hero-image');
            // if (heroImage) heroImage.style.display = 'none'; // Hide if no podcast
            container.innerHTML = '<div class="text-muted p-2 small">No recent podcast available for this topic.</div>';
            return;
        }
        // Ensure hero image is visible if there is a podcast
        // const heroImage = document.querySelector('#podcast-briefing-section .podcast-hero-image');
        // if (heroImage) heroImage.style.display = 'block';


        let transcriptHtml = '';
        if (data.transcript) {
            const snippet = data.transcript.substring(0, 100) + (data.transcript.length > 100 ? '...' : '');
            transcriptHtml = `<p class="small text-muted mt-1 mb-0">Transcript: ${snippet}</p>`;
        }

        let durationHtml = '';
        if (data.duration_minutes) {
            durationHtml = `<small class="text-muted ms-2">(${data.duration_minutes.toFixed(1)} min)</small>`;
        }

        // Simplified card structure for latest podcast, to fit better with the hero image
        container.innerHTML = `
            <div>
                <h6 class="mb-1 text-primary">${data.title}</h6>
                ${data.audio_url ? `<audio controls class="w-100 mt-1" src="${data.audio_url}" style="height: 35px;" id="latest-podcast-audio"></audio>` : '<p class="small text-muted mt-1 mb-0">No audio available.</p>'}
                <div class="d-flex justify-content-between align-items-center mt-1">
                    <small class="text-muted">Published: ${new Date(data.created_at).toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' })}</small>
                    ${durationHtml}
                </div>
                ${transcriptHtml}
            </div>
        `;

        const audioElement = document.getElementById('latest-podcast-audio');
        if (audioElement && visualizer) {
            audioElement.onplay = () => visualizer.classList.add('playing');
            audioElement.onpause = () => visualizer.classList.remove('playing');
            audioElement.onended = () => visualizer.classList.remove('playing');
        }
    }

    async function loadPreviousPodcasts(topic) {
        document.getElementById('previous-podcasts-list').innerHTML = '<div class="loading-indicator small py-2">Loading previous...</div>';
        const data = await fetchData(`/api/dashboard/podcasts-for-topic/${encodeURIComponent(topic)}?limit=5`);
        renderPreviousPodcasts(data);
    }

    function renderPreviousPodcasts(podcasts) {
        const listContainer = document.getElementById('previous-podcasts-list');
        listContainer.innerHTML = ''; // Clear loading or previous data

        if (!podcasts || podcasts.length === 0) {
            listContainer.innerHTML = '<div class="list-group-item text-muted small">No previous briefings found for this topic.</div>';
            return;
        }

        podcasts.forEach(podcast => {
            const pubDate = podcast.created_at ? new Date(podcast.created_at) : null;
            const formattedDate = pubDate ? pubDate.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric' 
            }) : 'N/A';
            const formattedTime = pubDate ? pubDate.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            }) : '';
            
            const item = document.createElement('div');
            item.className = 'list-group-item py-2 px-3'; // Removed d-flex, justify-content-between, align-items-center to allow more control with inner divs
            item.setAttribute('data-podcast-id', podcast.podcast_id || ''); // Store podcast_id
            item.setAttribute('data-audio-url', podcast.audio_url || '');
            item.setAttribute('data-podcast-title', podcast.title || 'Untitled');
            item.setAttribute('data-podcast-date', formattedDate);
            item.setAttribute('data-podcast-duration', podcast.duration_minutes ? podcast.duration_minutes.toFixed(1) + ' min' : '');
            
            item.style.cursor = 'pointer';
            // item.style.transition = 'background-color 0.2s'; // Already in CSS
            // item.addEventListener('mouseover', function() {
            //     this.style.backgroundColor = '#f8f9fa'; // Already in CSS
            // });
            // item.addEventListener('mouseout', function() {
            //     this.style.backgroundColor = ''; // Already in CSS
            // });
            
            const truncatedTitle = (podcast.title || 'Untitled').length > 50 
                ? (podcast.title || 'Untitled').substring(0, 50) + '...' 
                : (podcast.title || 'Untitled');
                
            // Main content on the left (play icon, title, date, duration)
            // Action icons on the right (download, transcript)
            item.innerHTML = `
                <div class="row align-items-center">
                    <div class="col-auto play-podcast-icon-col">
                        <i class="bi bi-play-circle text-primary" style="font-size: 1.5rem;"></i>
                    </div>
                    <div class="col">
                        <div class="d-flex w-100 justify-content-between">
                            <h6 class="mb-0 text-truncate" style="max-width: 70%;" title="${podcast.title || 'Untitled'}">${truncatedTitle}</h6>
                            <small class="text-muted text-nowrap">${formattedDate}</small>
                        </div>
                        <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">${podcast.duration_minutes ? `Duration: ${podcast.duration_minutes.toFixed(1)} min` : ''}</small>
                            <small class="text-muted text-nowrap">${formattedTime}</small>
                        </div>
                    </div>
                    <div class="col-auto podcast-actions">
                        ${podcast.audio_url ? `<a href="${podcast.audio_url}" download="${podcast.title || 'podcast'}.mp3" title="Download Audio"><i class="fas fa-download"></i></a>` : ''}
                        ${podcast.podcast_id ? `<a href="#" onclick="downloadDashboardPodcastTranscript('${podcast.podcast_id}', '${podcast.title || 'podcast'}'); return false;" title="Download Transcript"><i class="fas fa-file-alt"></i></a>` : ''}
                    </div>
                </div>
            `;

            // Make the main content area (excluding actions) clickable to play
            const playSection = item.querySelector('.play-podcast-icon-col, .col:not(.podcast-actions)');
            if (playSection) {
                 // Find the column that contains the title and duration, make that clickable along with icon
                const mainContentCol = item.querySelector('.col:not(.podcast-actions)');

                // Add click listener to icon column
                item.querySelector('.play-podcast-icon-col').addEventListener('click', function(e) {
                    handlePreviousPodcastClick(item, e);
                });
                // Add click listener to main text content column
                if (mainContentCol) {
                     mainContentCol.addEventListener('click', function(e) {
                        handlePreviousPodcastClick(item, e);
                    });
                }
            }
            listContainer.appendChild(item);
        });
    }

    // New helper function to handle click on previous podcast item (refactored from renderPreviousPodcasts)
    function handlePreviousPodcastClick(itemElement, event) {
        event.preventDefault(); // Prevent default if it was a link (though it's a div now)
        event.stopPropagation(); // Stop event from bubbling up if actions are nested

        const audioUrl = itemElement.dataset.audioUrl;
        const podcastTitle = itemElement.dataset.podcastTitle;
        const podcastDate = itemElement.dataset.podcastDate; // This is already formatted "Short, Month Day"
        const podcastDuration = itemElement.dataset.podcastDuration;
        const visualizer = document.getElementById('podcast-visualizer-latest');
        // Ensure hero image is visible when a previous podcast is played
        // const heroImage = document.querySelector('#podcast-briefing-section .podcast-hero-image');
        // if (heroImage) heroImage.style.display = 'block';

        if (audioUrl) {
            const latestPodcastContainer = document.getElementById('latest-podcast-section');
            let durationHtml = podcastDuration ? `<small class="text-muted ms-2">(${podcastDuration})</small>` : '';
            
            // Update the #latest-podcast-section with the selected previous podcast's details
            latestPodcastContainer.innerHTML = `
                <div>
                    <h6 class="mb-1 text-primary">${podcastTitle}</h6>
                    <audio controls autoplay class="w-100 mt-1" src="${audioUrl}" style="height: 35px;" id="previous-podcast-audio-active"></audio>
                    <div class="d-flex justify-content-between align-items-center mt-1">
                        <small class="text-muted">Published: ${podcastDate}</small>
                        ${durationHtml}
                    </div>
                    <p class="small text-muted mt-1 mb-0 fst-italic">Now playing: previous briefing.</p>
                </div>
            `;
            
            const audioElement = document.getElementById('previous-podcast-audio-active');
            if (audioElement && visualizer) {
                visualizer.classList.add('playing');
                audioElement.onplay = () => visualizer.classList.add('playing');
                audioElement.onpause = () => visualizer.classList.remove('playing');
                audioElement.onended = () => visualizer.classList.remove('playing');
            }
            
            document.querySelectorAll('#previous-podcasts-list .list-group-item').forEach(el => {
                el.classList.remove('active', 'bg-light'); // Bootstrap 'active' also adds blue bg, remove if not desired
            });
            itemElement.classList.add('active', 'bg-light'); // Add 'active' for Bootstrap's styling or custom
        }
    }

    // Function to download podcast transcript (similar to podcastdirector.html)
    async function downloadDashboardPodcastTranscript(podcastId, podcastTitle) {
        if (!podcastId) {
            console.error("No podcast ID provided for transcript download.");
            alert("Cannot download transcript: Missing Podcast ID.");
            return;
        }
        try {
            const response = await fetch(`/api/podcast/${podcastId}/transcript`);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                throw new Error(`HTTP error! status: ${response.status} - ${errorData.detail}`);
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Sanitize title for filename
            const safeTitle = podcastTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            a.download = `${safeTitle}_transcript.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Error downloading transcript:', error);
            alert(`Error downloading transcript: ${error.message}`);
        }
    }

    // --- Helper Functions ---
    function formatDate(date) {
        // Returns YYYY-MM-DD
        const d = new Date(date);
        const month = ('' + (d.getMonth() + 1)).padStart(2, '0');
        const day = ('' + d.getDate()).padStart(2, '0');
        const year = d.getFullYear();
        return [year, month, day].join('-');
    }
    
    function setDefaultDates(days = 30) {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - days + 1); // Corrected: -days + 1 for inclusive range ending today
        
        currentEndDate = formatDate(endDate);      
        currentStartDate = formatDate(startDate);   
        
        console.log(`setDefaultDates: currentStartDate set to ${currentStartDate}, currentEndDate set to ${currentEndDate} (for ${days} days period ending today)`); // Added log

        document.getElementById('endDateInput').value = currentEndDate;
        document.getElementById('startDateInput').value = currentStartDate;

        // Update preset button active state
        document.querySelectorAll('.date-preset-btn').forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.days) === days) {
                btn.classList.add('active');
            }
        });
    }

    // --- Data Loading Functions (modified) ---
    
    // Add back the missing loadSummary function
    async function loadSummary(topic) {
        // This function is now effectively disabled by hiding its container
        // document.getElementById('topic-summary-metrics').innerHTML = '<div class="loading-indicator">Loading metrics...</div>';
        // const data = await fetchData(`/api/dashboard/topic-summary/${encodeURIComponent(topic)}`);
        // renderSummaryMetrics(data);
        console.log("Summary metrics loading skipped as section is hidden.");
    }
    
    async function loadTrends(topic) {
        console.log(`loadTrends started. currentStartDate: ${currentStartDate}, currentEndDate: ${currentEndDate}`); // Added log

        let queryParams = new URLSearchParams();
        let radarDaysLimit = 30; // Default for radar if no specific dates

        if (currentStartDate && currentEndDate) {
            queryParams.append('start_date', currentStartDate);
            queryParams.append('end_date', currentEndDate);
            // Calculate days_limit for radar consistency if needed, though start/end take precedence
            const sDate = new Date(currentStartDate);
            const eDate = new Date(currentEndDate);
            radarDaysLimit = Math.round((eDate - sDate) / (1000 * 60 * 60 * 24)) + 1;
        } else {
            // If no specific dates, find the active preset button to determine days_limit
            const activePreset = document.querySelector('.date-preset-btn.active');
            const daysFromPreset = activePreset ? parseInt(activePreset.dataset.days) : 30;
            queryParams.append('days_limit', daysFromPreset.toString());
            radarDaysLimit = daysFromPreset;
        }
        
        const stackBy = document.getElementById('volumeStackBy').value || 'category';
        
        // Clone queryParams for volume and add stack_by
        let volumeQueryParams = new URLSearchParams(queryParams.toString());
        volumeQueryParams.append('stack_by', stackBy);
        
        // Show loading indicators for all charts in this tab
        const volumeLoading = document.getElementById('volume-loading');
        if (volumeLoading) volumeLoading.classList.remove('d-none');
        
        const sentimentLoading = document.getElementById('sentiment-loading');
        if (sentimentLoading) sentimentLoading.classList.remove('d-none');
        
        const tagsLoading = document.getElementById('tags-loading');
        if (tagsLoading) tagsLoading.classList.remove('d-none');
        
        const wordcloudLoading = document.getElementById('wordcloud-loading');
        if (wordcloudLoading) wordcloudLoading.classList.remove('d-none');
        
        const radarLoading = document.getElementById('radar-loading');
        if (radarLoading) radarLoading.classList.remove('d-none');

        const volumeChartEl = document.getElementById('volumeChart');
        if (volumeChartEl) volumeChartEl.style.display = 'none';

        const sentimentChartEl = document.getElementById('sentimentChart');
        if (sentimentChartEl) sentimentChartEl.style.display = 'none';

        const tagsCloudContainerEl = document.getElementById('tagsCloudContainer');
        if (tagsCloudContainerEl) tagsCloudContainerEl.style.display = 'none';

        const wordCloudContainerEl = document.getElementById('wordCloudContainer');
        if (wordCloudContainerEl) wordCloudContainerEl.style.display = 'none';

        const radarChartElDisplay = document.getElementById('radarChart');
        if (radarChartElDisplay) radarChartElDisplay.style.display = 'none';

        // Fetch Volume Data
        console.log(`Fetching volume data with params: ${volumeQueryParams.toString()}`);
        const volumeData = await fetchData(`/api/dashboard/volume-over-time/${encodeURIComponent(topic)}?${volumeQueryParams.toString()}`);
        renderVolumeChart(volumeData, stackBy);

        // Fetch other data using the base queryParams (without stack_by, but with date range or days_limit)
        console.log(`Fetching sentiment, tags, word freq with params: ${queryParams.toString()}`);
        const sentimentData = await fetchData(`/api/dashboard/sentiment-over-time/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        renderSentimentChart(sentimentData);

        const tagsData = await fetchData(`/api/dashboard/top-tags/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        renderTagsCloud(tagsData);
        renderTopTagsList(tagsData);
        
        const wordFrequencyData = await fetchData(`/api/dashboard/word-frequency/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        renderWordCloud(wordFrequencyData);

        // Call renderRadarChart with consistent date parameters or the derived days_limit
        // renderRadarChart will construct its own final query string.
        console.log(`Calling renderRadarChart with topic: ${topic}, startDate: ${currentStartDate}, endDate: ${currentEndDate}, daysLimit: ${radarDaysLimit}`);
        renderRadarChart(topic, currentStartDate, currentEndDate, radarDaysLimit); 
    }
    
    async function loadOutliers(topic) {
        // This function is now effectively disabled by hiding its container
        // document.getElementById('outliers-list').innerHTML = '<div class="loading-indicator">Loading outliers...</div>';
        // const data = await fetchData(`/api/dashboard/semantic-outliers/${encodeURIComponent(topic)}?${outlierParams}`);
        // renderOutliers(data);
        console.log("Semantic outliers loading skipped as section is hidden.");
    }

    // Modified loadArticles to respect global date filters
    async function loadArticles(topic, page = 1, startDate = null, endDate = null) {
        currentPage = page;
        document.getElementById('articles-list').innerHTML = '<div class="loading-indicator">Loading articles...</div>';
        document.getElementById('articles-pagination').innerHTML = ''; // Clear pagination while loading

        // Use the provided date range or fall back to global date filters
        const effectiveStartDate = startDate || currentStartDate;
        const effectiveEndDate = endDate || currentEndDate;

        let apiUrl = `/api/dashboard/articles/${encodeURIComponent(topic)}?page=${page}&per_page=${articlesPerPage}`;
        
        // Always include date range if available
        if (effectiveStartDate && effectiveEndDate) {
            console.log(`Filtering articles by date range: ${effectiveStartDate} to ${effectiveEndDate}`);
            apiUrl += `&start_date=${effectiveStartDate}&end_date=${effectiveEndDate}`;
            
            // Update the section title to reflect filtering
            if (!startDate && !endDate) { // Only update if using global filters
                const daysDiff = Math.round((new Date(effectiveEndDate) - new Date(effectiveStartDate)) / (1000 * 60 * 60 * 24));
                let periodText = `${daysDiff} days`;
                if (daysDiff === 1) periodText = "24 hours";
                else if (daysDiff === 7) periodText = "1 week";
                else if (daysDiff === 30) periodText = "1 month";
                else if (daysDiff === 90) periodText = "3 months";
                else if (daysDiff === 365) periodText = "1 year";
                
                document.getElementById('articles-section-title').textContent = `Articles (Last ${periodText})`;
            }
        } else {
            document.getElementById('articles-section-title').textContent = 'Articles (All time)';
        }

        // If only filtering by specific date, hide pagination, otherwise show it
        document.getElementById('articles-pagination').style.display = (startDate && endDate && startDate === endDate) ? 'none' : 'flex';

        try {
            const data = await fetchData(apiUrl);
            renderArticles(data);
        } catch (error) {
            console.error("Error loading articles:", error);
            document.getElementById('articles-list').innerHTML = 
                '<div class="alert alert-danger">Failed to load articles. Please try again later.</div>';
        }
    }

    async function loadKeyArticles(topic) {
        console.log(`[loadKeyArticles] Called for topic: ${topic}`);
        // This ID must match the div in the main content area's Highlights section
        const targetDiv = document.getElementById('key-articles-list'); 
        if (!targetDiv) {
            console.error("[loadKeyArticles] Target div 'key-articles-list' not found!");
            return;
        }
        targetDiv.innerHTML = '<div class="loading-indicator">Loading highlights...</div>';
        
        const apiUrl = `/api/dashboard/key-articles/${encodeURIComponent(topic)}`;
        console.log(`[loadKeyArticles] Attempting to fetch from: ${apiUrl}`);
        try {
            const data = await fetchData(apiUrl);
            console.log("[loadKeyArticles] Data received:", data);
            renderKeyArticles(data);
        } catch (error) {
            console.error("[loadKeyArticles] Error fetching or rendering key articles:", error);
            targetDiv.innerHTML = '<div class="text-danger p-2 small">Failed to load highlights.</div>';
        }
    }

    async function loadGeneratedInsights(topic) {
        // Target the specific flex container for trend insights
        const trendInsightsFlexContainer = document.getElementById('trend-insights-flex-container');
        if (!trendInsightsFlexContainer) {
            console.error("Critical Error: #trend-insights-flex-container not found!");
            return;
        }
        trendInsightsFlexContainer.innerHTML = '<div class="loading-indicator w-100 text-center">Loading trend insights...</div>';
        
        let insightsParams = '';
        if (currentStartDate && currentEndDate) {
            insightsParams = `?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        } // Use current date range
        const data = await fetchData(`/api/dashboard/generated-insights/${encodeURIComponent(topic)}${insightsParams}`);
        renderGeneratedInsights(data);
    }

    async function loadLatestPodcast(topic) {
        // Ensure the target is the main player section for today's briefing
        document.getElementById('latest-podcast-section').innerHTML = '<div class="loading-indicator">Loading today\'s briefing...</div>';
        const data = await fetchData(`/api/dashboard/latest-podcast/${encodeURIComponent(topic)}`);
        renderLatestPodcast(data); // This function populates #latest-podcast-section
    }

    async function loadArticleInsights(topic) {
        const container = document.getElementById('article-insights-flex-container');
        container.innerHTML = '<div class="loading-indicator w-100 text-center">Loading article insights...</div>';
        // Construct URL with date range if available
        let insightsParams = '';
        if (currentStartDate && currentEndDate) {
            insightsParams = `?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        } // Use current date range for fetching relevant articles for insights
        const data = await fetchData(`/api/dashboard/article-insights/${encodeURIComponent(topic)}${insightsParams}`);
        renderArticleInsights(data);
    }

    function renderArticleInsights(themed_insights) { // Renamed data to themed_insights for clarity
        const container = document.getElementById('article-insights-flex-container');
        container.innerHTML = ''; // Clear loading/previous

        if (!themed_insights || themed_insights.length === 0) {
            container.innerHTML = '<div class="text-muted p-2 small w-100 text-center">No thematic article insights available for this period.</div>';
            return;
        }

        themed_insights.forEach((theme_item, index) => {
            const card = document.createElement('div');
            card.className = 'insight-item-card'; // Reuse styling
            
            let articlesHtml = '<ul class="list-unstyled mt-2 mb-0 small">';
            if (theme_item.articles && theme_item.articles.length > 0) {
                theme_item.articles.forEach(article => {
                    const pubDate = article.publication_date ? new Date(article.publication_date).toLocaleDateString() : 'N/A';
                    articlesHtml += `
                        <li class="mb-1">
                            <a href="${article.uri}" target="_blank" rel="noopener" class="text-decoration-none">
                                ${article.title || 'Untitled Article'}
                            </a>
                            <small class="text-muted d-block">${article.news_source || 'Unknown Source'} - ${pubDate}</small>
                            ${article.short_summary ? `<p class="mb-0 fst-italic text-muted">${article.short_summary}</p>` : ''}
                        </li>`;
                });
            } else {
                articlesHtml += '<li class="text-muted">No specific articles listed for this theme.</li>';
            }
            articlesHtml += '</ul>';

            card.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0 text-primary">${theme_item.theme_name || 'Unnamed Theme'}</h6>
                    <span class="badge bg-warning text-dark">Theme</span> {# Using a yellow badge for themes #}
                </div>
                <p class="mb-1 small">${theme_item.theme_summary || 'No summary provided for this theme.'}</p>
                ${articlesHtml}
            `;
            container.appendChild(card);
        });
    }

    async function loadCategoryInsights(topic) {
        const container = document.getElementById('category-insights-flex-container');
        container.innerHTML = '<div class="loading-indicator w-100 text-center">Loading category insights...</div>';
        // Construct URL with date range if available
        let insightsParams = '';
        if (currentStartDate && currentEndDate) {
            insightsParams = `?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        }
        const data = await fetchData(`/api/dashboard/category-insights/${encodeURIComponent(topic)}${insightsParams}`);
        renderCategoryInsights(data);
    }

    function renderCategoryInsights(categories) {
        const container = document.getElementById('category-insights-flex-container');
        container.innerHTML = ''; // Clear loading/previous

        if (!categories || categories.length === 0) {
            container.innerHTML = '<div class="text-muted p-2 small w-100 text-center">No category distribution data available for this period.</div>';
            return;
        }

        // Change from list to cards
        categories.forEach(cat_item => {
            const card = document.createElement('div');
            card.className = 'insight-item-card'; // Use the same class as other insight cards

            card.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0 text-primary">${cat_item.category}</h6>
                    <span class="badge bg-success text-dark">Category</span> {# Using a green badge for categories #}
                </div>
                <p class="mb-1 small"><strong>Article Count:</strong> ${cat_item.article_count}</p>
                <p class="mb-0 small fst-italic">${cat_item.insight_text || 'Further analysis for this category will be available soon.'}</p>
            `;
            // The field 'cat_item.insight_text' is hypothetical and assumes the API might provide it later.
            // If not, the placeholder text will be shown.
            container.appendChild(card);
        });
    }

    // --- Event Listeners ---
    
    document.getElementById('topicSelector').addEventListener('change', function() {
        const selectedTopic = this.value;
        if (selectedTopic) {
            localStorage.setItem(DEFAULT_TOPIC_KEY, selectedTopic); // Save selected topic
            document.getElementById('dashboard-title').textContent = `Dashboard: ${selectedTopic}`;
            if (!currentStartDate) setDefaultDates(30); 
            loadSummary(selectedTopic); // Will log skipped
            loadKeyArticles(selectedTopic);
            loadGeneratedInsights(selectedTopic);
            loadLatestPodcast(selectedTopic);
            loadPreviousPodcasts(selectedTopic);
            loadArticles(selectedTopic, 1);
            loadTrends(selectedTopic);
            loadOutliers(selectedTopic); // Will log skipped
            loadArticleInsights(selectedTopic); // <-- Add this call
            loadCategoryInsights(selectedTopic); // <-- Add this call
            startTickerUpdates();
        }
    });

    // Date Range Preset Buttons
    document.querySelectorAll('.date-preset-btn').forEach(button => {
        button.addEventListener('click', function() {
            const days = parseInt(this.dataset.days);
            setDefaultDates(days);
            // Trigger data reload if a topic is selected
            const selectedTopic = document.getElementById('topicSelector').value;
            if (selectedTopic) {
                // Reload only data affected by date range
                loadGeneratedInsights(selectedTopic);
                loadArticles(selectedTopic, 1); // Reload articles from page 1 with new date range
                loadTrends(selectedTopic);
                loadPreviousPodcasts(selectedTopic);
                loadArticleInsights(selectedTopic); // <-- Add this call
                loadCategoryInsights(selectedTopic); // <-- Add this call
            }
        });
    });

    // Custom Date Range Apply Button - Effectively hidden, but listener remains for now
    document.getElementById('applyDateRangeBtn').addEventListener('click', function() {
        const startDateVal = document.getElementById('startDateInput').value;
        const endDateVal = document.getElementById('endDateInput').value;
        
        if (startDateVal && endDateVal && startDateVal <= endDateVal) {
            currentStartDate = startDateVal;
            currentEndDate = endDateVal;
             // Deactivate preset buttons when custom range is applied
            document.querySelectorAll('.date-preset-btn').forEach(btn => btn.classList.remove('active'));
            // Trigger data reload
            const selectedTopic = document.getElementById('topicSelector').value;
            if (selectedTopic) {
                loadTrends(selectedTopic);
                loadOutliers(selectedTopic);
                loadGeneratedInsights(selectedTopic);
                loadLatestPodcast(selectedTopic);
                loadPreviousPodcasts(selectedTopic);
                loadArticleInsights(selectedTopic); // <-- Add this call
                loadCategoryInsights(selectedTopic); // <-- Add this call
            }
        } else {
            alert('Please select a valid date range.');
        }
    });

    // Add reset button listener
    document.getElementById('reset-article-filter-btn').addEventListener('click', function() {
        const selectedTopic = document.getElementById('topicSelector').value;
        if (selectedTopic) {
            document.getElementById('articles-section-title').textContent = 'Articles';
            this.style.display = 'none'; // Hide reset button
            loadArticles(selectedTopic, 1); // Reload first page, no date filter
        }
    });

    // Fix the tab initialization logic to prevent interference between panels
    document.addEventListener('DOMContentLoaded', () => {
        setDefaultDates(30); // Initialize with default 30 days
        stopTickerUpdates(); 

        // Manually initialize Bootstrap tabs with improved handler
        document.querySelectorAll('.nav-tabs .nav-link').forEach(tabLink => {
            tabLink.addEventListener('click', function(e) {
                e.preventDefault();
                
                // Get the parent tab element and its content container
                const tabContainer = this.closest('.nav-tabs');
                const tabContentId = tabContainer.getAttribute('aria-controls') || 
                                     tabContainer.getAttribute('id').replace('Tab', 'TabContent');
                
                // Only affect tabs within the same container
                const tabContent = document.getElementById(tabContentId) || 
                                   tabContainer.nextElementSibling;
                
                if (!tabContent) {
                    console.error("Tab content container not found for tab:", this.id);
                    return;
                }
                
                const targetId = this.getAttribute('data-bs-target').substring(1); // Remove leading #
                const targetTab = document.getElementById(targetId);
                
                console.log(`Tab clicked: ${this.id}, target: ${targetId}, in container: ${tabContentId}`);
                
                // Hide only the sibling tab panes in THIS tab container
                tabContent.querySelectorAll('.tab-pane').forEach(tabPane => {
                    tabPane.classList.remove('show', 'active');
                });
                
                // Show target tab content
                if (targetTab) {
                    targetTab.classList.add('show', 'active');
                    
                    // Special handling for lexical analysis tab
                    if (this.id === 'vector-analysis-tab') {
                        console.log("Lexical analysis tab clicked - refreshing visualizations");
                        // Force display for the tab to make sure it's visible
                        targetTab.style.display = 'block';
                        
                        // Then refresh visualizations
                        const selectedTopic = document.getElementById('topicSelector').value;
                        if (selectedTopic) {
                            // Wait a tiny bit to ensure DOM is ready
                            setTimeout(() => {
                                console.log("Refreshing lexical analysis visualizations...");
                                refreshLexicalAnalysis(selectedTopic);
                            }, 200);
                        }
                    }
                } else {
                    console.error(`Target tab not found: ${targetId}`);
                }
                
                // Update active state on tab links only in the current tab set
                tabContainer.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                    link.setAttribute('aria-selected', 'false');
                });
                
                this.classList.add('active');
                this.setAttribute('aria-selected', 'true');
            });
        });

        const savedTopic = localStorage.getItem(DEFAULT_TOPIC_KEY);
        const topicSelector = document.getElementById('topicSelector');
        
        // Check if topicSelector has options loaded before trying to set value
        if (topicSelector.options.length > 1 && savedTopic) {
            // Check if the saved topic is a valid option
            let topicExists = false;
            for (let i = 0; i < topicSelector.options.length; i++) {
                if (topicSelector.options[i].value === savedTopic) {
                    topicExists = true;
                    break;
                }
            }
            if (topicExists) {
                topicSelector.value = savedTopic;
                // Manually trigger the change event to load data for the saved topic
                topicSelector.dispatchEvent(new Event('change')); 
            }
        }
    });

    async function updateTicker() {
        const selectedTopic = document.getElementById('topicSelector').value;
        if (!selectedTopic) return;

        const tickerContainer = document.querySelector('#newsTicker .ticker-move');
        if (!tickerContainer) return;

        try {
            const data = await fetchData(`/api/dashboard/articles/${encodeURIComponent(selectedTopic)}?page=1&per_page=7&sort_by=submission_date&sort_order=desc`);
            if (data && data.items && data.items.length > 0) {
                const linkedTitles = data.items.map(article => {
                    const title = (article.title || 'Untitled').trim();
                    const safeTitle = title.replace(/[<>"&']/g, function (match) {
                        return {
                            '<': '&lt;',
                            '>': '&gt;',
                            '"': '&quot;',
                            '&': '&amp;',
                            "'": '&#039;'
                        }[match];
                    });
                    const summaryTooltip = article.summary ? article.summary.substring(0, 150).replace(/[<>"&']/g, function(m){return {'<':'&lt;','>':'&gt;','"':'&quot;','&':'&amp;',"'":'&#039;'}[m];}) + (article.summary.length > 150 ? '...' : '') : 'No summary available';
                    return article.uri ? `<a href="${article.uri}" target="_blank" rel="noopener noreferrer" title="${summaryTooltip}">${safeTitle}</a>` : `<span title="${summaryTooltip}">${safeTitle}</span>`;
                });
                
                const tickerContentHtml = `<span class="ticker-prefix">LATEST</span> ` + 
                                      linkedTitles.join('  <span class="ticker-separator">|</span>  '); // Using a pipe as separator with a class
                
                tickerContainer.style.animation = 'none';
                await new Promise(resolve => setTimeout(resolve, 50)); 
                
                tickerContainer.innerHTML = `<span class="ticker-item">${tickerContentHtml}</span>`; 
                
                tickerContainer.style.animation = ''; 

                document.getElementById('newsTicker').style.display = 'block';
            } else {
                 document.getElementById('newsTicker').style.display = 'none';
            }
        } catch (error) {
            console.error('Error updating ticker:', error);
            document.getElementById('newsTicker').style.display = 'none';
        }
    }

    function startTickerUpdates() {
        stopTickerUpdates(); // Clear any existing interval
        updateTicker(); // Update immediately
        tickerIntervalId = setInterval(updateTicker, TICKER_UPDATE_INTERVAL);
        console.log('Started ticker updates, interval ID:', tickerIntervalId);
    }

    function stopTickerUpdates() {
        if (tickerIntervalId) {
            clearInterval(tickerIntervalId);
            console.log('Stopped ticker updates, interval ID:', tickerIntervalId);
            tickerIntervalId = null;
        }
    }

    function renderTopTagsList(data) {
        const container = document.getElementById('topTagsList');
        if (!container) {
            console.error("Top tags list container not found");
            return;
        }
        
        if (!data || data.length === 0) {
            container.innerHTML = '<div class="text-muted p-2">No tag data available.</div>';
            return;
        }
        
        // Create a simple badge list of top tags
        let html = '<div class="d-flex flex-wrap">';
        
        // Sort data by count (descending)
        const sortedData = [...data].sort((a, b) => b.count - a.count);
        
        // Create badge for each tag
        sortedData.forEach(tag => {
            const badgeClass = tag.count > 10 ? 'bg-primary' : 
                               tag.count > 5 ? 'bg-info' : 'bg-secondary';
            html += `<span class="badge ${badgeClass} me-1 mb-1">${tag.tag} (${tag.count})</span>`;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    function renderWordCloud(data) {
        console.log("renderWordCloud (WordCloud2.js) received data:", data);

        const container = document.getElementById('wordCloudContainer');
        const loadingIndicator = document.getElementById('wordcloud-loading');

        if (loadingIndicator) {
            loadingIndicator.classList.add('d-none');
        }
        container.innerHTML = ''; // Clear previous content (e.g., D3 SVG or fallback)
        container.style.display = 'block'; // Ensure container is visible

        if (!data || data.length === 0) {
            console.warn("WordCloud2.js: No data to display.");
            container.innerHTML = '<div class="text-muted p-2">No word frequency data available for cloud.</div>';
            return;
        }

        // Transform data for WordCloud2.js: needs [['word', size], ...]
        // We can use 'count' directly as size or scale it.
        const listData = data.map(d => [String(d.word).trim(), d.count]);
        console.log("Data formatted for WordCloud2.js:", listData);

        if (listData.length === 0) {
            container.innerHTML = '<div class="text-muted p-2">No valid words for cloud after formatting.</div>';
            return;
        }

        // Create a canvas element for WordCloud2.js if it doesn't exist, or ensure the container is suitable
        // WordCloud2.js can draw on an existing canvas or an element directly.
        // For simplicity, let's allow it to draw directly on the container div.
        // Ensure container has relative/absolute positioning if WordCloud2 creates absolutely positioned elements.
        container.style.position = 'relative'; // Important for WordCloud2.js positioning
        container.style.width = container.clientWidth > 0 ? `${container.clientWidth}px` : '300px'; // Ensure width is set
        container.style.height = container.clientHeight > 0 ? `${container.clientHeight}px` : '280px'; // Ensure height is set

        try {
            if (typeof WordCloud !== 'undefined') {
                WordCloud(container, { 
                    list: listData,
                    gridSize: Math.round(16 * container.clientWidth / 1024),
                    weightFactor: function (size) {
                        // Scale font size: make smaller counts more visible, cap larger ones
                        return Math.pow(size, 0.7) * (container.clientWidth / 300); // Experiment with scaling
                    },
                    fontFamily: 'sans-serif',
                    color: 'random-dark',
                    hover: window.drawBox, // Example hover callback (optional)
                    click: function(item, dimension, event) {
                        console.log(item[0] + ': ' + item[1]);
                        // Add to search bar: item[0] is the word
                         const searchInput = document.getElementById('searchInput');
                         searchInput.value = (searchInput.value + ' ' + item[0]).trim();
                         runSearch(); // Optional: trigger search immediately
                    },
                    backgroundColor: '#ffffff', // Match dashboard section background
                    minRotation: -Math.PI / 4, // -45 degrees
                    maxRotation: Math.PI / 4,  // 45 degrees
                    rotationSteps: 2,       // 0, 45/2, 45 or 0, -45/2, -45
                    shuffle: true,
                    rotateRatio: 0.5, // 50% of words will be rotated
                    shape: 'circle', // or 'cardioid', 'diamond', 'triangle-forward', etc.
                    minSize: 5 // Minimum font size
                });
                console.log("WordCloud2.js initiated.");
            } else {
                console.error("WordCloud2.js library is not loaded!");
                renderWordCloudFallback(data, container); // Use existing fallback
            }
        } catch (error) {
            console.error("Error initializing WordCloud2.js:", error);
            renderWordCloudFallback(data, container); // Use existing fallback on error
        }
    }

    // Fallback function remains the same, it uses the original `data` format
    function renderWordCloudFallback(data, container) {
        // Simple visual fallback if WordCloud2.js fails
        let html = `
            <div class="alert alert-warning mb-2">Unable to render interactive word cloud.</div>
            <div class="p-2">
                <h6 class="mb-2">Word Frequency:</h6>
                <div class="word-cloud-fallback">
        `;
        
        // Sort data by count (descending)
        const sortedData = [...data].sort((a, b) => b.count - a.count);
        
        // Create styled text for each word
        sortedData.forEach(item => { // Changed from tag to item
            const fontSize = 10 + (item.count * 1.5); // Scale font size based on count
            const fontWeight = item.count > 10 ? 'bold' : 'normal';
            const opacity = 0.5 + (item.count / 20); // Scale opacity
            
            html += `<span style="font-size: ${fontSize}px; font-weight: ${fontWeight}; opacity: ${opacity}; display: inline-block; margin: 5px; color: #007bff;">${item.word}</span>`; // Changed from tag.tag to item.word
        });
        
        html += '</div></div>';
        container.innerHTML = html;
    }

    // Function to refresh just the lexical analysis visualizations
    async function refreshLexicalAnalysis(topic) {
        console.log("Refreshing lexical analysis for:", topic);
        
        // Check if elements exist before using them
        const tagsLoadingEl = document.getElementById('tags-loading');
        const wordcloudLoadingEl = document.getElementById('wordcloud-loading');
        
        if (tagsLoadingEl) tagsLoadingEl.classList.remove('d-none');
        if (wordcloudLoadingEl) wordcloudLoadingEl.classList.remove('d-none');
        
        // Build URL with potential date range
        let trendsParams = '';
        if (currentStartDate && currentEndDate) {
            trendsParams = `&start_date=${currentStartDate}&end_date=${currentEndDate}`;
        }
        
        try {
            // Fetch tag data and render visualizations
            const tagsData = await fetchData(`/api/dashboard/top-tags/${encodeURIComponent(topic)}?${trendsParams}`);
            console.log("Tags Data for Lexical Analysis:", tagsData);
            
            // Clear previous visualizations - check if elements exist first
            const tagsContainer = document.getElementById('tagsCloudContainer');
            const wordCloudContainer = document.getElementById('wordCloudContainer');
            const topTagsList = document.getElementById('topTagsList');
            
            if (tagsContainer) {
                tagsContainer.innerHTML = '';
                tagsContainer.style.display = 'block';
            } else {
                console.error("Tags cloud container not found!");
            }
            
            if (wordCloudContainer) {
                wordCloudContainer.innerHTML = '';
                wordCloudContainer.style.display = 'block';
            }
            
            if (topTagsList) {
                topTagsList.innerHTML = '';
            }
            
            // Only render visualizations if data exists
            if (tagsData && tagsData.length > 0) {
                renderTagsCloud(tagsData);
                renderTopTagsList(tagsData);
                // renderWordCloud(tagsData); // WordCloud is now fetched separately in loadTrends and here if needed for refresh
            } else {
                if (tagsContainer) tagsContainer.innerHTML = '<div class="text-muted p-2">No tag data available.</div>';
                // if (wordCloudContainer) wordCloudContainer.innerHTML = '<div class="text-muted p-2">No word data available.</div>';
                if (topTagsList) topTagsList.innerHTML = '<div class="text-muted p-2">No tags available.</div>';
            }

            // Refresh Word Cloud separately
            // const wordCloudContainer = document.getElementById('wordCloudContainer'); // Removed const declaration
            let wordCloudContainerEl = document.getElementById('wordCloudContainer'); // Use let and a different name or ensure it's used correctly
            const wordcloudLoadingEl = document.getElementById('wordcloud-loading');
            if (wordcloudLoadingEl) wordcloudLoadingEl.classList.remove('d-none');
            // if (wordCloudContainer) wordCloudContainer.style.display = 'none'; // Original line, commented out for safety
            if (wordCloudContainerEl) wordCloudContainerEl.style.display = 'none'; // Use the new variable name

            const wordFrequencyData = await fetchData(`/api/dashboard/word-frequency/${encodeURIComponent(topic)}?${trendsParams.replace(/^&/, '?')}`);
            console.log("Refreshed Word Frequency Data:", wordFrequencyData);
            if (wordFrequencyData && wordFrequencyData.length > 0) {
                 if (wordCloudContainerEl) wordCloudContainerEl.innerHTML = ''; // Clear before rendering
                renderWordCloud(wordFrequencyData);
            } else {
                // if (wordCloudContainer) wordCloudContainer.innerHTML = '<div class="text-muted p-2">No word data available.</div>';
                if (wordCloudContainerEl) wordCloudContainerEl.innerHTML = '<div class="text-muted p-2">No word data available.</div>';
            }

        } catch (error) {
            console.error("Error refreshing lexical analysis:", error);
            // Show error messages in containers
            const containers = [
                document.getElementById('tagsCloudContainer'),
                document.getElementById('wordCloudContainer'),
                document.getElementById('topTagsList')
            ];
            
            containers.forEach(container => {
                if (container) {
                    container.innerHTML = '<div class="alert alert-danger">Error loading data. Please try again.</div>';
                }
            });
        }
    }

    // New function to render Radar Chart
    async function renderRadarChart(topic, startDate, endDate, daysLimit) {
        const radarLoading = document.getElementById('radar-loading');
        const radarChartEl = document.getElementById('radarChart');
        const radarContainer = document.getElementById('radarChartContainer');

        radarLoading.classList.remove('d-none');
        radarChartEl.style.display = 'none';
        if (radarChartInstance) radarChartInstance.destroy();

        let queryParams = new URLSearchParams();
        if (startDate && endDate) {
            queryParams.append('start_date', startDate);
            queryParams.append('end_date', endDate);
        } else {
            queryParams.append('days_limit', daysLimit.toString());
        }
        console.log(`Fetching radar data with params: ${queryParams.toString()}`);
        const data = await fetchData(`/api/dashboard/radar-chart-data/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        console.log("Radar Chart Data Received:", data);

        radarLoading.classList.add('d-none');
        if (!data || !data.labels || data.labels.length === 0 || !data.datasets || data.datasets.length === 0) {
            radarContainer.innerHTML = '<div class="text-muted p-2 text-center small">No data available for radar chart.</div>';
            return;
        }
        radarChartEl.style.display = 'block';
        if(radarContainer.querySelector('.text-muted')) radarContainer.innerHTML = '<canvas id="radarChart"></canvas>'; // Clear placeholder if exists

        const ctx = document.getElementById('radarChart').getContext('2d');
        radarChartInstance = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: data.labels, // Future signals
                datasets: data.datasets.map(dataset => ({
                    ...dataset, // Spread existing dataset properties (label, data, colors, customData)
                    fill: true, // Explicitly set fill to true, works with backgroundColor alpha
                    pointRadius: dataset.customData.map(cd => Math.max(3, Math.min(15, Math.sqrt(cd.total_articles || 1) * 2))), // Array of radii based on total_articles
                    pointHoverRadius: dataset.customData.map(cd => Math.max(5, Math.min(20, Math.sqrt(cd.total_articles || 1) * 2.5))),
                    pointBackgroundColor: dataset.backgroundColor.replace(/0\.6\)$/, '0.8)'), // Slightly more opaque points
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                elements: {
                    line: { borderWidth: 2 },
                    point: { radius: 3, hoverRadius: 5 } 
                },
                scales: {
                    r: {
                        angleLines: { display: true },
                        suggestedMin: 0,
                        pointLabels: { font: { size: 10 } }
                        // suggestedMax: can be set if max count is known or to provide padding
                    }
                },
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.r !== null) {
                                    label += context.parsed.r + ' articles';
                                }
                                // Access customData for more details
                                const customInfo = context.dataset.customData[context.dataIndex];
                                if (customInfo && customInfo.tti_breakdown) {
                                    label += ' (TTI: ';
                                    const ttiDetails = Object.entries(customInfo.tti_breakdown)
                                        .map(([tti, count]) => `${tti}: ${count}`)
                                        .join(', ');
                                    label += ttiDetails + ')';
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    // Add event listener for the volumeStackBy dropdown
    document.getElementById('volumeStackBy').addEventListener('change', function() {
        const selectedTopic = document.getElementById('topicSelector').value;
        if (selectedTopic) {
            // Reload only the volume chart with the new stack_by parameter
            const stackBy = this.value;
            let queryParams = new URLSearchParams();
            if (currentStartDate && currentEndDate) {
                queryParams.append('start_date', currentStartDate);
                queryParams.append('end_date', currentEndDate);
            }
            queryParams.append('stack_by', stackBy);
            
            document.getElementById('volume-loading').classList.remove('d-none');
            document.getElementById('volumeChart').style.display = 'none';

            fetchData(`/api/dashboard/volume-over-time/${encodeURIComponent(selectedTopic)}?${queryParams.toString()}`)
                .then(data => renderVolumeChart(data, stackBy));
        }
    });

</script>

{% endblock %} 