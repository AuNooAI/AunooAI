{% extends 'base.html' %}
{% block title %}Topic Dashboard{% endblock %}

{% block content %}
{# Include Chart.js CDN #}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
{# Include TagCloud.js CDN - use direct TagCloud script #}
<script src="https://www.goat1000.com/tagcanvas.min.js"></script>
{# Add D3 for word cloud visualization - Keep for other potential D3 uses #}
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
{# <script src="https://cdn.jsdelivr.net/npm/d3-cloud@1.2.7/build/d3.layout.cloud.min.js"></script> #} {# Commented out D3 Cloud #}
{# Add WordCloud2.js CDN #}
<script src="https://cdn.jsdelivr.net/npm/wordcloud@1.2.2/src/wordcloud2.js"></script>

{# Add Bootstrap Icons for podcast player #}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
{# Add marked.js for markdown rendering #}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<style>
    /* Basic layout styling */
    .dashboard-container-grid {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        padding: 1rem 1.5rem;
        box-sizing: border-box;
        min-height: calc(100vh - 80px);
        max-width: 100%;
        overflow-y: auto;
        background-color: #f4f7f9; /* Lighter background for the page */
    }
    .dashboard-header {
        /* background-color: #fff; */ /* Original */
        background-color: #ffffff; /* Keep it white but add other enhancements */
        padding: 1.25rem 1.75rem; /* Slightly increased padding */
        border-radius: 8px;
        /* box-shadow: 0 2px 4px rgba(0,0,0,0.05); */ /* Original */
        box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* More pronounced shadow */
        width: 100%;
        box-sizing: border-box;
        border-bottom: 3px solid var(--bs-primary); /* Accent border */
        margin-bottom: 1rem; /* Ensure some space below header before main content */
    }
    .dashboard-sidebar {
        background-color: #f8f9fa; 
        padding: 1.5rem;
        border-radius: 8px;
        height: 100%; 
        display: none; /* Hide the sidebar column entirely */
    }
    .dashboard-main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        width: 100%;
        box-sizing: border-box;
    }
    .dashboard-section {
        background-color: #fff;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
    }
    .dashboard-section:last-child {
        margin-bottom: 0;
    }
    .chart-container {
        height: 280px; /* Slightly smaller charts */
        position: relative;
        width: 100%;
    }
    #articles-list {
         max-height: 500px; /* Adjust max height */
         overflow-y: auto;
         border-top: 1px solid #dee2e6;
         border-bottom: 1px solid #dee2e6;
         width: 100%;
         box-sizing: border-box;
    }
     #articles-list .list-group-item {
        border-left: 0;
        border-right: 0;
        padding-left: 0;
        padding-right: 0;
        width: 100%;
        box-sizing: border-box;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }
     #articles-list .list-group-item:first-child {
        border-top: 0;
    }
     #articles-list .list-group-item:last-child {
        border-bottom: 0;
    }
    #outliers-list {
        max-height: 250px; /* Adjust height */
        overflow-y: auto;
    }
    .loading-indicator {
        text-align: center;
        padding: 2rem;
        color: #6c757d;
    }
    .sentiment-badge {
        font-size: 0.75em;
        padding: 0.25em 0.5em;
        margin-left: 0.5em;
        vertical-align: middle;
    }
    .sentiment-positive { background-color: #d1e7dd; color: #0a5132; border: 1px solid #a3cfbb; }
    .sentiment-negative { background-color: #f8d7da; color: #842029; border: 1px solid #f1aeb5; }
    .sentiment-neutral { background-color: #e2e3e5; color: #41464b; border: 1px solid #c3c6ca; }
    .sentiment-unknown { background-color: #f8f9fa; color: #6c757d; border: 1px solid #dee2e6; }
    .ticker-wrap {
        width: 100%;
        overflow: hidden;
        background: transparent; 
        padding: 8px 0; 
        border-radius: 6px; 
        margin-top: 0.75rem; 
    }
    .ticker-move {
        display: inline-block;
        white-space: nowrap;
        padding-left: 100%;
        animation: ticker 60s linear infinite; 
    }
    .ticker-item {
        display: inline-block;
        padding: 0 1.5rem; 
        color: #343a40; /* Default text color */
        font-size: 0.9rem; 
    }
    
    .ticker-prefix {
        background-color: #ff007f; /* Vibrant pink for breaking news */
        color: #fff; /* White text */
        padding: 3px 8px; /* Padding to make it look like a badge */
        border-radius: 4px; /* Rounded corners for the badge */
        font-weight: 500;
        font-size: 0.85rem; /* Slightly smaller font for the badge text */
        margin-right: 0.75em;
        text-transform: uppercase; /* Uppercase LATEST */
    }
    
    /* Alternating ticker items */
    .ticker-item-pink {
        background-color: #ff007f; /* Vibrant pink bg */
        border-radius: 4px;
        padding: 3px 10px;
        margin: 0 5px;
        color: #ffffff; /* White text */
    }
    
    .ticker-item-white {
        background-color: #ffffff; /* White bg */
        border-radius: 4px;
        padding: 3px 10px;
        margin: 0 5px;
        color: #ff007f; /* Pink text */
        border: 1px solid #ff007f; /* Pink border */
    }
    
    .ticker-item a {
        text-decoration: none;
        font-weight: 500; 
        color: inherit; /* Inherit color from parent */
    }
    
    .ticker-item-white a {
        color: #ff007f; /* Pink text for links in white items */
    }
    
    .ticker-item-pink a {
        color: #ffffff; /* White text for links in pink items */
    }
    
    .ticker-item a:hover {
        text-decoration: underline;
    }
    
    .ticker-separator {
        color: #868e96; /* Medium gray for separator */
        margin: 0 0.75em; /* Spacing around separator */
        font-weight: bold;
    }

    @keyframes ticker {
        0% { transform: translate3d(0, 0, 0); }
        100% { transform: translate3d(-100%, 0, 0); }
    }
    .ticker-wrap:hover .ticker-move {
        animation-play-state: paused; /* Pause animation on hover */
    }

    /* Add styles for the trend insights container */
    #trend-insights-flex-container {
        gap: 1rem; 
        width: 100%;
        box-sizing: border-box;
        /* display: flex; flex-wrap: wrap; align-items: stretch; */ /* Ensure these are set if overridden elsewhere */
    }
    
    /* Add styles for the insights container */
    .insight-card {
        word-wrap: break-word;
        overflow-wrap: break-word;
        max-width: 100%;
    }

    /* Styles for horizontally aligned insight cards */
    .insight-item-card {
        border: 1px solid #e0e0e0; /* Slightly more visible border */
        border-radius: 6px; /* Consistent rounded corners */
        padding: 1.25rem; /* Standardized padding */
        margin-bottom: 1rem; 
        flex: 1 1 320px; /* Adjusted flex-basis for better wrapping */
        box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Softer shadow */
        display: flex; 
        flex-direction: column; 
        background-color: #fff; /* Ensure cards have a white background */
    }
    .insight-item-card h6 {
        font-size: 1rem; /* Slightly larger heading */
        color: var(--bs-primary);
    }
    .insight-item-card p {
        font-size: 0.9rem;
        flex-grow: 1; /* Allow paragraph to take available space */
        max-height: 200px; /* Maximum height before scrolling */
        overflow-y: auto;  /* Enable vertical scroll if content exceeds max-height */
        word-wrap: break-word; /* Ensure long words break */
        margin-bottom: 0; /* Adjust as needed */
    }

    /* Ensure the flex container for trend insights has a gap */
    #trend-insights-flex-container {
        gap: 1rem; /* Add gap between insight cards */
        width: 100%;
        box-sizing: border-box;
    }

    /* Styles for horizontally aligned highlight cards */
    #key-articles-list {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 1rem; /* Space between highlight cards */
        justify-content: flex-start; /* Align cards to the start */
        align-items: stretch; /* Make cards in a row equal height if needed */
    }
    /* Adjustments for highlight cards within the flex layout */
    #key-articles-list .card {
        flex: 0 0 calc(33.333% - 1rem); /* Example: 3 cards per row, considering the gap */
        /* Adjust calc if you want different number of cards per row, e.g., 50% - 0.5rem for 2 cards */
        min-width: 280px; /* Minimum width before wrapping */
        margin-bottom: 0 !important; /* Remove original margin-bottom if using gap */
    }
    
    /* Add style to ensure markdown renders properly in insight cards */
    .insight-content {
        width: 100%;
    }
    .insight-content ul, .insight-content ol {
        padding-left: 1.5rem;
    }
    .insight-content p {
        margin-bottom: 0.5rem;
    }

    /* Podcast wave visualizer styles */
    .podcast-visualizer {
        display: flex;
        align-items: flex-end; /* Align bars to the bottom */
        justify-content: center; /* Center bars */
        height: 20px; /* Height of the visualizer area */
        gap: 3px; /* Space between bars */
        margin-top: 5px; /* Space above visualizer */
        visibility: hidden; /* Hidden by default */
        opacity: 0;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }
    .podcast-visualizer.playing {
        visibility: visible;
        opacity: 1;
    }
    .podcast-visualizer span {
        width: 4px; /* Width of each bar */
        background-color: var(--bs-primary); /* Use primary color */
        display: inline-block;
        animation: wavePulse 0.8s infinite ease-in-out alternate;
    }
    .podcast-visualizer span:nth-child(1) { height: 10px; animation-delay: 0s; }
    .podcast-visualizer span:nth-child(2) { height: 15px; animation-delay: 0.2s; }
    .podcast-visualizer span:nth-child(3) { height: 12px; animation-delay: 0.4s; }

    @keyframes wavePulse {
        0% { transform: scaleY(0.3); opacity: 0.7; }
        100% { transform: scaleY(1); opacity: 1; }
    }

    /* Word Cloud styles */
    .word-cloud-fallback {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
    .word-cloud-fallback span {
        padding: 5px 10px;
        background-color: #f0f0f0;
        border-radius: 15px;
        font-size: 14px;
        color: #333;
    }
    .chart-controls {
        text-align: right;
        margin-bottom: 0.5rem;
    }
    .chart-controls label {
        margin-right: 0.5rem;
        font-size: 0.85rem;
        color: #6c757d;
    }
    .chart-controls .form-select-sm {
        display: inline-block;
        width: auto;
        vertical-align: middle;
    }
    #radarChartContainer {
        height: 400px; /* Or your desired height */
        position: relative;
        width: 100%;
    }

    /* Improved layout for Category Insights - Using Grid */
    #category-insights-flex-container {
        display: grid;
        /* grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); */ /* Responsive columns */
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* auto-fit is often better */
        gap: 1.25rem; /* Consistent gap */
        width: 100%;
        box-sizing: border-box;
    }
    /* Ensure insight cards within the grid take full height of their row if desired, or behave as blocks */
    #category-insights-flex-container .insight-item-card {
        /* flex-basis will be ignored by grid, but keep other styles */
         margin-bottom: 0; /* Gap is handled by grid, remove margin if it causes double spacing */
    }

    /* Styles for Previous Briefings list improvements */
    #previous-podcasts-list .list-group-item {
        transition: background-color 0.2s ease-in-out;
        /* display: flex;
        justify-content: space-between;
        align-items: center; */ /* Keep flex for internal alignment if needed */
    }
    #previous-podcasts-list .list-group-item:hover {
        background-color: #f8f9fa; /* Light hover effect */
    }
    .podcast-actions a {
        color: #6c757d; /* Muted color for icons */
        text-decoration: none;
        margin-left: 0.5rem;
        font-size: 0.9rem; /* Slightly smaller icon actions */
    }
    .podcast-actions a:hover {
        color: var(--bs-primary); /* Primary color on hover */
    }

    /* New styles for prominent podcast panel */
    #podcast-briefing-section {
        position: relative; /* For positioning overlay elements if needed */
        padding: 0; /* Remove padding if image is to fill */
    }
    .podcast-hero-image {
        width: 100%;
        max-height: 300px; /* Adjust as needed */
        object-fit: cover;
        border-radius: 8px 8px 0 0; /* Rounded top corners if section has rounded bottom */
        display: block;
    }
    .podcast-content-overlay {
        /* position: absolute; */ /* If you want to overlay on image */
        /* bottom: 0; */
        /* left: 0; */
        /* width: 100%; */
        background-color: rgba(255, 255, 255, 0.95); /* Semi-transparent white for readability if overlaying */
        padding: 1rem; /* Add padding back for content */
        border-radius: 0 0 8px 8px; /* If image is top part */
    }
    #latest-podcast-section .card { /* Ensure card within has no extra margin if panel padding is 0 */
        margin-bottom: 0 !important;
    }


    /* New styles for "Top Stories" (formerly Highlights) */
    #highlights-section { /* Keep ID for now, but treat as Top Stories */
        /* background-color: #f8f9fa; */ /* Optional: different background */
        /* padding: 1rem; */
    }
    #key-articles-list {
        display: flex;
        flex-direction: column; /* Stack stories vertically */
        gap: 0; /* Remove gap, use borders for separation */
    }
    .top-story-item {
        padding: 0.75rem 0;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        flex-direction: column;
    }
    .top-story-item:last-child {
        border-bottom: none;
    }
    .top-story-item .category-badge {
        font-size: 0.7rem;
        padding: 0.2em 0.5em;
        margin-bottom: 0.3rem;
        align-self: flex-start; /* Badge at the start of the line */
        text-transform: uppercase;
        font-weight: bold;
    }
    .top-story-item h6 {
        font-size: 0.95rem;
        margin-bottom: 0.25rem;
    }
    .top-story-item h6 a {
        text-decoration: none;
        color: #212529;
    }
    .top-story-item h6 a:hover {
        color: var(--bs-primary);
    }
    .top-story-item .summary {
        font-size: 0.85rem;
        color: #6c757d;
        margin-bottom: 0.3rem;
        line-height: 1.4;
    }
    .top-story-item .timestamp {
        font-size: 0.75rem;
        color: #6c757d;
        margin-bottom: 0.3rem;
    }
    .top-story-item .read-more {
        font-size: 0.8rem;
        font-weight: bold;
        color: var(--bs-primary);
        text-decoration: none;
        align-self: flex-start;
    }
    .top-story-item .read-more:hover {
        text-decoration: underline;
    }

    /* Styles for Top Story hover details */
    .top-story-item {
        position: relative; /* Needed for absolute positioning of details */
    }
    .top-story-hover-details {
        display: none;
        position: fixed; /* Changed to fixed positioning */
        width: 300px; /* Fixed width */
        background-color: #ffffff;
        border: 1px solid #ced4da;
        border-radius: 0.25rem;
        padding: 1rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        z-index: 1050; /* Even higher z-index */
        font-size: 0.85rem;
        line-height: 1.5;
        max-height: 500px; /* Maximum height to prevent overflow */
        overflow-y: auto; /* Add scrolling if needed */
    }
    .top-story-hover-details h6 {
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        color: var(--bs-primary);
        font-weight: bold;
    }
    .top-story-hover-details p {
        margin-bottom: 0.5rem;
    }
    .top-story-hover-details .meta-item {
        display: block; /* Each meta item on new line */
        margin-bottom: 0.25rem;
    }
    .top-story-hover-details .meta-item strong {
        color: #343a40;
    }
    
    /* Arrow pointing to the item */
    .tooltip-arrow {
        position: absolute;
        width: 0;
        height: 0;
        border-style: solid;
    }
    
    /* Media query for mobile/smaller screens */
    @media (max-width: 768px) {
        .top-story-hover-details {
            width: 90%; /* Almost full width on small screens */
            max-width: 300px;
        }
    }

    /* Styles for button-like tabs */
    .nav-tabs.nav-fill .nav-link {
        background-color: #e9ecef;
        border: 1px solid #dee2e6;
        color: #495057;
        border-radius: 0.25rem; /* Rounded corners */
        margin: 0 2px; /* Small gap between tabs */
        transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out, border-color 0.15s ease-in-out;
    }
    .nav-tabs.nav-fill .nav-link.active {
        background-color: var(--bs-primary);
        color: #fff;
        border-color: var(--bs-primary);
    }
    .nav-tabs.nav-fill .nav-link:hover:not(.active) {
        background-color: #ced4da;
        border-color: #adb5bd;
    }

    /* Add styles for the metadata tags */
    .metadata-tag {
        display: inline-block;
        padding: 0.2em 0.6em;
        margin-right: 0.3em;
        margin-bottom: 0.3em;
        font-size: 0.75em;
        font-weight: 600;
        line-height: 1;
        text-align: center;
        white-space: nowrap;
        vertical-align: baseline;
        border-radius: 0.25rem;
        border: 1px solid transparent;
    }

    .tag-category {
        background-color: #e6f3ff;
        color: #0066cc;
        border-color: #99ccff;
    }

    .tag-driver {
        background-color: #fff0e6;
        color: #cc6600;
        border-color: #ffcc99;
    }

    .tag-tti {
        background-color: #f0f0ff;
        color: #4b0082;
        border-color: #c0c0ff;
    }

    .tag-sentiment {
        /* Only used for non-standard sentiments */
        border-width: 1px;
        border-style: solid;
    }

    .sentiment-critical {
        background-color: #ffe6e6;
        color: #cc0000;
        border-color: #ffb3b3;
    }

    .sentiment-hyperbolic {
        background-color: #fffae6;
        color: #997a00;
        border-color: #ffe680;
    }

    .sentiment-mixed {
        background-color: #f9f9f9;
        color: #666666;
        border-color: #dddddd;
    }

    /* Add styles for the news network header */
    .news-network-header {
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #e9ecef;
        margin-bottom: 0.5rem;
    }

    .network-name {
        font-size: 1.75rem;
        font-weight: 700;
        color: #000;
        margin-bottom: 0.25rem;
    }

    .network-logo {
        /* Add any specific styling for the logo if needed, e.g., margin */
        margin-bottom: 0.25rem; /* Matches original h1 margin */
    }

    .network-date {
        font-size: 0.9rem;
        color: #666;
    }

    /* Badge styles for the header */
    .live-badge {
        background-color: #ff007f;
        color: white;
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        border-radius: 3px;
        margin-left: 1rem;
        font-weight: 600;
    }

    .header-nav {
        display: inline-block;
        margin-left: 1rem;
    }

    .header-nav a {
        color: #666;
        text-decoration: none;
        margin: 0 0.5rem;
        font-size: 0.9rem;
        padding: 0.25rem 0.5rem;
    }

    .header-nav a:hover {
        background-color: #f8f9fa;
        border-radius: 3px;
    }

    .header-nav a.active {
        color: #ff007f;
        font-weight: 600;
    }

    /* Custom pink button style for Aunoo theme */
    .btn-aunoo-pink {
        background-color: #FF69B4; /* Hot Pink */
        border-color: #FF69B4;
        color: white;
        font-size: 0.8rem; /* Smaller font for these buttons */
        padding: 0.25rem 0.6rem; /* Reduced padding */
    }
    .btn-aunoo-pink:hover {
        background-color: #FF1493; /* Deeper Pink */
        border-color: #FF1493;
        color: white;
    }

    .top-story-item .article-actions {
        /* This class might not be needed if using d-flex on parent for alignment */
    }

    /* Top Stories Show X Dropdown */
    #top-stories-content .input-group-sm {
        width: auto; /* Allow natural width */
        flex-shrink: 0; /* Prevent shrinking */
    }
    #top-stories-content .input-group-text {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }
    #topStoriesCountSelect {
        min-width: 65px; /* Slightly wider for double digits */
        max-width: 80px; /* Prevent excessive width */
        -webkit-appearance: menulist-button; /* More consistent appearance if needed */
        appearance: menulist-button; /* More consistent appearance if needed */
    }
</style>

<div class="container-fluid dashboard-container-grid">

    {# News Network Header #}
</style>

<div class="container-fluid dashboard-container-grid">

    {# News Network Header #}
    <div class="news-network-header">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                {# <h1 class="network-name">ANN - Aunoo News Network</h1> #}
                <img src="/static/img/aunoonewsnetwork.png" alt="Aunoo News Network" width="250" height="50" class="network-logo">
                <div class="network-date" id="current-date-time"></div>
            </div>
            <div>
                <span class="live-badge">LIVE</span>
                <div class="header-nav">
                    <a href="#" class="active">AI Insights</a>
                    <a href="#">Global News</a>
                </div>
            </div>
        </div>
    </div>

    {# Header Section (Topic Selector, Date Range) #}
    <div class="dashboard-header">
        {# Combined Row for Title, Topic Selector, and Date Range #}
        <div class="row align-items-center gy-2 mb-3"> 
            {# Column for Title #}
            <div class="col-md-auto">
                <h4 id="dashboard-title" class="text-primary fw-bold mb-0">Topic Dashboard</h4> 
            </div>
            
            {# Column for Topic Selector - push to the right #}
            <div class="col-md ms-md-auto" style="max-width: 300px;"> 
                 <select id="topicSelector" class="form-select form-select-sm">
                    <option value="" selected disabled>Select a Topic...</option>
                    {% for topic in topics %}
                    <option value="{{ topic }}">{{ topic }}</option>
                    {% endfor %}
                </select>
            </div>
        </div>
        
        {# Row for Date Range Controls (now below the title/topic row) #}
        <div class="row align-items-center gy-2">
            <div class="col-auto">
                <label class="form-label mb-0 small">Date Range:</label>
             </div>
             <div class="col-auto btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="1">Today</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="7">Week</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn active" data-days="30">Month</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="90">Quarter</button>
                <button type="button" class="btn btn-outline-secondary date-preset-btn" data-days="365">Year</button>
            </div>
            {# Hidden original date inputs - kept for potential future re-enablement via JS #}
            <div class="col-auto" style="display: none;">
                 <input type="date" id="startDateInput" class="form-control form-control-sm" style="width: auto;">
            </div>
             <div class="col-auto px-0" style="display: none;">-</div>
            <div class="col-auto" style="display: none;">
                 <input type="date" id="endDateInput" class="form-control form-control-sm" style="width: auto;">
            </div>
            <div class="col-auto" style="display: none;">
                <button id="applyDateRangeBtn" class="btn btn-sm btn-primary">Apply</button>
            </div>
        </div>
        {# Ticker used to be here - MOVED #}
        {# <div id="newsTicker" class="ticker-wrap mt-2" style="display: none;"> 
            <div class="ticker-move"></div>
        </div> #}
    </div>

    {# News Ticker Panel - NEW PLACEMENT #}
    <div class="dashboard-section" id="news-ticker-section" style="padding: 0.5rem 0;"> {# Reduced padding for ticker panel #}
        <div id="newsTicker" class="ticker-wrap" style="display: none; margin-top: 0;"> 
            <div class="ticker-move"></div>
        </div>
    </div>

    {# Sidebar - Kept in HTML for now but hidden with CSS, content moved to main #}
    <div class="dashboard-sidebar" style="display: none;">
        {# Content that was here (like Highlights) has been moved to dashboard-main #}
        {# Example: Old highlights structure (now moved)
        <h5 class="mb-3">Highlights</h5> 
        <div id="key-articles-list-sidebar-version" class="mb-4 flex-grow-1" style="overflow-y: auto;">
             <div class="loading-indicator">Loading highlights...</div>
        </div> 
        #}
    </div>

    {# Main Content Area (Single Column Flow) #}
    <div class="dashboard-main">
        {# AI Trends Today's Briefing - Modified for Prominent Image #}
        <div class="dashboard-section" id="podcast-briefing-section">
            <img src="/static/trend_daily_briefing.gif" alt="AI Trends Daily Briefing" class="podcast-hero-image">
            <div class="podcast-content-overlay">
                <h5 class="mb-3 mt-2"><i class="bi bi-mic-fill me-2"></i>AI Trends Today's Briefing</h5>
                <div id="latest-podcast-section" class="mb-3">
                    <div class="loading-indicator">Loading today's briefing...</div>
                </div>
                <div id="podcast-visualizer-latest" class="podcast-visualizer">
                    <span></span><span></span><span></span>
                </div>
                <h6 class="mb-2 small text-muted">Previous Briefings</h6>
                <div id="previous-podcasts-list" class="list-group list-group-flush small" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px;">
                    <div class="loading-indicator">Loading previous briefings...</div>
                </div>
            </div>
        </div>

        {# Top Stories and Articles Combined Section (Tabbed) #}
        <div class="dashboard-section" id="stories-section">
            <ul class="nav nav-tabs nav-fill nav-sm mb-3" id="storiesTab" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="top-stories-tab" data-bs-toggle="tab" data-bs-target="#top-stories-content" type="button" role="tab" aria-controls="top-stories-content" aria-selected="true">Top Stories</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="articles-tab" data-bs-toggle="tab" data-bs-target="#articles-content" type="button" role="tab" aria-controls="articles-content" aria-selected="false">All Articles</button>
                </li>
            </ul>
            <div class="tab-content" id="storiesTabContent">
                {# Top Stories Tab Content #}
                <div class="tab-pane fade show active" id="top-stories-content" role="tabpanel" aria-labelledby="top-stories-tab">
                    <div class="d-flex justify-content-end mb-2 align-items-center"> <!-- Added align-items-center -->
                        <div class="input-group input-group-sm" style="width: auto; flex-shrink: 0;"> <!-- Added flex-shrink: 0 -->
                            <label class="input-group-text" for="topStoriesCountSelect">Show:</label>
                            <select class="form-select form-select-sm" id="topStoriesCountSelect" style="min-width: 60px;"> <!-- Added min-width -->
                                <option value="1">1</option>
                                <option value="3">3</option>
                                <option value="5" selected>5</option>
                                <option value="10">10</option>
                            </select>
                        </div>
                    </div>
                    <div id="key-articles-list" class="mb-0">
                        <div class="loading-indicator">Loading top stories...</div>
                    </div>
                </div>
                
                {# Articles Tab Content #}
                <div class="tab-pane fade" id="articles-content" role="tabpanel" aria-labelledby="articles-tab">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 id="articles-section-title" class="mb-2">Articles</h6>
                        <button id="reset-article-filter-btn" class="btn btn-sm btn-outline-secondary" style="display: none;">Show All Articles</button>
                    </div>
                    <div id="articles-list" class="list-group list-group-flush mt-2">
                        <div class="loading-indicator">Select a topic to view articles.</div>
                    </div>
                    <nav aria-label="Article navigation">
                        <ul class="pagination pagination-sm justify-content-center mt-3" id="articles-pagination">
                            {# Pagination controls will be added by JS #}
                        </ul>
                    </nav>
                </div>
            </div>
        </div>

        {# Generated Insights (Tabbed) #}
        <div class="dashboard-section" id="generated-insights-tab-section">
            <h5 class="mb-3">Generated Insights</h5>
            <ul class="nav nav-tabs nav-fill nav-sm mb-3" id="insightsTab" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="trend-insights-tab" data-bs-toggle="tab" data-bs-target="#trend-insights-content" type="button" role="tab" aria-controls="trend-insights-content" aria-selected="true">Trend Insights</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="article-insights-tab" data-bs-toggle="tab" data-bs-target="#article-insights-content" type="button" role="tab" aria-controls="article-insights-content" aria-selected="false">Article Insights</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="category-insights-tab" data-bs-toggle="tab" data-bs-target="#category-insights-content" type="button" role="tab" aria-controls="category-insights-content" aria-selected="false">Category Insights</button>
                </li>
            </ul>
            <div class="tab-content" id="insightsTabContent">
                <div class="tab-pane fade show active" id="trend-insights-content" role="tabpanel" aria-labelledby="trend-insights-tab">
                    {# The .d-flex container should always be present. Loading/content goes inside it. #}
                    <div class="d-flex flex-row flex-wrap justify-content-start align-items-stretch" id="trend-insights-flex-container">
                        <div class="loading-indicator w-100 text-center">Loading trend insights...</div>
                    </div>
                </div>
                <div class="tab-pane fade" id="article-insights-content" role="tabpanel" aria-labelledby="article-insights-tab">
                    <div class="d-flex flex-row flex-wrap justify-content-start align-items-stretch" id="article-insights-flex-container">
                        <div class="text-muted p-2 small w-100 text-center">Article-specific insights will be shown here. (Coming soon)</div>
                    </div>
                </div>
                <div class="tab-pane fade" id="category-insights-content" role="tabpanel" aria-labelledby="category-insights-tab">
                    {# Use the grid container for category insights #}
                    <div id="category-insights-flex-container"> 
                        <div class="text-muted p-2 small w-100 text-center">Category-based insights will be shown here.</div>
                    </div>
                </div>
            </div>
        </div>

        {# Trends (Tabbed) #}
        <div class="dashboard-section">
            <h5 class="mb-3">Trends</h5>
            <ul class="nav nav-tabs nav-fill nav-sm mb-3" id="trendsTab" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="statistical-analysis-tab" data-bs-toggle="tab" data-bs-target="#statistical-analysis-content" type="button" role="tab" aria-controls="statistical-analysis-content" aria-selected="true">Statistical Analysis</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="vector-analysis-tab" data-bs-toggle="tab" data-bs-target="#vector-analysis-content" type="button" role="tab" aria-controls="vector-analysis-content" aria-selected="false">Lexical Analysis</button> {# Renamed from Vector Analysis #}
                </li>
            </ul>
            <div class="tab-content" id="trendsTabContent">
                <div class="tab-pane fade show active" id="statistical-analysis-content" role="tabpanel" aria-labelledby="statistical-analysis-tab">
                    <div class="row">
                        <div class="col-md-6 mb-4">
                            <div class="d-flex justify-content-between align-items-center">
                                <h6>Volume Over Time</h6>
                                <div class="chart-controls">
                                    <label for="volumeStackBy">Stack by:</label>
                                    <select id="volumeStackBy" class="form-select form-select-sm">
                                        <option value="category" selected>Category</option>
                                        <option value="sentiment">Sentiment</option>
                                    </select>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="volumeChart"></canvas>
                            </div>
                            <div id="volume-loading" class="loading-indicator d-none">Loading...</div>
                        </div>
                        <div class="col-md-6 mb-4">
                            <h6>Sentiment Over Time</h6>
                            <div class="chart-container">
                                <canvas id="sentimentChart"></canvas>
                            </div>
                            <div id="sentiment-loading" class="loading-indicator d-none">Loading...</div>
                        </div>
                    </div>
                    {# New Row for Radar Chart #}
                    <div class="row mt-4"> {# Removed mb-4 from this row to reduce potential bottom space if it's the last one #}
                        <div class="col-md-12"> {# Removed mb-4 from this col as well #}
                            <h6>Distribution by Future Signal, Sentiment & TTI</h6>
                             <div id="radarChartContainer" class="chart-container">
                                <canvas id="radarChart"></canvas>
                            </div>
                            <div id="radar-loading" class="loading-indicator d-none">Loading Radar Chart...</div>
                        </div>
                    </div>
                </div>
                <div class="tab-pane fade" id="vector-analysis-content" role="tabpanel" aria-labelledby="vector-analysis-tab">
                    <div class="row">
                        <div class="col-md-6 mb-4">
                            <h6>Top Tags</h6>
                            <div id="tagsCloudContainer" style="height: 280px; width: 100%; border: 1px solid #eee; border-radius: 4px;">
                                 <div id="tags-loading" class="loading-indicator">Loading Tags...</div>
                            </div>
                            <div id="topTagsList" class="mt-2" style="max-height: 150px; overflow-y: auto;"></div>
                        </div>
                        <div class="col-md-6 mb-4">
                            <h6>Word Frequency</h6>
                            <div id="wordCloudContainer" style="height: 280px; width: 100%; border: 1px solid #eee; border-radius: 4px;">
                                <div id="wordcloud-loading" class="loading-indicator">Loading Word Cloud...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        {# Global News Activity Map Section #}
        {% include 'components/global_news_map.html' %}
    </div>

</div> {# End dashboard-container-grid #}

<!-- Article Annotation Modal -->
<div class="modal fade" id="articleAnnotationModal" tabindex="-1" aria-labelledby="articleAnnotationModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="articleAnnotationModalLabel">Article Details & Annotations</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <h6 id="annotationModalArticleTitle">Article Title</h6>
        <p class="small text-muted" id="annotationModalArticleSource">Source: N/A</p>
        <p class="small" id="annotationModalArticleSummary">Summary loading...</p>
        <hr>
        <h5>Analyst Annotations</h5>
        <div id="existingAnnotationsContainer" class="mb-3" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding: 10px; border-radius: 4px;">
          <p class="text-muted small">No annotations yet.</p>
        </div>
        <div class="mb-3">
          <label for="newAnnotationText" class="form-label">New Annotation:</label>
          <textarea class="form-control" id="newAnnotationText" rows="3"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <input type="hidden" id="annotationModalArticleURI">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="saveAnnotationBtn">Save Annotation</button>
      </div>
    </div>
  </div>
</div>

<script>
    // Chart instances - declare globally to manage updates/destruction
    let volumeChartInstance = null;
    let sentimentChartInstance = null;
    let radarChartInstance = null; // Added for radar chart
    let tagCloudInstance = null;
    let currentPage = 1;
    const articlesPerPage = 10;
    let currentStartDate = null; // Store current date range state
    let currentEndDate = null;
    let tickerIntervalId = null; // ID for the ticker polling interval
    const TICKER_UPDATE_INTERVAL = 60000; // Update ticker every 60 seconds
    const DEFAULT_TOPIC_KEY = 'dashboardDefaultTopic'; // localStorage key

    // API Fetch Functions
    async function fetchData(url) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Fetch error:', error);
            // Display error to user? 
            return null;
        }
    }

    // Helper function to escape HTML content for safe display
    function escapeHTML(str) {
        if (str === null || typeof str === 'undefined') return '';
        return String(str).replace(/[&<"']/g, function (match) {
            return {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            }[match];
        });
    }

    // Utility for unescaping HTML (simple version for this context)
    function unescapeHTML(html) {
        const temp = document.createElement("div");
        temp.innerHTML = html;
        return temp.textContent || temp.innerText || "";
    }

    // Add a basic showAlert if not already present (can be enhanced)
    if (typeof showAlert !== 'function') {
        window.showAlert = function(message, type = 'info') {
            const alertContainer = document.getElementById('alert-container'); // Assuming you have a div with this ID in base.html or similar
            if (!alertContainer) {
                console.warn("Alert container not found, logging to console:", type, message);
                alert(`${type.toUpperCase()}: ${message}`);
                return;
            }
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show m-2`;
            alertDiv.role = 'alert';
            alertDiv.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
            alertContainer.appendChild(alertDiv);
            setTimeout(() => bootstrap.Alert.getOrCreateInstance(alertDiv)?.close(), 5000);
        }
    }

    // --- Rendering Functions ---

    function renderSummaryMetrics(data) {
        const container = document.getElementById('topic-summary-metrics');
        if (!data) {
            container.innerHTML = '<div class="alert alert-warning">Could not load summary metrics.</div>';
            return;
        }
        container.innerHTML = `
            <div class="col-md-3 col-6 mb-2"><strong>Total Articles:</strong><br>${data.total_articles}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Last 24h:</strong><br>${data.new_articles_last_24h}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Last 7d:</strong><br>${data.new_articles_last_7d}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Dominant Source (30d):</strong><br>${data.dominant_news_source || 'N/A'}</div>
            <div class="col-md-3 col-6 mb-2"><strong>Frequent TTI (30d):</strong><br>${data.most_frequent_time_to_impact || 'N/A'}</div>
            {# Add placeholders for future metrics if needed #}
        `;
    }

    function getSentimentBadge(sentiment, explanation) {
        if (!sentiment) return '';
        const sentimentLower = sentiment.toLowerCase();
        let badgeClass = 'sentiment-unknown';
        if (sentimentLower === 'positive') badgeClass = 'sentiment-positive';
        else if (sentimentLower === 'negative') badgeClass = 'sentiment-negative';
        else if (sentimentLower === 'neutral') badgeClass = 'sentiment-neutral';
        
        const displaySentiment = sentiment.charAt(0).toUpperCase() + sentiment.slice(1);
        const tooltipText = explanation ? ` title="${explanation.replace(/"/g, '&quot;')}"` : '';
        
        return `<span class="badge rounded-pill sentiment-badge ${badgeClass}" data-bs-toggle="tooltip" data-bs-placement="top"${tooltipText}>${displaySentiment}</span>`;
    }

    function renderArticles(data) {
        const listContainer = document.getElementById('articles-list');
        const paginationContainer = document.getElementById('articles-pagination');
        listContainer.innerHTML = ''; 
        paginationContainer.innerHTML = '';

        if (!data || !data.items || data.items.length === 0) {
            listContainer.innerHTML = '<div class="list-group-item text-muted">No articles found for this topic.</div>';
            return;
        }

        data.items.forEach(article => {
            const articleItem = document.createElement('div');
            articleItem.className = 'list-group-item';
            
            const pubDate = article.publication_date ? new Date(article.publication_date).toLocaleDateString() : 'N/A';
            
            let metadataHtml = '<div class="mb-1">';
            if (article.category) {
                metadataHtml += `<span class="metadata-tag tag-category"><i class="fas fa-folder-open me-1"></i>${escapeHTML(article.category)}</span>`;
            }
            if (article.driver_type) {
                metadataHtml += `<span class="metadata-tag tag-driver"><i class="fas fa-cogs me-1"></i>${escapeHTML(article.driver_type)}</span>`;
            }
            if (article.time_to_impact) {
                metadataHtml += `<span class="metadata-tag tag-tti"><i class="fas fa-clock me-1"></i>${escapeHTML(article.time_to_impact)}</span>`;
            }
            if (article.sentiment) {
                const sentimentLower = article.sentiment.toLowerCase();
                let sentimentClass = '';
                
                if (sentimentLower === 'positive' || sentimentLower === 'negative' || sentimentLower === 'neutral') {
                    sentimentClass = `sentiment-badge sentiment-${sentimentLower}`;
                } 
                else if (sentimentLower === 'critical') {
                    sentimentClass = 'metadata-tag sentiment-critical';
                }
                else if (sentimentLower === 'hyperbolic') {
                    sentimentClass = 'metadata-tag sentiment-hyperbolic';
                }
                else if (sentimentLower === 'mixed') {
                    sentimentClass = 'metadata-tag sentiment-mixed';
                }
                else {
                    sentimentClass = 'metadata-tag tag-sentiment';
                }
                
                const sentimentDisplay = escapeHTML(article.sentiment.charAt(0).toUpperCase() + article.sentiment.slice(1));
                const tooltipText = article.sentiment_explanation ? ` title="${escapeHTML(article.sentiment_explanation)}"` : '';
                
                metadataHtml += `<span class="${sentimentClass}" data-bs-toggle="tooltip" data-bs-placement="top"${tooltipText}><i class="fas fa-heart me-1"></i>${sentimentDisplay}</span>`;
            }
            
            metadataHtml += '</div>';
            
            // Regular tags
            const tagsHtml = article.tags && article.tags.length > 0 
                ? article.tags.map(tag => `<span class="badge bg-secondary me-1">${escapeHTML(tag)}</span>`).join('') 
                : '';

            // Action buttons
            let archiveUrl = '#';
            let archiveButtonDisabled = true;
            let archiveButtonTitle = 'Original URL not available for archive.is';
            if (article.url && typeof article.url === 'string' && article.url.trim() !== '') {
                archiveUrl = `https://archive.is/${article.url.trim()}`;
                archiveButtonDisabled = false;
                archiveButtonTitle = 'View on archive.is';
            } else {
                console.warn(`Article URI ${article.uri} (Title: ${article.title || 'N/A'}) has no valid original URL for archive.is link. URL was:`, article.url);
            }

            const actionsHtml = `
                <div class="mt-2 article-actions d-flex justify-content-end"> 
                    <button class="btn btn-sm btn-aunoo-pink me-2 annotate-article-btn" 
                            data-uri="${article.uri}" 
                            data-title="${escapeHTML(article.title || 'Untitled')}" 
                            data-summary="${escapeHTML(article.summary || 'No summary available.')}" 
                            data-source="${escapeHTML(article.news_source || 'Unknown Source')}" 
                            title="View/Annotate">
                        <i class="fas fa-edit"></i> Annotate
                    </button>
                    <a href="${archiveUrl}" target="_blank" rel="noopener noreferrer" 
                       class="btn btn-sm btn-outline-secondary ${archiveButtonDisabled ? 'disabled' : ''}" 
                       title="${archiveButtonTitle}" 
                       ${archiveButtonDisabled ? 'aria-disabled="true" tabindex="-1"' : ''}>
                        <i class="fas fa-archive"></i>
                    </a>
                </div>
            `;
            
            articleItem.innerHTML = `
                <div class="d-flex w-100 justify-content-between">
                    <h6 class="mb-1"><a href="${article.uri}" target="_blank" rel="noopener">${escapeHTML(article.title || 'Untitled')}</a></h6>
                    <small>${pubDate}</small>
                </div>
                <p class="mb-1"><small class="text-muted">${escapeHTML(article.news_source || 'Unknown Source')}</small></p>
                <p class="mb-1 small">${escapeHTML((article.summary || 'No summary available.').substring(0, 250))}...</p>
                ${metadataHtml}
                <div>${tagsHtml}</div>
                ${actionsHtml}
            `;
            
            listContainer.appendChild(articleItem);
        });

        // Initialize Bootstrap tooltips after rendering articles
        const tooltipTriggerList = [].slice.call(listContainer.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        });
        
        // Add event listeners for new annotate buttons
        listContainer.querySelectorAll('.annotate-article-btn').forEach(button => {
            button.addEventListener('click', function() {
                const uri = this.dataset.uri;
                const title = this.dataset.title;
                const summary = this.dataset.summary;
                const source = this.dataset.source;
                openAnnotationModal(uri, title, summary, source);
            });
        });

        renderPagination(data.total_pages, data.page);
    }
    
    function renderPagination(totalPages, currentPage) {
        const paginationContainer = document.getElementById('articles-pagination');
        paginationContainer.innerHTML = ''; // Clear previous pagination

        if (totalPages <= 1) return; // No pagination needed for 1 or 0 pages

        // Previous Button
        const prevLi = document.createElement('li');
        prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
        prevLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage - 1}">Previous</a>`;
        paginationContainer.appendChild(prevLi);

        // Page Number Buttons (simplified version)
        // Show current page and +/- 1-2 pages around it
        const startPage = Math.max(1, currentPage - 2);
        const endPage = Math.min(totalPages, currentPage + 2);

        if (startPage > 1) {
             const firstLi = document.createElement('li');
             firstLi.className = 'page-item';
             firstLi.innerHTML = `<a class="page-link" href="#" data-page="1">1</a>`;
             paginationContainer.appendChild(firstLi);
             if (startPage > 2) {
                 const ellipsisLi = document.createElement('li');
                 ellipsisLi.className = 'page-item disabled';
                 ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
                 paginationContainer.appendChild(ellipsisLi);
             }
        }

        for (let i = startPage; i <= endPage; i++) {
            const pageLi = document.createElement('li');
            pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
            pageLi.innerHTML = `<a class="page-link" href="#" data-page="${i}">${i}</a>`;
            paginationContainer.appendChild(pageLi);
        }
        
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                const ellipsisLi = document.createElement('li');
                ellipsisLi.className = 'page-item disabled';
                ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
                paginationContainer.appendChild(ellipsisLi);
            }
             const lastLi = document.createElement('li');
             lastLi.className = 'page-item';
             lastLi.innerHTML = `<a class="page-link" href="#" data-page="${totalPages}">${totalPages}</a>`;
             paginationContainer.appendChild(lastLi);
        }

        // Next Button
        const nextLi = document.createElement('li');
        nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
        nextLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage + 1}">Next</a>`;
        paginationContainer.appendChild(nextLi);

        // Add event listeners to pagination links
        paginationContainer.querySelectorAll('.page-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const page = parseInt(e.target.dataset.page);
                if (page && page !== currentPage) {
                    const selectedTopic = document.getElementById('topicSelector').value;
                    loadArticles(selectedTopic, page);
                }
            });
        });
    }

    function renderVolumeChart(data, stackBy = 'category') {
        const ctx = document.getElementById('volumeChart').getContext('2d');
        document.getElementById('volume-loading').classList.add('d-none');
        if (volumeChartInstance) volumeChartInstance.destroy();
        
        if (!data || data.length === 0) {
            document.getElementById('volumeChart').style.display = 'none';
            document.getElementById('volume-loading').textContent = 'No volume data available.';
            document.getElementById('volume-loading').classList.remove('d-none');
            return;
        }
        document.getElementById('volumeChart').style.display = 'block';

        const dates = data.map(d => d.date);
        const stackValues = new Set(); // To get all unique categories or sentiments
        data.forEach(d => {
            Object.keys(d.values).forEach(val => stackValues.add(val));
        });
        const sortedStackValues = Array.from(stackValues).sort();

        // Define a color palette (extend if more than 7 unique stack values expected)
        const palette = [
            'rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(255, 206, 86, 0.6)',
            'rgba(75, 192, 192, 0.6)', 'rgba(153, 102, 255, 0.6)', 'rgba(255, 159, 64, 0.6)',
            'rgba(199, 199, 199, 0.6)'
        ];
        const colorMap = {};
        sortedStackValues.forEach((val, index) => {
            colorMap[val] = palette[index % palette.length];
        });

        const datasets = sortedStackValues.map(stackVal => ({
            label: stackVal,
            data: data.map(d => d.values[stackVal] || 0),
            backgroundColor: colorMap[stackVal],
            borderColor: colorMap[stackVal].replace('0.6', '1'), // Make border solid
            borderWidth: 1
        }));

        volumeChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: dates,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'bottom' },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: { stacked: true },
                    y: { 
                        stacked: true,
                        beginAtZero: true,
                        ticks: { precision: 0 }
                    }
                },
                onClick: (event, elements) => {
                    // Optional: handle click to filter by date and stack_value if needed
                    if (elements.length > 0) {
                        const chartElement = elements[0];
                        const dateClicked = dates[chartElement.index];
                        const datasetClicked = datasets[chartElement.datasetIndex];
                        const stackValueClicked = datasetClicked.label;
                        console.log(`Volume chart clicked: Date=${dateClicked}, ${stackBy}=${stackValueClicked}, Count=${datasetClicked.data[chartElement.index]}`);
                        // Potentially call loadArticles with additional filters
                    }
                }
            }
        });
    }

    function renderSentimentChart(data) {
        const ctx = document.getElementById('sentimentChart').getContext('2d');
        document.getElementById('sentiment-loading').classList.add('d-none');
        if (sentimentChartInstance) sentimentChartInstance.destroy();
        
        if (!data || data.length === 0) {
             document.getElementById('sentimentChart').style.display = 'none';
             document.getElementById('sentiment-loading').textContent = 'No sentiment data available.';
             document.getElementById('sentiment-loading').classList.remove('d-none');
             return;
        }
        document.getElementById('sentimentChart').style.display = 'block';

        // Define colors for all potential sentiments
        const sentimentColors = {
            positive: 'rgba(75, 192, 192, 0.6)',
            neutral: 'rgba(201, 203, 207, 0.6)',
            negative: 'rgba(255, 99, 132, 0.6)',
            mixed: 'rgba(255, 159, 64, 0.6)',    // Orange for Mixed
            critical: 'rgba(153, 102, 255, 0.6)', // Purple for Critical
            hyperbolic: 'rgba(255, 205, 86, 0.6)' // Yellow for Hyperbolic
        };

        const sentimentFields = ['positive', 'neutral', 'negative', 'mixed', 'critical', 'hyperbolic'];
        
        const datasets = sentimentFields.map(field => {
            // Check if any data point actually has this field with a count > 0
            const hasData = data.some(d => d[field] && d[field] > 0);
            if (!hasData && field !== 'positive' && field !== 'neutral' && field !== 'negative') {
                 // Optionally, always include pos/neu/neg even if zero, but hide others if no data
                 // For now, only create dataset if there's data for it, unless it's the main three.
                 // return null; // This would require filtering out nulls later
            }
            return {
                label: field.charAt(0).toUpperCase() + field.slice(1), // Capitalize first letter
                data: data.map(d => d[field] || 0), // Default to 0 if field is missing for a day
                borderColor: sentimentColors[field] ? sentimentColors[field].replace('0.6', '1') : 'rgba(0,0,0,1)',
                backgroundColor: sentimentColors[field] || 'rgba(0,0,0,0.1)',
                type: 'line',
                yAxisID: 'yCount',
                fill: false, 
                tension: 0.4, 
                borderWidth: 1
            };
        }); //.filter(ds => ds !== null); // Filter out null datasets if we chose to return null for empty ones

        sentimentChartInstance = new Chart(ctx, {
            data: {
                labels: data.map(d => d.date),
                datasets: datasets.filter(ds => ds.data.some(val => val > 0)) // Only include datasets with some data
            },
            options: {
// ... existing options, ensure yCount is the only y-axis if avg_score was fully removed
                responsive: true,
                maintainAspectRatio: false,
                interaction: { 
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    yCount: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        beginAtZero: true,
                         ticks: { precision: 0 },
                         title: { display: true, text: 'Count' }
                    }
                },
                 plugins: { 
                     legend: { position: 'bottom' },
                     tooltip: { 
                         mode: 'index',
                         intersect: false,
                     }
                },
                 onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const index = elements[0].index;
                        const clickedDate = data[index].date; 
                        const selectedTopic = document.getElementById('topicSelector').value;
                        if (selectedTopic && clickedDate) {
                             console.log(`Sentiment chart clicked. Filtering articles for date: ${clickedDate}`);
                             document.getElementById('articles-section-title').textContent = `Articles for ${clickedDate}`;
                             document.getElementById('reset-article-filter-btn').style.display = 'inline-block';
                             loadArticles(selectedTopic, 1, clickedDate, clickedDate); 
                        }
                    }
                }
            }
        });
    }

    function renderTagsCloud(data) {
        const container = document.getElementById('tagsCloudContainer');
        const loadingIndicator = document.getElementById('tags-loading');
        
        if (loadingIndicator) {
            loadingIndicator.classList.add('d-none');
        }
        
        if (!container) {
            console.error("TagCloud container not found: #tagsCloudContainer");
            return;
        }
        
        // Clear the container
        container.innerHTML = '';
        
        if (!data || data.length === 0) {
            container.innerHTML = '<div class="text-muted p-2">No tag data available.</div>';
            return;
        }

        // Create a new canvas-based tag cloud using TagCanvas library
        try {
            // Create structure for TagCanvas
            container.innerHTML = `
                <div style="width: 100%; height: 100%;">
                    <canvas id="tagsCanvas" width="500" height="270">
                        <ul id="tagsList">
                            ${data.map(tag => `<li><a href="#" data-weight="${tag.count}">${tag.tag}</a></li>`).join('')}
                        </ul>
                    </canvas>
                </div>
            `;
            
            // Get the canvas element and set willReadFrequently attribute
            const canvas = document.getElementById('tagsCanvas');
            if (canvas) {
                // Create a temporary context with willReadFrequently set to true
                // This signals to the browser that this canvas will have multiple read operations
                const tempCtx = canvas.getContext('2d', { willReadFrequently: true });
            }
            
            // Check if TagCanvas is available
            if (typeof window.TagCanvas !== 'undefined') {
                console.log("Initializing TagCanvas...");
                
                // Initialize TagCanvas with additional options for performance
                window.TagCanvas.Start('tagsCanvas', 'tagsList', {
                    textColour: '#007bff',
                    outlineColour: '#f8f9fa',
                    reverse: true,
                    depth: 0.8,
                    maxSpeed: 0.05,
                    weight: true,
                    weightFrom: 'data-weight',
                    weightMode: 'both',
                    weightSize: 1.5,
                    weightSizeMax: 30,
                    weightSizeMin: 8,
                    outlineMethod: 'none',
                    wheelZoom: false,
                    freezeActive: true,
                    initial: [0.2, -0.1],
                    decel: 0.95,
                    minBrightness: 0.1,
                    shuffleTags: true,
                    shadow: '#cccccc',
                    shadowBlur: 3
                });
                
                console.log("TagCanvas initialized successfully");
            } else {
                // Fallback if TagCanvas not available
                console.error("TagCanvas library not found");
                renderFallbackTags(data, container);
            }
        } catch (e) {
            console.error("Error initializing TagCanvas:", e);
            renderFallbackTags(data, container);
        }
    }
    
    // Simple fallback for tag rendering
    function renderFallbackTags(data, container) {
        // Create badges for tags
        let html = '<div class="p-3"><h6>Top Tags:</h6><div class="d-flex flex-wrap">';
        
        data.forEach(tag => {
            const fontSize = 10 + Math.min(16, tag.count / 2); // Cap the size
            html += `<span class="badge bg-info m-1" style="font-size: ${fontSize}px;">${tag.tag} (${tag.count})</span>`;
        });
        
        html += '</div></div>';
        container.innerHTML = html;
    }

    function renderOutliers(data) {
        const listContainer = document.getElementById('outliers-list');
        listContainer.innerHTML = ''; // Clear loading or previous data

        if (!data || data.length === 0) {
            listContainer.innerHTML = '<div class="text-muted p-2">No significant outliers detected.</div>';
            return;
        }
        
        const ul = document.createElement('ul');
        ul.className = 'list-group list-group-flush';
        
        data.forEach(outlier => {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center small py-1';
            const sentimentBadgeHtml = getSentimentBadge(outlier.sentiment, outlier.sentiment_explanation);
            li.innerHTML = `
                <span><a href="${outlier.uri}" target="_blank" rel="noopener">${(outlier.title || 'Untitled').substring(0, 50)}...</a> ${sentimentBadgeHtml}</span>
                <span class="badge bg-warning text-dark rounded-pill">Score: ${outlier.anomaly_score.toFixed(2)}</span>
            `;
            ul.appendChild(li);
        });
        listContainer.appendChild(ul);
    }

    function renderKeyArticles(data) {
        const listContainer = document.getElementById('key-articles-list');
        listContainer.innerHTML = ''; // Clear loading or previous data

        if (!data || data.length === 0) {
            listContainer.innerHTML = '<div class="text-muted p-2 small">No top stories identified for this period.</div>';
            return;
        }
        
        // Tooltip element handling (ensure it's created once and reused, or handle its lifecycle carefully)
        let tooltipElement = document.querySelector('.top-story-hover-details');
        if (!tooltipElement) {
            tooltipElement = document.createElement('div');
            tooltipElement.className = 'top-story-hover-details';
            tooltipElement.style.display = 'none';
            document.body.appendChild(tooltipElement);
            const arrowElement = document.createElement('div');
            arrowElement.className = 'tooltip-arrow';
            tooltipElement.appendChild(arrowElement);
            tooltipElement.addEventListener('mouseenter', function() { tooltipElement.style.display = 'block'; });
            tooltipElement.addEventListener('mouseleave', function() { tooltipElement.style.display = 'none'; });
        }
        
        let currentVisibleItem = null;
        
        data.forEach(article => {
            const storyItem = document.createElement('div');
            storyItem.className = 'top-story-item';
            
            let categoryBadgeClass = 'bg-secondary'; 
            let categoryText = article.highlight_category || 'General';
            const hc = categoryText.toLowerCase();

            if (hc === 'breaking') { categoryBadgeClass = 'bg-danger'; }
            else if (hc === 'developing') { categoryBadgeClass = 'bg-warning text-dark'; }
            else if (hc === 'technology') { categoryBadgeClass = 'bg-primary'; }
            else if (hc === 'insight') { categoryBadgeClass = 'bg-info text-dark'; }
            else if (hc === 'analysis') { categoryBadgeClass = 'bg-success'; }
            else { categoryBadgeClass = 'bg-secondary'; }

            const categoryBadge = document.createElement('span');
            categoryBadge.className = `badge category-badge ${categoryBadgeClass}`;
            categoryBadge.textContent = escapeHTML(categoryText);
            storyItem.appendChild(categoryBadge);
            
            const titleWrapper = document.createElement('h6');
            const titleLink = document.createElement('a');
            titleLink.href = article.uri;
            titleLink.target = '_blank';
            titleLink.rel = 'noopener';
            // Unescape then escape to handle existing entities correctly and prevent XSS
            titleLink.textContent = escapeHTML(unescapeHTML(article.title || 'Untitled'));
            titleWrapper.appendChild(titleLink);
            storyItem.appendChild(titleWrapper);
            
            const fullSummaryText = article.highlight_summary || article.summary || 'No summary available.';
            const summaryP = document.createElement('p');
            summaryP.className = 'summary';
            // Unescape then escape for the summary as well
            summaryP.textContent = escapeHTML(unescapeHTML(fullSummaryText)); 
            storyItem.appendChild(summaryP);
            
            const pubDate = article.publication_date ? new Date(article.publication_date) : null;
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'timestamp';
            timestampDiv.textContent = pubDate ? pubDate.toLocaleDateString() + ' ' + pubDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'N/A';
            storyItem.appendChild(timestampDiv);

            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'mt-2 d-flex justify-content-end align-items-center'; 

            let archiveUrl = '#';
            let archiveButtonDisabled = true;
            let archiveButtonTitle = 'Original URL not available for archive.is';
            if (article.url && typeof article.url === 'string' && article.url.trim() !== '') {
                archiveUrl = `https://archive.is/${article.url.trim()}`;
                archiveButtonDisabled = false;
                archiveButtonTitle = 'View on archive.is';
            } else {
                console.warn(`Key Article URI ${article.uri} (Title: ${article.title || 'N/A'}) has no valid original URL for archive.is link. URL was:`, article.url);
            }
            
            const annotateButton = document.createElement('button');
            annotateButton.className = 'btn btn-sm btn-aunoo-pink me-2 annotate-article-btn'; 
            annotateButton.innerHTML = '<i class="fas fa-edit me-1"></i>Annotate';
            annotateButton.title = 'View/Annotate';
            annotateButton.dataset.uri = article.uri;
            annotateButton.dataset.title = escapeHTML(article.title || 'Untitled');
            annotateButton.dataset.summary = escapeHTML(fullSummaryText);
            annotateButton.dataset.source = escapeHTML(article.news_source || 'Unknown');
            annotateButton.addEventListener('click', function() {
                openAnnotationModal(this.dataset.uri, this.dataset.title, this.dataset.summary, this.dataset.source);
            });
            actionsContainer.appendChild(annotateButton);

            const archiveLink = document.createElement('a');
            archiveLink.href = archiveUrl;
            archiveLink.target = '_blank';
            archiveLink.rel = 'noopener noreferrer';
            archiveLink.className = `btn btn-sm btn-outline-secondary ${archiveButtonDisabled ? 'disabled' : ''}`;
            archiveLink.innerHTML = '<i class="fas fa-archive"></i>';
            archiveLink.title = archiveButtonTitle;
            if (archiveButtonDisabled) {
                archiveLink.setAttribute('aria-disabled', 'true');
                archiveLink.setAttribute('tabindex', '-1'); 
            }
            actionsContainer.appendChild(archiveLink);
            
            storyItem.appendChild(actionsContainer);
            
            const readMoreLink = document.createElement('a');
            readMoreLink.href = article.uri; 
            readMoreLink.target = '_blank';
            readMoreLink.rel = 'noopener';
            readMoreLink.className = 'read-more';
            readMoreLink.innerHTML = 'Read More <i class="fas fa-arrow-right fa-xs"></i>';
            storyItem.appendChild(readMoreLink); 
            
            storyItem.dataset.title = escapeHTML(unescapeHTML(article.title || 'Untitled'));
            storyItem.dataset.summary = escapeHTML(unescapeHTML(fullSummaryText));
            storyItem.dataset.source = escapeHTML(unescapeHTML(article.news_source || 'N/A'));
            storyItem.dataset.category = escapeHTML(unescapeHTML(article.category || 'N/A'));
            storyItem.dataset.sentiment = escapeHTML(unescapeHTML(article.sentiment || 'N/A'));
            storyItem.dataset.sentimentExplanation = escapeHTML(unescapeHTML(article.sentiment_explanation || ''));
            storyItem.dataset.timeToImpact = escapeHTML(unescapeHTML(article.time_to_impact || 'N/A'));
            
            // Simplified hover listeners to avoid issues with complex shared tooltipElement
            storyItem.addEventListener('mouseenter', function(e) { 
                // For complex tooltips, ensure tooltipElement is correctly positioned and updated here.
                // For now, relying on browser default title attribute for `storyItem` if needed.
            });
            storyItem.addEventListener('mouseleave', function(e) { 
                // if (tooltipElement) tooltipElement.style.display = 'none';
            });
            
            listContainer.appendChild(storyItem);
        });
    }

    // Fix the renderGeneratedInsights function to properly render markdown
    function renderGeneratedInsights(data) {
        // Target the specific flex container for trend insights
        const trendInsightsFlexContainer = document.getElementById('trend-insights-flex-container');
        if (!trendInsightsFlexContainer) {
            console.error("Critical Error: #trend-insights-flex-container not found!");
            return;
        }
        trendInsightsFlexContainer.innerHTML = ''; // Clear loading or previous data

        if (!data || data.length === 0) {
            trendInsightsFlexContainer.innerHTML = '<div class="text-muted p-2 small w-100 text-center">No insights generated for this period.</div>';
            return;
        }
        
        // Log data for debugging
        console.log(`Rendering ${data.length} insights:`, data);

        data.forEach((insight, index) => {
            const insightCard = document.createElement('div');
            insightCard.className = 'insight-item-card'; // Use new class for styling
            
            // Parse markdown using marked library
            const parsedText = marked.parse(insight.text);
            
            insightCard.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0 text-primary">Insight ${index + 1}</h6>
                    <span class="badge bg-info text-dark">Trend</span>
                </div>
                <div class="insight-content small">${parsedText}</div>
            `;
            trendInsightsFlexContainer.appendChild(insightCard);
        });
    }

    function renderLatestPodcast(data) {
        const container = document.getElementById('latest-podcast-section');
        const visualizer = document.getElementById('podcast-visualizer-latest');
        container.innerHTML = ''; // Clear loading or previous data
        if (visualizer) visualizer.classList.remove('playing');

        if (!data || !data.podcast_id) {
            // Clear the hero image if no podcast
            // const heroImage = document.querySelector('#podcast-briefing-section .podcast-hero-image');
            // if (heroImage) heroImage.style.display = 'none'; // Hide if no podcast
            container.innerHTML = '<div class="text-muted p-2 small">No recent podcast available for this topic.</div>';
            return;
        }
        // Ensure hero image is visible if there is a podcast
        // const heroImage = document.querySelector('#podcast-briefing-section .podcast-hero-image');
        // if (heroImage) heroImage.style.display = 'block';


        let transcriptHtml = '';
        if (data.transcript) {
            const snippet = data.transcript.substring(0, 100) + (data.transcript.length > 100 ? '...' : '');
            transcriptHtml = `<p class="small text-muted mt-1 mb-0">Transcript: ${snippet}</p>`;
        }

        let durationHtml = '';
        if (data.duration_minutes) {
            durationHtml = `<small class="text-muted ms-2">(${data.duration_minutes.toFixed(1)} min)</small>`;
        }

        // Simplified card structure for latest podcast, to fit better with the hero image
        container.innerHTML = `
            <div>
                <h6 class="mb-1 text-primary">${data.title}</h6>
                ${data.audio_url ? `<audio controls class="w-100 mt-1" src="${data.audio_url}" style="height: 35px;" id="latest-podcast-audio"></audio>` : '<p class="small text-muted mt-1 mb-0">No audio available.</p>'}
                <div class="d-flex justify-content-between align-items-center mt-1">
                    <small class="text-muted">Published: ${new Date(data.created_at).toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' })}</small>
                    ${durationHtml}
                </div>
                ${transcriptHtml}
            </div>
        `;

        const audioElement = document.getElementById('latest-podcast-audio');
        if (audioElement && visualizer) {
            audioElement.onplay = () => visualizer.classList.add('playing');
            audioElement.onpause = () => visualizer.classList.remove('playing');
            audioElement.onended = () => visualizer.classList.remove('playing');
        }
    }

    async function loadPreviousPodcasts(topic) {
        document.getElementById('previous-podcasts-list').innerHTML = '<div class="loading-indicator small py-2">Loading previous...</div>';
        const data = await fetchData(`/api/dashboard/podcasts-for-topic/${encodeURIComponent(topic)}?limit=5`);
        renderPreviousPodcasts(data);
    }

    function renderPreviousPodcasts(podcasts) {
        const listContainer = document.getElementById('previous-podcasts-list');
        listContainer.innerHTML = ''; // Clear loading or previous data

        if (!podcasts || podcasts.length === 0) {
            listContainer.innerHTML = '<div class="list-group-item text-muted small">No previous briefings found for this topic.</div>';
            return;
        }

        podcasts.forEach(podcast => {
            const pubDate = podcast.created_at ? new Date(podcast.created_at) : null;
            const formattedDate = pubDate ? pubDate.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric' 
            }) : 'N/A';
            const formattedTime = pubDate ? pubDate.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            }) : '';
            
            const item = document.createElement('div');
            item.className = 'list-group-item py-2 px-3'; // Removed d-flex, justify-content-between, align-items-center to allow more control with inner divs
            item.setAttribute('data-podcast-id', podcast.podcast_id || ''); // Store podcast_id
            item.setAttribute('data-audio-url', podcast.audio_url || '');
            item.setAttribute('data-podcast-title', podcast.title || 'Untitled');
            item.setAttribute('data-podcast-date', formattedDate);
            item.setAttribute('data-podcast-duration', podcast.duration_minutes ? podcast.duration_minutes.toFixed(1) + ' min' : '');
            
            item.style.cursor = 'pointer';
            // item.style.transition = 'background-color 0.2s'; // Already in CSS
            // item.addEventListener('mouseover', function() {
            //     this.style.backgroundColor = '#f8f9fa'; // Already in CSS
            // });
            // item.addEventListener('mouseout', function() {
            //     this.style.backgroundColor = ''; // Already in CSS
            // });
            
            const truncatedTitle = (podcast.title || 'Untitled').length > 50 
                ? (podcast.title || 'Untitled').substring(0, 50) + '...' 
                : (podcast.title || 'Untitled');
                
            // Main content on the left (play icon, title, date, duration)
            // Action icons on the right (download, transcript)
            item.innerHTML = `
                <div class="row align-items-center">
                    <div class="col-auto play-podcast-icon-col">
                        <i class="bi bi-play-circle text-primary" style="font-size: 1.5rem;"></i>
                    </div>
                    <div class="col">
                        <div class="d-flex w-100 justify-content-between">
                            <h6 class="mb-0 text-truncate" style="max-width: 70%;" title="${podcast.title || 'Untitled'}">${truncatedTitle}</h6>
                            <small class="text-muted text-nowrap">${formattedDate}</small>
                        </div>
                        <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">${podcast.duration_minutes ? `Duration: ${podcast.duration_minutes.toFixed(1)} min` : ''}</small>
                            <small class="text-muted text-nowrap">${formattedTime}</small>
                        </div>
                    </div>
                    <div class="col-auto podcast-actions">
                        ${podcast.audio_url ? `<a href="${podcast.audio_url}" download="${podcast.title || 'podcast'}.mp3" title="Download Audio"><i class="fas fa-download"></i></a>` : ''}
                        ${podcast.podcast_id ? `<a href="#" onclick="downloadDashboardPodcastTranscript('${podcast.podcast_id}', '${podcast.title || 'podcast'}'); return false;" title="Download Transcript"><i class="fas fa-file-alt"></i></a>` : ''}
                    </div>
                </div>
            `;

            // Make the main content area (excluding actions) clickable to play
            const playSection = item.querySelector('.play-podcast-icon-col, .col:not(.podcast-actions)');
            if (playSection) {
                 // Find the column that contains the title and duration, make that clickable along with icon
                const mainContentCol = item.querySelector('.col:not(.podcast-actions)');

                // Add click listener to icon column
                item.querySelector('.play-podcast-icon-col').addEventListener('click', function(e) {
                    handlePreviousPodcastClick(item, e);
                });
                // Add click listener to main text content column
                if (mainContentCol) {
                     mainContentCol.addEventListener('click', function(e) {
                        handlePreviousPodcastClick(item, e);
                    });
                }
            }
            listContainer.appendChild(item);
        });
    }

    // New helper function to handle click on previous podcast item (refactored from renderPreviousPodcasts)
    function handlePreviousPodcastClick(itemElement, event) {
        event.preventDefault(); // Prevent default if it was a link (though it's a div now)
        event.stopPropagation(); // Stop event from bubbling up if actions are nested

        const audioUrl = itemElement.dataset.audioUrl;
        const podcastTitle = itemElement.dataset.podcastTitle;
        const podcastDate = itemElement.dataset.podcastDate; // This is already formatted "Short, Month Day"
        const podcastDuration = itemElement.dataset.podcastDuration;
        const visualizer = document.getElementById('podcast-visualizer-latest');
        // Ensure hero image is visible when a previous podcast is played
        // const heroImage = document.querySelector('#podcast-briefing-section .podcast-hero-image');
        // if (heroImage) heroImage.style.display = 'block';

        if (audioUrl) {
            const latestPodcastContainer = document.getElementById('latest-podcast-section');
            let durationHtml = podcastDuration ? `<small class="text-muted ms-2">(${podcastDuration})</small>` : '';
            
            // Update the #latest-podcast-section with the selected previous podcast's details
            latestPodcastContainer.innerHTML = `
                <div>
                    <h6 class="mb-1 text-primary">${podcastTitle}</h6>
                    <audio controls autoplay class="w-100 mt-1" src="${audioUrl}" style="height: 35px;" id="previous-podcast-audio-active"></audio>
                    <div class="d-flex justify-content-between align-items-center mt-1">
                        <small class="text-muted">Published: ${podcastDate}</small>
                        ${durationHtml}
                    </div>
                    <p class="small text-muted mt-1 mb-0 fst-italic">Now playing: previous briefing.</p>
                </div>
            `;
            
            const audioElement = document.getElementById('previous-podcast-audio-active');
            if (audioElement && visualizer) {
                visualizer.classList.add('playing');
                audioElement.onplay = () => visualizer.classList.add('playing');
                audioElement.onpause = () => visualizer.classList.remove('playing');
                audioElement.onended = () => visualizer.classList.remove('playing');
            }
            
            document.querySelectorAll('#previous-podcasts-list .list-group-item').forEach(el => {
                el.classList.remove('active', 'bg-light'); // Bootstrap 'active' also adds blue bg, remove if not desired
            });
            itemElement.classList.add('active', 'bg-light'); // Add 'active' for Bootstrap's styling or custom
        }
    }

    // Function to download podcast transcript (similar to podcastdirector.html)
    async function downloadDashboardPodcastTranscript(podcastId, podcastTitle) {
        if (!podcastId) {
            console.error("No podcast ID provided for transcript download.");
            alert("Cannot download transcript: Missing Podcast ID.");
            return;
        }
        try {
            const response = await fetch(`/api/podcast/${podcastId}/transcript`);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                throw new Error(`HTTP error! status: ${response.status} - ${errorData.detail}`);
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Sanitize title for filename
            const safeTitle = podcastTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            a.download = `${safeTitle}_transcript.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Error downloading transcript:', error);
            alert(`Error downloading transcript: ${error.message}`);
        }
    }

    // --- Helper Functions ---
    function formatDate(date) {
        // Returns YYYY-MM-DD
        const d = new Date(date);
        const month = ('' + (d.getMonth() + 1)).padStart(2, '0');
        const day = ('' + d.getDate()).padStart(2, '0');
        const year = d.getFullYear();
        return [year, month, day].join('-');
    }
    
    function setDefaultDates(days = 30) {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - days + 1); // Corrected: -days + 1 for inclusive range ending today
        
        currentEndDate = formatDate(endDate);      
        currentStartDate = formatDate(startDate);   
        
        console.log(`setDefaultDates: currentStartDate set to ${currentStartDate}, currentEndDate set to ${currentEndDate} (for ${days} days period ending today)`); // Added log

        document.getElementById('endDateInput').value = currentEndDate;
        document.getElementById('startDateInput').value = currentStartDate;

        // Update preset button active state
        document.querySelectorAll('.date-preset-btn').forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.days) === days) {
                btn.classList.add('active');
            }
        });
    }

    // --- Data Loading Functions (modified) ---
    
    // Add back the missing loadSummary function
    async function loadSummary(topic) {
        // This function is now effectively disabled by hiding its container
        // document.getElementById('topic-summary-metrics').innerHTML = '<div class="loading-indicator">Loading metrics...</div>';
        // const data = await fetchData(`/api/dashboard/topic-summary/${encodeURIComponent(topic)}`);
        // renderSummaryMetrics(data);
        console.log("Summary metrics loading skipped as section is hidden.");
    }
    
    async function loadTrends(topic) {
        console.log(`loadTrends started. currentStartDate: ${currentStartDate}, currentEndDate: ${currentEndDate}`); // Added log

        let queryParams = new URLSearchParams();
        let radarDaysLimit = 30; // Default for radar if no specific dates

        if (currentStartDate && currentEndDate) {
            queryParams.append('start_date', currentStartDate);
            queryParams.append('end_date', currentEndDate);
            // Calculate days_limit for radar consistency if needed, though start/end take precedence
            const sDate = new Date(currentStartDate);
            const eDate = new Date(currentEndDate);
            radarDaysLimit = Math.round((eDate - sDate) / (1000 * 60 * 60 * 24)) + 1;
        } else {
            // If no specific dates, find the active preset button to determine days_limit
            const activePreset = document.querySelector('.date-preset-btn.active');
            const daysFromPreset = activePreset ? parseInt(activePreset.dataset.days) : 30;
            queryParams.append('days_limit', daysFromPreset.toString());
            radarDaysLimit = daysFromPreset;
        }
        
        const stackBy = document.getElementById('volumeStackBy').value || 'category';
        
        // Clone queryParams for volume and add stack_by
        let volumeQueryParams = new URLSearchParams(queryParams.toString());
        volumeQueryParams.append('stack_by', stackBy);
        
        // Show loading indicators for all charts in this tab
        const volumeLoading = document.getElementById('volume-loading');
        if (volumeLoading) volumeLoading.classList.remove('d-none');
        
        const sentimentLoading = document.getElementById('sentiment-loading');
        if (sentimentLoading) sentimentLoading.classList.remove('d-none');
        
        const tagsLoading = document.getElementById('tags-loading');
        if (tagsLoading) tagsLoading.classList.remove('d-none');
        
        const wordcloudLoading = document.getElementById('wordcloud-loading');
        if (wordcloudLoading) wordcloudLoading.classList.remove('d-none');
        
        const radarLoading = document.getElementById('radar-loading');
        if (radarLoading) radarLoading.classList.remove('d-none');

        const volumeChartEl = document.getElementById('volumeChart');
        if (volumeChartEl) volumeChartEl.style.display = 'none';

        const sentimentChartEl = document.getElementById('sentimentChart');
        if (sentimentChartEl) sentimentChartEl.style.display = 'none';

        const tagsCloudContainerEl = document.getElementById('tagsCloudContainer');
        if (tagsCloudContainerEl) tagsCloudContainerEl.style.display = 'none';

        const wordCloudContainerEl = document.getElementById('wordCloudContainer');
        if (wordCloudContainerEl) wordCloudContainerEl.style.display = 'none';

        const radarChartElDisplay = document.getElementById('radarChart');
        if (radarChartElDisplay) radarChartElDisplay.style.display = 'none';

        // Fetch Volume Data
        console.log(`Fetching volume data with params: ${volumeQueryParams.toString()}`);
        const volumeData = await fetchData(`/api/dashboard/volume-over-time/${encodeURIComponent(topic)}?${volumeQueryParams.toString()}`);
        renderVolumeChart(volumeData, stackBy);

        // Fetch other data using the base queryParams (without stack_by, but with date range or days_limit)
        console.log(`Fetching sentiment, tags, word freq with params: ${queryParams.toString()}`);
        const sentimentData = await fetchData(`/api/dashboard/sentiment-over-time/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        renderSentimentChart(sentimentData);

        const tagsData = await fetchData(`/api/dashboard/top-tags/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        renderTagsCloud(tagsData);
        renderTopTagsList(tagsData);
        
        const wordFrequencyData = await fetchData(`/api/dashboard/word-frequency/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        renderWordCloud(wordFrequencyData);

        // Call renderRadarChart with consistent date parameters or the derived days_limit
        // renderRadarChart will construct its own final query string.
        console.log(`Calling renderRadarChart with topic: ${topic}, startDate: ${currentStartDate}, endDate: ${currentEndDate}, daysLimit: ${radarDaysLimit}`);
        renderRadarChart(topic, currentStartDate, currentEndDate, radarDaysLimit); 
    }
    
    async function loadOutliers(topic) {
        // This function is now effectively disabled by hiding its container
        // document.getElementById('outliers-list').innerHTML = '<div class="loading-indicator">Loading outliers...</div>';
        // const data = await fetchData(`/api/dashboard/semantic-outliers/${encodeURIComponent(topic)}?${outlierParams}`);
        // renderOutliers(data);
        console.log("Semantic outliers loading skipped as section is hidden.");
    }

    // Modified loadArticles to respect global date filters
    async function loadArticles(topic, page = 1, startDate = null, endDate = null) {
        currentPage = page;
        document.getElementById('articles-list').innerHTML = '<div class="loading-indicator">Loading articles...</div>';
        document.getElementById('articles-pagination').innerHTML = ''; // Clear pagination while loading

        // Use the provided date range or fall back to global date filters
        const effectiveStartDate = startDate || currentStartDate;
        const effectiveEndDate = endDate || currentEndDate;

        let apiUrl = `/api/dashboard/articles/${encodeURIComponent(topic)}?page=${page}&per_page=${articlesPerPage}`;
        
        // Always include date range if available
        if (effectiveStartDate && effectiveEndDate) {
            console.log(`Filtering articles by date range: ${effectiveStartDate} to ${effectiveEndDate}`);
            apiUrl += `&start_date=${effectiveStartDate}&end_date=${effectiveEndDate}`;
            
            // Update the section title to reflect filtering
            if (!startDate && !endDate) { // Only update if using global filters
                const daysDiff = Math.round((new Date(effectiveEndDate) - new Date(effectiveStartDate)) / (1000 * 60 * 60 * 24));
                let periodText = `${daysDiff} days`;
                if (daysDiff === 1) periodText = "24 hours";
                else if (daysDiff === 7) periodText = "1 week";
                else if (daysDiff === 30) periodText = "1 month";
                else if (daysDiff === 90) periodText = "3 months";
                else if (daysDiff === 365) periodText = "1 year";
                
                document.getElementById('articles-section-title').textContent = `Articles (Last ${periodText})`;
            }
        } else {
            document.getElementById('articles-section-title').textContent = 'Articles (All time)';
        }

        // If only filtering by specific date, hide pagination, otherwise show it
        document.getElementById('articles-pagination').style.display = (startDate && endDate && startDate === endDate) ? 'none' : 'flex';

        try {
            const data = await fetchData(apiUrl);
            renderArticles(data);
        } catch (error) {
            console.error("Error loading articles:", error);
            document.getElementById('articles-list').innerHTML = 
                '<div class="alert alert-danger">Failed to load articles. Please try again later.</div>';
        }
    }

    async function loadKeyArticles(topic, date_range) {
        console.log(`[loadKeyArticles] Called for topic: ${topic}, date_range: ${date_range}`);
        const targetDiv = document.getElementById('key-articles-list'); 
        if (!targetDiv) {
            console.error("[loadKeyArticles] Target div 'key-articles-list' not found!");
            return;
        }
        targetDiv.innerHTML = '<div class="loading-indicator">Loading top stories...</div>';
        
        const topKSelect = document.getElementById('topStoriesCountSelect');
        const topK = topKSelect ? topKSelect.value : 5; // Default to 5 if not found

        let apiUrl = `/api/dashboard/key-articles/${encodeURIComponent(topic)}?top_k=${topK}`;
        
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            apiUrl += `&start_date=${start}&end_date=${end}`;
        } else if (date_range) { 
             console.warn("[loadKeyArticles] date_range format for API might be incorrect if not start,end. API /key-articles/ expects start_date & end_date or uses its default.")
        }
        
        console.log(`[loadKeyArticles] Attempting to fetch from: ${apiUrl}`);
        try {
            const data = await fetchData(apiUrl);
            console.log("[loadKeyArticles] Data received:", data);
            renderKeyArticles(data);
        } catch (error) {
            console.error("[loadKeyArticles] Error fetching or rendering key articles:", error);
            targetDiv.innerHTML = '<div class="text-danger p-2 small">Failed to load highlights.</div>';
        }
    }

    async function loadGeneratedInsights(topic) {
        // Target the specific flex container for trend insights
        const trendInsightsFlexContainer = document.getElementById('trend-insights-flex-container');
        if (!trendInsightsFlexContainer) {
            console.error("Critical Error: #trend-insights-flex-container not found!");
            return;
        }
        trendInsightsFlexContainer.innerHTML = '<div class="loading-indicator w-100 text-center">Loading trend insights...</div>';
        
        let insightsParams = '';
        if (currentStartDate && currentEndDate) {
            insightsParams = `?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        } // Use current date range
        const data = await fetchData(`/api/dashboard/generated-insights/${encodeURIComponent(topic)}${insightsParams}`);
        renderGeneratedInsights(data);
    }

    async function loadLatestPodcast(topic) {
        // Ensure the target is the main player section for today's briefing
        document.getElementById('latest-podcast-section').innerHTML = '<div class="loading-indicator">Loading today\'s briefing...</div>';
        const data = await fetchData(`/api/dashboard/latest-podcast/${encodeURIComponent(topic)}`);
        renderLatestPodcast(data); // This function populates #latest-podcast-section
    }

    async function loadArticleInsights(topic) {
        const container = document.getElementById('article-insights-flex-container');
        container.innerHTML = '<div class="loading-indicator w-100 text-center">Loading article insights...</div>';
        // Construct URL with date range if available
        let insightsParams = '';
        if (currentStartDate && currentEndDate) {
            insightsParams = `?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        } // Use current date range for fetching relevant articles for insights
        const data = await fetchData(`/api/dashboard/article-insights/${encodeURIComponent(topic)}${insightsParams}`);
        renderArticleInsights(data);
    }

    function renderArticleInsights(themed_insights) { // Renamed data to themed_insights for clarity
        const container = document.getElementById('article-insights-flex-container');
        container.innerHTML = ''; // Clear loading/previous

        if (!themed_insights || themed_insights.length === 0) {
            container.innerHTML = '<div class="text-muted p-2 small w-100 text-center">No thematic article insights available for this period.</div>';
            return;
        }

        themed_insights.forEach((theme_item, index) => {
            const card = document.createElement('div');
            card.className = 'insight-item-card'; // Reuse styling
            
            let articlesHtml = '<ul class="list-unstyled mt-2 mb-0 small">';
            if (theme_item.articles && theme_item.articles.length > 0) {
                theme_item.articles.forEach(article => {
                    const pubDate = article.publication_date ? new Date(article.publication_date).toLocaleDateString() : 'N/A';
                    articlesHtml += `
                        <li class="mb-1">
                            <a href="${article.uri}" target="_blank" rel="noopener" class="text-decoration-none">
                                ${article.title || 'Untitled Article'}
                            </a>
                            <small class="text-muted d-block">${article.news_source || 'Unknown Source'} - ${pubDate}</small>
                            ${article.short_summary ? `<p class="mb-0 fst-italic text-muted">${article.short_summary}</p>` : ''}
                        </li>`;
                });
            } else {
                articlesHtml += '<li class="text-muted">No specific articles listed for this theme.</li>';
            }
            articlesHtml += '</ul>';

            card.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0 text-primary">${theme_item.theme_name || 'Unnamed Theme'}</h6>
                    <span class="badge bg-warning text-dark">Theme</span> {# Using a yellow badge for themes #}
                </div>
                <p class="mb-1 small">${theme_item.theme_summary || 'No summary provided for this theme.'}</p>
                ${articlesHtml}
            `;
            container.appendChild(card);
        });
    }

    async function loadCategoryInsights(topic) {
        const container = document.getElementById('category-insights-flex-container');
        container.innerHTML = '<div class="loading-indicator w-100 text-center">Loading category insights...</div>';
        // Construct URL with date range if available
        let insightsParams = '';
        if (currentStartDate && currentEndDate) {
            insightsParams = `?start_date=${currentStartDate}&end_date=${currentEndDate}`;
        }
        const data = await fetchData(`/api/dashboard/category-insights/${encodeURIComponent(topic)}${insightsParams}`);
        renderCategoryInsights(data);
    }

    function renderCategoryInsights(categories) {
        const container = document.getElementById('category-insights-flex-container');
        container.innerHTML = ''; // Clear loading/previous

        if (!categories || categories.length === 0) {
            container.innerHTML = '<div class="text-muted p-2 small w-100 text-center">No category distribution data available for this period.</div>';
            return;
        }

        categories.forEach(cat_item => {
            const card = document.createElement('div');
            card.className = 'insight-item-card'; 

            const analyzeLink = `/vector-analysis?category=${encodeURIComponent(cat_item.category)}&start_date=${currentStartDate || ''}&end_date=${currentEndDate || ''}`;

            card.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="mb-0 text-primary">${cat_item.category}</h6>
                    <span class="badge bg-success text-dark">Category</span>
                </div>
                <p class="mb-1 small"><strong>Article Count:</strong> ${cat_item.article_count}</p>
                <p class="mb-2 small fst-italic">${cat_item.insight_text || 'Further analysis for this category will be available soon.'}</p>
                <a href="${analyzeLink}" class="btn btn-sm btn-outline-primary mt-auto" target="_blank">
                    <i class="fas fa-chart-pie me-1"></i> Analyze Category
                </a>
            `;
            container.appendChild(card);
        });
    }

    // --- Event Listeners ---
    
    document.getElementById('topicSelector').addEventListener('change', function(e) {
        const selectedTopic = e.target.value;
        if (selectedTopic) {
            loadDashboardData(selectedTopic);
        }
    });

    // Date range preset buttons
    document.querySelectorAll('.date-preset-btn').forEach(button => {
        button.addEventListener('click', function(e) {
            // Remove active class from all buttons
            document.querySelectorAll('.date-preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Add active class to clicked button
            this.classList.add('active');
            
            // Get days from data attribute
            const days = parseInt(this.dataset.days);
            
            // Calculate new date range
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - days);
            
            // Update current date range - keep consistent with formatDate output format
            currentStartDate = formatDate(start);
            currentEndDate = formatDate(end);
            
            // Get selected topic and reload data
            const selectedTopic = document.getElementById('topicSelector').value;
            if (selectedTopic) {
                loadDashboardData(selectedTopic);
                
                // Dispatch a custom event that components like the map can listen for
                document.dispatchEvent(new CustomEvent('dateRangeChanged', { 
                    detail: { 
                        startDate: currentStartDate, 
                        endDate: currentEndDate,
                        dateRange: getCurrentDateRange()
                    }
                }));
            }
        });
    });

    // Custom Date Range Apply Button - Effectively hidden, but listener remains for now
    document.getElementById('applyDateRangeBtn').addEventListener('click', function() {
        const startDateVal = document.getElementById('startDateInput').value;
        const endDateVal = document.getElementById('endDateInput').value;
        
        if (startDateVal && endDateVal && startDateVal <= endDateVal) {
            currentStartDate = startDateVal;
            currentEndDate = endDateVal;
             // Deactivate preset buttons when custom range is applied
            document.querySelectorAll('.date-preset-btn').forEach(btn => btn.classList.remove('active'));
            // Trigger data reload
            const selectedTopic = document.getElementById('topicSelector').value;
            if (selectedTopic) {
                loadTrends(selectedTopic);
                loadOutliers(selectedTopic);
                loadGeneratedInsights(selectedTopic);
                loadLatestPodcast(selectedTopic);
                loadPreviousPodcasts(selectedTopic);
                loadArticleInsights(selectedTopic); // <-- Add this call
                loadCategoryInsights(selectedTopic); // <-- Add this call
            }
        } else {
            alert('Please select a valid date range.');
        }
    });

    // Add reset button listener
    document.getElementById('reset-article-filter-btn').addEventListener('click', function() {
        const selectedTopic = document.getElementById('topicSelector').value;
        if (selectedTopic) {
            document.getElementById('articles-section-title').textContent = 'Articles';
            this.style.display = 'none'; // Hide reset button
            loadArticles(selectedTopic, 1); // Reload first page, no date filter
        }
    });

    // Fix the tab initialization logic to prevent interference between panels
    document.addEventListener('DOMContentLoaded', () => {
        setDefaultDates(30); // Initialize with default 30 days
        stopTickerUpdates(); 
        updateDateTime(); // Initialize the date-time display
        setInterval(updateDateTime, 60000); // Update every minute

        // Event listener for the new top stories count select
        const topStoriesCountSelect = document.getElementById('topStoriesCountSelect');
        if (topStoriesCountSelect) {
            // Load saved value or set default
            const savedTopK = localStorage.getItem('topStoriesCount');
            if (savedTopK) {
                topStoriesCountSelect.value = savedTopK;
            }

            topStoriesCountSelect.addEventListener('change', function() {
                localStorage.setItem('topStoriesCount', this.value);
                const selectedTopic = getCurrentTopic();
                if (selectedTopic) {
                    loadKeyArticles(selectedTopic, getCurrentDateRange()); // Reload top stories with new count
                }
            });
        }

        // Manually initialize Bootstrap tabs with improved handler
        document.querySelectorAll('.nav-tabs .nav-link').forEach(tabLink => {
            tabLink.addEventListener('click', function(e) {
                e.preventDefault();
                
                // Get the parent tab element and its content container
                const tabContainer = this.closest('.nav-tabs');
                const tabContentId = tabContainer.getAttribute('aria-controls') || 
                                     tabContainer.getAttribute('id').replace('Tab', 'TabContent');
                
                // Only affect tabs within the same container
                const tabContent = document.getElementById(tabContentId) || 
                                   tabContainer.nextElementSibling;
                
                if (!tabContent) {
                    console.error("Tab content container not found for tab:", this.id);
                    return;
                }
                
                const targetId = this.getAttribute('data-bs-target').substring(1); // Remove leading #
                const targetTab = document.getElementById(targetId);
                
                console.log(`Tab clicked: ${this.id}, target: ${targetId}, in container: ${tabContentId}`);
                
                // Hide only the sibling tab panes in THIS tab container
                tabContent.querySelectorAll('.tab-pane').forEach(tabPane => {
                    tabPane.classList.remove('show', 'active');
                });
                
                // Show target tab content
                if (targetTab) {
                    targetTab.classList.add('show', 'active');
                    
                    // Special handling for lexical analysis tab
                    if (this.id === 'vector-analysis-tab') {
                        console.log("Lexical analysis tab clicked - refreshing visualizations");
                        // Force display for the tab to make sure it's visible
                        targetTab.style.display = 'block';
                        
                        // Then refresh visualizations
                        const selectedTopic = document.getElementById('topicSelector').value;
                        if (selectedTopic) {
                            // Wait a tiny bit to ensure DOM is ready
                            setTimeout(() => {
                                console.log("Refreshing lexical analysis visualizations...");
                                refreshLexicalAnalysis(selectedTopic);
                            }, 200);
                        }
                    }
                } else {
                    console.error(`Target tab not found: ${targetId}`);
                }
                
                // Update active state on tab links only in the current tab set
                tabContainer.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                    link.setAttribute('aria-selected', 'false');
                });
                
                this.classList.add('active');
                this.setAttribute('aria-selected', 'true');
            });
        });

        const savedTopic = localStorage.getItem(DEFAULT_TOPIC_KEY);
        const topicSelector = document.getElementById('topicSelector');
        
        // Check if topicSelector has options loaded before trying to set value
        if (topicSelector.options.length > 1 && savedTopic) {
            // Check if the saved topic is a valid option
            let topicExists = false;
            for (let i = 0; i < topicSelector.options.length; i++) {
                if (topicSelector.options[i].value === savedTopic) {
                    topicExists = true;
                    break;
                }
            }
            if (topicExists) {
                topicSelector.value = savedTopic;
                // Manually trigger the change event to load data for the saved topic
                topicSelector.dispatchEvent(new Event('change')); 
            }
        }
    });

    async function updateTicker() {
        const selectedTopic = document.getElementById('topicSelector').value;
        if (!selectedTopic) return;

        const tickerContainer = document.querySelector('#newsTicker .ticker-move');
        if (!tickerContainer) return;

        try {
            const data = await fetchData(`/api/dashboard/articles/${encodeURIComponent(selectedTopic)}?page=1&per_page=7&sort_by=submission_date&sort_order=desc`);
            if (data && data.items && data.items.length > 0) {
                let tickerContentHtml = '<span class="ticker-prefix">BREAKING</span> ';
                
                // Create alternating ticker items
                data.items.forEach((article, index) => {
                    const title = (article.title || 'Untitled').trim();
                    const safeTitle = title.replace(/[<>"&']/g, function (match) {
                        return {
                            '<': '&lt;',
                            '>': '&gt;',
                            '"': '&quot;',
                            '&': '&amp;',
                            "'": '&#039;'
                        }[match];
                    });
                    const summaryTooltip = article.summary ? article.summary.substring(0, 150).replace(/[<>"&']/g, function(m){return {'<':'&lt;','>':'&gt;','"':'&quot;','&':'&amp;',"'":'&#039;'}[m];}) + (article.summary.length > 150 ? '...' : '') : 'No summary available';
                    
                    // Alternate between pink and white styles
                    const itemClass = index % 2 === 0 ? 'ticker-item-pink' : 'ticker-item-white';
                    
                    const articleLink = article.uri ? 
                        `<a href="${article.uri}" target="_blank" rel="noopener noreferrer" title="${summaryTooltip}">${safeTitle}</a>` : 
                        `<span title="${summaryTooltip}">${safeTitle}</span>`;
                    
                    tickerContentHtml += `<span class="ticker-item ${itemClass}">${articleLink}</span>`;
                    
                    // Add separator only between items, not after the last item
                    if (index < data.items.length - 1) {
                        tickerContentHtml += '<span class="ticker-separator"></span>';
                    }
                });
                
                tickerContainer.style.animation = 'none';
                await new Promise(resolve => setTimeout(resolve, 50)); 
                
                tickerContainer.innerHTML = tickerContentHtml;
                
                tickerContainer.style.animation = ''; 

                document.getElementById('newsTicker').style.display = 'block';
            } else {
                 document.getElementById('newsTicker').style.display = 'none';
            }
        } catch (error) {
            console.error('Error updating ticker:', error);
            document.getElementById('newsTicker').style.display = 'none';
        }
    }

    function startTickerUpdates() {
        stopTickerUpdates(); // Clear any existing interval
        updateTicker(); // Update immediately
        tickerIntervalId = setInterval(updateTicker, TICKER_UPDATE_INTERVAL);
        console.log('Started ticker updates, interval ID:', tickerIntervalId);
    }

    function stopTickerUpdates() {
        if (tickerIntervalId) {
            clearInterval(tickerIntervalId);
            console.log('Stopped ticker updates, interval ID:', tickerIntervalId);
            tickerIntervalId = null;
        }
    }

    function renderTopTagsList(data) {
        const container = document.getElementById('topTagsList');
        if (!container) {
            console.error("Top tags list container not found");
            return;
        }
        
        if (!data || data.length === 0) {
            container.innerHTML = '<div class="text-muted p-2">No tag data available.</div>';
            return;
        }
        
        // Create a simple badge list of top tags
        let html = '<div class="d-flex flex-wrap">';
        
        // Sort data by count (descending)
        const sortedData = [...data].sort((a, b) => b.count - a.count);
        
        // Create badge for each tag
        sortedData.forEach(tag => {
            const badgeClass = tag.count > 10 ? 'bg-primary' : 
                               tag.count > 5 ? 'bg-info' : 'bg-secondary';
            html += `<span class="badge ${badgeClass} me-1 mb-1">${tag.tag} (${tag.count})</span>`;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    function renderWordCloud(data) {
        console.log("renderWordCloud (WordCloud2.js) received data:", data);

        const container = document.getElementById('wordCloudContainer');
        const loadingIndicator = document.getElementById('wordcloud-loading');

        if (loadingIndicator) {
            loadingIndicator.classList.add('d-none');
        }
        container.innerHTML = ''; // Clear previous content (e.g., D3 SVG or fallback)
        container.style.display = 'block'; // Ensure container is visible

        if (!data || data.length === 0) {
            console.warn("WordCloud2.js: No data to display.");
            container.innerHTML = '<div class="text-muted p-2">No word frequency data available for cloud.</div>';
            return;
        }

        // Transform data for WordCloud2.js: needs [['word', size], ...]
        // We can use 'count' directly as size or scale it.
        const listData = data.map(d => [String(d.word).trim(), d.count]);
        console.log("Data formatted for WordCloud2.js:", listData);

        if (listData.length === 0) {
            container.innerHTML = '<div class="text-muted p-2">No valid words for cloud after formatting.</div>';
            return;
        }

        // Create a canvas element for WordCloud2.js if it doesn't exist, or ensure the container is suitable
        // WordCloud2.js can draw on an existing canvas or an element directly.
        // For simplicity, let's allow it to draw directly on the container div.
        // Ensure container has relative/absolute positioning if WordCloud2 creates absolutely positioned elements.
        container.style.position = 'relative'; // Important for WordCloud2.js positioning
        container.style.width = container.clientWidth > 0 ? `${container.clientWidth}px` : '300px'; // Ensure width is set
        container.style.height = container.clientHeight > 0 ? `${container.clientHeight}px` : '280px'; // Ensure height is set

        try {
            if (typeof WordCloud !== 'undefined') {
                WordCloud(container, { 
                    list: listData,
                    gridSize: Math.round(16 * container.clientWidth / 1024),
                    weightFactor: function (size) {
                        // Scale font size: make smaller counts more visible, cap larger ones
                        return Math.pow(size, 0.7) * (container.clientWidth / 300); // Experiment with scaling
                    },
                    fontFamily: 'sans-serif',
                    color: 'random-dark',
                    hover: window.drawBox, // Example hover callback (optional)
                    click: function(item, dimension, event) {
                        console.log(item[0] + ': ' + item[1]);
                        // Add to search bar: item[0] is the word
                         const searchInput = document.getElementById('searchInput');
                         searchInput.value = (searchInput.value + ' ' + item[0]).trim();
                         runSearch(); // Optional: trigger search immediately
                    },
                    backgroundColor: '#ffffff', // Match dashboard section background
                    minRotation: -Math.PI / 4, // -45 degrees
                    maxRotation: Math.PI / 4,  // 45 degrees
                    rotationSteps: 2,       // 0, 45/2, 45 or 0, -45/2, -45
                    shuffle: true,
                    rotateRatio: 0.5, // 50% of words will be rotated
                    shape: 'circle', // or 'cardioid', 'diamond', 'triangle-forward', etc.
                    minSize: 5 // Minimum font size
                });
                console.log("WordCloud2.js initiated.");
            } else {
                console.error("WordCloud2.js library is not loaded!");
                renderWordCloudFallback(data, container); // Use existing fallback
            }
        } catch (error) {
            console.error("Error initializing WordCloud2.js:", error);
            renderWordCloudFallback(data, container); // Use existing fallback on error
        }
    }

    // Fallback function remains the same, it uses the original `data` format
    function renderWordCloudFallback(data, container) {
        // Simple visual fallback if WordCloud2.js fails
        let html = `
            <div class="alert alert-warning mb-2">Unable to render interactive word cloud.</div>
            <div class="p-2">
                <h6 class="mb-2">Word Frequency:</h6>
                <div class="word-cloud-fallback">
        `;
        
        // Sort data by count (descending)
        const sortedData = [...data].sort((a, b) => b.count - a.count);
        
        // Create styled text for each word
        sortedData.forEach(item => { // Changed from tag to item
            const fontSize = 10 + (item.count * 1.5); // Scale font size based on count
            const fontWeight = item.count > 10 ? 'bold' : 'normal';
            const opacity = 0.5 + (item.count / 20); // Scale opacity
            
            html += `<span style="font-size: ${fontSize}px; font-weight: ${fontWeight}; opacity: ${opacity}; display: inline-block; margin: 5px; color: #007bff;">${item.word}</span>`; // Changed from tag.tag to item.word
        });
        
        html += '</div></div>';
        container.innerHTML = html;
    }

    // Function to refresh just the lexical analysis visualizations
    async function refreshLexicalAnalysis(topic) {
        console.log("Refreshing lexical analysis for:", topic);
        
        // Check if elements exist before using them
        const tagsLoadingEl = document.getElementById('tags-loading');
        const wordcloudLoadingEl = document.getElementById('wordcloud-loading');
        
        if (tagsLoadingEl) tagsLoadingEl.classList.remove('d-none');
        if (wordcloudLoadingEl) wordcloudLoadingEl.classList.remove('d-none');
        
        // Build URL with potential date range
        let trendsParams = '';
        if (currentStartDate && currentEndDate) {
            trendsParams = `&start_date=${currentStartDate}&end_date=${currentEndDate}`;
        }
        
        try {
            // Fetch tag data and render visualizations
            const tagsData = await fetchData(`/api/dashboard/top-tags/${encodeURIComponent(topic)}?${trendsParams}`);
            console.log("Tags Data for Lexical Analysis:", tagsData);
            
            // Clear previous visualizations - check if elements exist first
            const tagsContainer = document.getElementById('tagsCloudContainer');
            const wordCloudContainer = document.getElementById('wordCloudContainer');
            const topTagsList = document.getElementById('topTagsList');
            
            if (tagsContainer) {
                tagsContainer.innerHTML = '';
                tagsContainer.style.display = 'block';
            } else {
                console.error("Tags cloud container not found!");
            }
            
            if (wordCloudContainer) {
                wordCloudContainer.innerHTML = '';
                wordCloudContainer.style.display = 'block';
            }
            
            if (topTagsList) {
                topTagsList.innerHTML = '';
            }
            
            // Only render visualizations if data exists
            if (tagsData && tagsData.length > 0) {
                renderTagsCloud(tagsData);
                renderTopTagsList(tagsData);
                // renderWordCloud(tagsData); // WordCloud is now fetched separately in loadTrends and here if needed for refresh
            } else {
                if (tagsContainer) tagsContainer.innerHTML = '<div class="text-muted p-2">No tag data available.</div>';
                // if (wordCloudContainer) wordCloudContainer.innerHTML = '<div class="text-muted p-2">No word data available.</div>';
                if (topTagsList) topTagsList.innerHTML = '<div class="text-muted p-2">No tags available.</div>';
            }

            // Refresh Word Cloud separately
            // const wordCloudContainer = document.getElementById('wordCloudContainer'); // Removed const declaration
            let wordCloudContainerEl = document.getElementById('wordCloudContainer'); // Use let and a different name or ensure it's used correctly
            const wordcloudLoadingEl = document.getElementById('wordcloud-loading');
            if (wordcloudLoadingEl) wordcloudLoadingEl.classList.remove('d-none');
            // if (wordCloudContainer) wordCloudContainer.style.display = 'none'; // Original line, commented out for safety
            if (wordCloudContainerEl) wordCloudContainerEl.style.display = 'none'; // Use the new variable name

            const wordFrequencyData = await fetchData(`/api/dashboard/word-frequency/${encodeURIComponent(topic)}?${trendsParams.replace(/^&/, '?')}`);
            console.log("Refreshed Word Frequency Data:", wordFrequencyData);
            if (wordFrequencyData && wordFrequencyData.length > 0) {
                 if (wordCloudContainerEl) wordCloudContainerEl.innerHTML = ''; // Clear before rendering
                renderWordCloud(wordFrequencyData);
            } else {
                // if (wordCloudContainer) wordCloudContainer.innerHTML = '<div class="text-muted p-2">No word data available.</div>';
                if (wordCloudContainerEl) wordCloudContainerEl.innerHTML = '<div class="text-muted p-2">No word data available.</div>';
            }

        } catch (error) {
            console.error("Error refreshing lexical analysis:", error);
            // Show error messages in containers
            const containers = [
                document.getElementById('tagsCloudContainer'),
                document.getElementById('wordCloudContainer'),
                document.getElementById('topTagsList')
            ];
            
            containers.forEach(container => {
                if (container) {
                    container.innerHTML = '<div class="alert alert-danger">Error loading data. Please try again.</div>';
                }
            });
        }
    }

    // New function to render Radar Chart
    async function renderRadarChart(topic, startDate, endDate, daysLimit) {
        const radarLoading = document.getElementById('radar-loading');
        const radarChartEl = document.getElementById('radarChart');
        const radarContainer = document.getElementById('radarChartContainer');

        if (radarLoading) radarLoading.classList.remove('d-none');
        
        // Check if elements exist before accessing
        if (radarChartInstance) radarChartInstance.destroy();
        
        // Make sure the container exists before trying to update it
        if (!radarContainer) {
            console.error("Radar chart container not found: #radarChartContainer");
            return;
        }
        
        // Safe handling of the chart element
        if (radarChartEl) radarChartEl.style.display = 'none';

        let queryParams = new URLSearchParams();
        if (startDate && endDate) {
            queryParams.append('start_date', startDate);
            queryParams.append('end_date', endDate);
        } else {
            queryParams.append('days_limit', daysLimit.toString());
        }
        console.log(`Fetching radar data with params: ${queryParams.toString()}`);
        const data = await fetchData(`/api/dashboard/radar-chart-data/${encodeURIComponent(topic)}?${queryParams.toString()}`);
        console.log("Radar Chart Data Received:", data);

        if (radarLoading) radarLoading.classList.add('d-none');
        
        if (!data || !data.labels || data.labels.length === 0 || !data.datasets || data.datasets.length === 0) {
            radarContainer.innerHTML = '<div class="text-muted p-2 text-center small">No data available for radar chart.</div>';
            return;
        }
        
        // Make sure we recreate the canvas if it doesn't exist
        if (!document.getElementById('radarChart')) {
            radarContainer.innerHTML = '<canvas id="radarChart"></canvas>';
        }
        
        // Get the canvas element again (it might have been recreated)
        const radarChart = document.getElementById('radarChart');
        if (radarChart) {
            radarChart.style.display = 'block';
        } else {
            console.error("Could not find or create radar chart canvas");
            return;
        }

        const ctx = radarChart.getContext('2d');
        radarChartInstance = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: data.labels, // Future signals
                datasets: data.datasets.map(dataset => ({
                    ...dataset, // Spread existing dataset properties (label, data, colors, customData)
                    fill: true, // Explicitly set fill to true, works with backgroundColor alpha
                    pointRadius: dataset.customData.map(cd => Math.max(3, Math.min(15, Math.sqrt(cd.total_articles || 1) * 2))), // Array of radii based on total_articles
                    pointHoverRadius: dataset.customData.map(cd => Math.max(5, Math.min(20, Math.sqrt(cd.total_articles || 1) * 2.5))),
                    pointBackgroundColor: dataset.backgroundColor.replace(/0\.6\)$/, '0.8)'), // Slightly more opaque points
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                elements: {
                    line: { borderWidth: 2 },
                    point: { radius: 3, hoverRadius: 5 } 
                },
                scales: {
                    r: {
                        angleLines: { display: true },
                        suggestedMin: 0,
                        pointLabels: { font: { size: 10 } }
                        // suggestedMax: can be set if max count is known or to provide padding
                    }
                },
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.r !== null) {
                                    label += context.parsed.r + ' articles';
                                }
                                // Access customData for more details
                                const customInfo = context.dataset.customData[context.dataIndex];
                                if (customInfo && customInfo.tti_breakdown) {
                                    label += ' (TTI: ';
                                    const ttiDetails = Object.entries(customInfo.tti_breakdown)
                                        .map(([tti, count]) => `${tti}: ${count}`)
                                        .join(', ');
                                    label += ttiDetails + ')';
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    // Add event listener for the volumeStackBy dropdown
    document.getElementById('volumeStackBy').addEventListener('change', function() {
        const selectedTopic = document.getElementById('topicSelector').value;
        if (selectedTopic) {
            // Reload only the volume chart with the new stack_by parameter
            const stackBy = this.value;
            let queryParams = new URLSearchParams();
            if (currentStartDate && currentEndDate) {
                queryParams.append('start_date', currentStartDate);
                queryParams.append('end_date', currentEndDate);
            }
            queryParams.append('stack_by', stackBy);
            
            document.getElementById('volume-loading').classList.remove('d-none');
            document.getElementById('volumeChart').style.display = 'none';

            fetchData(`/api/dashboard/volume-over-time/${encodeURIComponent(selectedTopic)}?${queryParams.toString()}`)
                .then(data => renderVolumeChart(data, stackBy));
        }
    });

    // Update the current date and time in the network header
    function updateDateTime() {
        const now = new Date();
        const options = { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        };
        document.getElementById('current-date-time').textContent = now.toLocaleDateString('en-US', options).replace(',', ' at').replace(/(\d+):(\d+)/, '$1:$2');
    }

    // Update the current date time in the header
    function updateCurrentDateTime() {
        const now = new Date();
        const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
        document.getElementById('current-date-time').textContent = now.toLocaleDateString('en-US', options);
    }
    updateCurrentDateTime();
    setInterval(updateCurrentDateTime, 60000); // Update every minute

    // Topic and Date Range Management
    function getCurrentTopic() {
        return document.getElementById('topicSelector').value || null;
    }

    function getCurrentDateRange() {
        if (currentStartDate && currentEndDate) {
            // Check if currentStartDate is already a string in YYYY-MM-DD format
            if (typeof currentStartDate === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(currentStartDate)) {
                return `${currentStartDate},${currentEndDate}`;
            }
            // If it's a Date object, convert it to ISO string and split
            try {
                const startISO = currentStartDate instanceof Date ? 
                    currentStartDate.toISOString().split('T')[0] : currentStartDate;
                const endISO = currentEndDate instanceof Date ? 
                    currentEndDate.toISOString().split('T')[0] : currentEndDate;
                return `${startISO},${endISO}`;
            } catch (e) {
                console.error("Date conversion error:", e);
                // If there's an error, try to return whatever we have as fallback
                return `${currentStartDate},${currentEndDate}`;
            }
        }
        return '';
    }

    // Dashboard Data Loading Function
    async function loadDashboardData(topic) {
        if (!topic) return;
        // Clear reset filter button
        document.getElementById('reset-article-filter-btn').style.display = 'none';

        // Update dashboard title
        document.getElementById('dashboard-title').innerText = `${topic} Dashboard`;
        document.title = `${topic} Dashboard - Aunoo`;

        // Set date range if not set
        if (!currentStartDate || !currentEndDate) {
            // Default to last 30 days
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - 30);
            currentStartDate = formatDate(start);
            currentEndDate = formatDate(end);
        }

        // Form the date range string - use the helper function to handle both string and Date objects
        const date_range = getCurrentDateRange();
        
        // Show loading indicators for charts
        document.querySelectorAll('.loading-indicator').forEach(el => {
            if (el.parentElement) el.parentElement.appendChild(el);
            el.style.display = 'block';
            el.classList.remove('d-none');
        });

        // Load data from various endpoints
        loadArticles(topic, 1);
        loadVolumeData(topic, date_range);
        loadSentimentData(topic, date_range);
        loadKeyArticles(topic, date_range);
        loadOutliers(topic, date_range);
        loadTagsData(topic, date_range);
        loadWordCloud(topic, date_range);
        loadRadarChart(topic, date_range);
        loadTickerData(topic);
        loadLatestPodcast(topic);
        loadPreviousPodcasts(topic);
        loadTrendInsights(topic);
        loadArticleInsights(topic, date_range);
        loadCategoryInsights(topic, date_range);
        
        // Initialize the global news map
        if (typeof initializeWorldMap === 'function') {
            initializeWorldMap();
        }
        
        // Store the selected topic in localStorage
        localStorage.setItem(DEFAULT_TOPIC_KEY, topic);
        
        // Trigger a custom event for topicChanged that our components can listen to
        document.dispatchEvent(new CustomEvent('topicChanged', { 
            detail: { topic: topic, dateRange: date_range }
        }));
    }

    // Load volume data
    async function loadVolumeData(topic, date_range) {
        const volumeQueryParams = new URLSearchParams();
        const stackBy = document.getElementById('volumeStackBy').value || 'category';
        
        // Parse date_range if it's in the format 'start,end'
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            volumeQueryParams.append('start_date', start);
            volumeQueryParams.append('end_date', end);
        }
        
        volumeQueryParams.append('stack_by', stackBy);
        
        document.getElementById('volume-loading').classList.remove('d-none');
        document.getElementById('volumeChart').style.display = 'none';
        
        const volumeData = await fetchData(`/api/dashboard/volume-over-time/${encodeURIComponent(topic)}?${volumeQueryParams.toString()}`);
        renderVolumeChart(volumeData, stackBy);
    }
    
    // Load sentiment data
    async function loadSentimentData(topic, date_range) {
        const sentimentQueryParams = new URLSearchParams();
        
        // Parse date_range if it's in the format 'start,end'
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            sentimentQueryParams.append('start_date', start);
            sentimentQueryParams.append('end_date', end);
        }
        
        document.getElementById('sentiment-loading').classList.remove('d-none');
        document.getElementById('sentimentChart').style.display = 'none';
        
        const sentimentData = await fetchData(`/api/dashboard/sentiment-over-time/${encodeURIComponent(topic)}?${sentimentQueryParams.toString()}`);
        renderSentimentChart(sentimentData);
    }
    
    // Load tags data
    async function loadTagsData(topic, date_range) {
        const tagsQueryParams = new URLSearchParams();
        
        // Parse date_range if it's in the format 'start,end'
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            tagsQueryParams.append('start_date', start);
            tagsQueryParams.append('end_date', end);
        }
        
        const tagsLoading = document.getElementById('tags-loading');
        if (tagsLoading) tagsLoading.classList.remove('d-none');
        
        const tagsData = await fetchData(`/api/dashboard/top-tags/${encodeURIComponent(topic)}?${tagsQueryParams.toString()}`);
        renderTagsCloud(tagsData);
        renderTopTagsList(tagsData);
    }
    
    // Load word cloud data
    async function loadWordCloud(topic, date_range) {
        const wordCloudQueryParams = new URLSearchParams();
        
        // Parse date_range if it's in the format 'start,end'
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            wordCloudQueryParams.append('start_date', start);
            wordCloudQueryParams.append('end_date', end);
        }
        
        const wordcloudLoading = document.getElementById('wordcloud-loading');
        if (wordcloudLoading) wordcloudLoading.classList.remove('d-none');
        
        const wordCloudData = await fetchData(`/api/dashboard/word-frequency/${encodeURIComponent(topic)}?${wordCloudQueryParams.toString()}`);
        renderWordCloud(wordCloudData);
    }
    
    // Load radar chart data
    async function loadRadarChart(topic, date_range) {
        const radarQueryParams = new URLSearchParams();
        
        // Parse date_range if it's in the format 'start,end'
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            renderRadarChart(topic, start, end, 30); // Default daysLimit to 30 if using date range
        } else {
            renderRadarChart(topic, null, null, 30); // Default to 30 days if no date range
        }
    }
    
    // Load ticker data
    async function loadTickerData(topic) {
        await updateTicker();
        startTickerUpdates();
    }
    
    // Load trend insights data
    async function loadTrendInsights(topic, date_range) {
        const insightsQueryParams = new URLSearchParams();
        
        // Parse date_range if it's in the format 'start,end'
        if (date_range && date_range.includes(',')) {
            const [start, end] = date_range.split(',');
            insightsQueryParams.append('start_date', start);
            insightsQueryParams.append('end_date', end);
        }
        
        const trendInsightsFlexContainer = document.getElementById('trend-insights-flex-container');
        if (trendInsightsFlexContainer) {
            trendInsightsFlexContainer.innerHTML = '<div class="loading-indicator w-100 text-center">Loading trend insights...</div>';
        }
        
        const data = await fetchData(`/api/dashboard/generated-insights/${encodeURIComponent(topic)}?${insightsQueryParams.toString()}`);
        renderGeneratedInsights(data);
    }

    // Load map data
    async function loadMapData(topic, date_range) {
        if (!topic) return;
        
        const mapElement = document.getElementById('global-news-map');
        if (!mapElement) return;
        
        // Set loading state for map
        mapElement.innerHTML = '<div class="d-flex justify-content-center align-items-center h-100"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading map data...</span></div></div>';
        
        const mapQueryParams = new URLSearchParams();
        if (date_range) {
            mapQueryParams.append('date_range', date_range);
        }
        
        try {
            // Fetch map data from the endpoint
            const mapData = await fetchData(`/api/dashboard/map-activity-data/${encodeURIComponent(topic)}?${mapQueryParams.toString()}`);
            initializeMap(mapData);
            
            // Update UTC time display
            updateUTCTimeDisplay();
        } catch (error) {
            console.error('Error loading map data:', error);
            mapElement.innerHTML = '<div class="alert alert-danger m-3">Failed to load map data</div>';
        }
    }
    
    // Update UTC time display
    function updateUTCTimeDisplay() {
        const now = new Date();
        const utcHours = now.getUTCHours();
        const utcMinutes = now.getUTCMinutes();
        const ampm = utcHours >= 12 ? 'PM' : 'AM';
        const hours12 = utcHours % 12 || 12; // Convert to 12-hour format
        const timeDisplay = `Current UTC: ${hours12}:${utcMinutes.toString().padStart(2, '0')} ${ampm}`;
        
        const utcTimeDisplay = document.getElementById('utc-time-display');
        if (utcTimeDisplay) {
            utcTimeDisplay.textContent = timeDisplay;
        }
    }
    
    // Initialize and render the map
    function initializeMap(mapData) {
        const mapElement = document.getElementById('global-news-map');
        if (!mapElement) return;
        
        // Clear previous map if any
        mapElement.innerHTML = '';
        
        // Check if mapData is valid
        if (!mapData || !Array.isArray(mapData) || mapData.length === 0) {
            mapElement.innerHTML = '<div class="alert alert-info m-3">No map data available for the selected time period</div>';
            return;
        }
        
        // Create map container
        const mapContainer = document.createElement('div');
        mapContainer.style.height = '100%';
        mapContainer.style.width = '100%';
        mapElement.appendChild(mapContainer);
        
        // Initialize map (using Leaflet for example)
        const map = L.map(mapContainer).setView([20, 0], 2);
        
        // Add tile layer (map background)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        
        // Add points to the map
        mapData.forEach(point => {
            // Determine marker color based on activity level
            const markerColor = point.activity_level === 'High' ? 'red' : 
                                point.activity_level === 'Medium' ? 'orange' : 'blue';
            
            // Create marker with popup
            const marker = L.circleMarker([point.latitude, point.longitude], {
                radius: point.activity_level === 'High' ? 8 : point.activity_level === 'Medium' ? 6 : 4,
                fillColor: markerColor,
                color: '#fff',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);
            
            // Add popup with information
            marker.bindPopup(`
                <strong>${point.name}</strong><br>
                Activity: ${point.activity_level}<br>
                ${point.count ? `Articles: ${point.count}` : ''}
            `);
        });
    }

    // Function to open and populate the annotation modal
    async function openAnnotationModal(uri, title, summary, source) {
        document.getElementById('annotationModalArticleTitle').textContent = title;
        document.getElementById('annotationModalArticleSource').textContent = `Source: ${source}`;
        document.getElementById('annotationModalArticleSummary').textContent = summary;
        document.getElementById('annotationModalArticleURI').value = uri;
        document.getElementById('newAnnotationText').value = ''; // Clear previous new annotation

        // Load existing annotations
        await loadAnnotations(uri); // Call the adapted loadAnnotations function

        const modal = new bootstrap.Modal(document.getElementById('articleAnnotationModal'));
        modal.show();
    }

    // --- Annotation Functions (Adapted from database_editor.html) ---
    async function loadAnnotations(articleUri) {
        const annotationsContainer = document.getElementById('existingAnnotationsContainer');
        annotationsContainer.innerHTML = '<p class="text-muted small">Loading annotations...</p>';
        try {
            const doubleEncodedUri = encodeURIComponent(encodeURIComponent(articleUri)); // Match encoding from database_editor
            const response = await fetch(`/api/articles/${doubleEncodedUri}/annotations`);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || 'Failed to load annotations');
            }
            const annotations = await response.json();
            if (annotations && annotations.length > 0) {
                annotationsContainer.innerHTML = annotations.map(annotation => `
                    <div class="card mb-2 annotation-card" data-annotation-id="${annotation.id}">
                        <div class="card-body p-2">
                            <div class="d-flex justify-content-between align-items-start mb-1">
                                <small class="text-muted">
                                    By: ${annotation.author || 'Unknown'} on ${new Date(annotation.created_at).toLocaleString()}
                                    ${annotation.is_private ? '<span class="badge bg-secondary ms-2">Private</span>' : ''}
                                </small>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-primary annotate-edit-btn" title="Edit Annotation"><i class="fas fa-edit"></i></button>
                                    <button class="btn btn-outline-danger annotate-delete-btn" title="Delete Annotation"><i class="fas fa-trash"></i></button>
                                </div>
                            </div>
                            <div class="annotation-content" data-raw-content="${escapeHTML(annotation.content || '')}">
                                ${marked.parse(annotation.content || '')}
                            </div>
                        </div>
                    </div>
                `).join('');
                // Add event listeners for edit/delete buttons on newly rendered annotations
                annotationsContainer.querySelectorAll('.annotate-edit-btn').forEach(btn => {
                    btn.closest('.annotation-card').addEventListener('click', function(event) {
                        if (event.target.closest('.annotate-edit-btn')) {
                             editAnnotation(this.dataset.annotationId);
                        }
                    });
                });
                annotationsContainer.querySelectorAll('.annotate-delete-btn').forEach(btn => {
                     btn.closest('.annotation-card').addEventListener('click', function(event) {
                        if (event.target.closest('.annotate-delete-btn')) {
                            deleteAnnotation(this.dataset.annotationId);
                        }
                    });
                });
            } else {
                annotationsContainer.innerHTML = '<p class="text-muted small">No annotations yet.</p>';
            }
        } catch (error) {
            console.error('Error loading annotations:', error);
            annotationsContainer.innerHTML = `<p class="text-danger small">Could not load annotations: ${error.message}</p>`;
        }
    }

    async function saveAnnotation() {
        const articleUri = document.getElementById('annotationModalArticleURI').value;
        const content = document.getElementById('newAnnotationText').value.trim();
        const isPrivate = document.getElementById('annotationModalIsPrivate') ? document.getElementById('annotationModalIsPrivate').checked : false; // Assuming an ID for a private checkbox

        if (!articleUri || !content) {
            showAlert('Annotation text cannot be empty.', 'warning');
            return;
        }
        try {
            const doubleEncodedUri = encodeURIComponent(encodeURIComponent(articleUri));
            const response = await fetch(`/api/articles/${doubleEncodedUri}/annotations`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: content, is_private: isPrivate, author: 'Analyst' /* TODO: Get current user */ })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || 'Failed to save annotation');
            }
            showAlert('Annotation saved successfully!', 'success');
            document.getElementById('newAnnotationText').value = '';
            if(document.getElementById('annotationModalIsPrivate')) document.getElementById('annotationModalIsPrivate').checked = false;
            await loadAnnotations(articleUri); // Refresh annotations list
        } catch (error) {
            console.error('Error saving annotation:', error);
            showAlert(`Failed to save annotation: ${error.message}`, 'danger');
        }
    }
    // Attach to save button in the main modal (if not already done)
    document.getElementById('saveAnnotationBtn')?.addEventListener('click', saveAnnotation);

    async function editAnnotation(annotationId) {
        const annotationCard = document.querySelector(`.annotation-card[data-annotation-id="${annotationId}"]`);
        if (!annotationCard) return;
        const contentDiv = annotationCard.querySelector('.annotation-content');
        const currentContent = unescapeHTML(contentDiv.dataset.rawContent || '');
        const isPrivate = annotationCard.innerHTML.includes('<span class="badge bg-secondary ms-2">Private</span>'); // Infer from display

        // Store original HTML to revert on cancel
        annotationCard.dataset.originalHtml = contentDiv.innerHTML; 

        contentDiv.innerHTML = `
            <textarea class="form-control form-control-sm mb-2 annotation-edit-text" rows="3">${currentContent}</textarea>
            <div class="form-check form-check-sm mb-2">
                <input class="form-check-input annotation-edit-private" type="checkbox" ${isPrivate ? 'checked' : ''} id="editPrivate-${annotationId}">
                <label class="form-check-label small" for="editPrivate-${annotationId}">Private</label>
            </div>
            <button class="btn btn-sm btn-success annotate-save-edit-btn me-1">Save</button>
            <button class="btn btn-sm btn-outline-secondary annotate-cancel-edit-btn">Cancel</button>
        `;
        annotationCard.querySelector('.annotate-save-edit-btn').onclick = () => saveEditedAnnotation(annotationId);
        annotationCard.querySelector('.annotate-cancel-edit-btn').onclick = () => cancelEdit(annotationId);
    }

    async function saveEditedAnnotation(annotationId) {
        const articleUri = document.getElementById('annotationModalArticleURI').value;
        const annotationCard = document.querySelector(`.annotation-card[data-annotation-id="${annotationId}"]`);
        if (!articleUri || !annotationCard) return;

        const content = annotationCard.querySelector('.annotation-edit-text').value.trim();
        const isPrivate = annotationCard.querySelector('.annotation-edit-private').checked;

        if (!content) {
            showAlert('Annotation text cannot be empty.', 'warning');
            return;
        }
        try {
            const doubleEncodedUri = encodeURIComponent(encodeURIComponent(articleUri));
            const response = await fetch(`/api/articles/${doubleEncodedUri}/annotations/${annotationId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: content, is_private: isPrivate, author: 'Analyst' /* TODO: Get current user */ })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || 'Failed to update annotation');
            }
            showAlert('Annotation updated successfully!', 'success');
            await loadAnnotations(articleUri); // Refresh list
        } catch (error) {
            console.error('Error updating annotation:', error);
            showAlert(`Failed to update annotation: ${error.message}`, 'danger');
            cancelEdit(annotationId); // Revert on error
        }
    }

    function cancelEdit(annotationId) {
        const annotationCard = document.querySelector(`.annotation-card[data-annotation-id="${annotationId}"]`);
        if (annotationCard && annotationCard.dataset.originalHtml) {
            const contentDiv = annotationCard.querySelector('.annotation-content');
            if(contentDiv) contentDiv.innerHTML = annotationCard.dataset.originalHtml;
            // Re-attach edit/delete listeners if they were part of originalHtml logic, or simplify by re-rendering all annotations
            // For simplicity here, we might rely on a full loadAnnotations if cancel is frequent, or ensure listeners are robust.
            // The current loadAnnotations re-adds listeners, so this is okay.
            loadAnnotations(document.getElementById('annotationModalArticleURI').value); // Quick way to restore and re-add listeners
        } else {
            // Fallback if original HTML wasn't stored, just reload all
            loadAnnotations(document.getElementById('annotationModalArticleURI').value);
        }
    }

    async function deleteAnnotation(annotationId) {
        const articleUri = document.getElementById('annotationModalArticleURI').value;
        if (!articleUri || !confirm('Are you sure you want to delete this annotation?')) return;

        try {
            const doubleEncodedUri = encodeURIComponent(encodeURIComponent(articleUri));
            const response = await fetch(`/api/articles/${doubleEncodedUri}/annotations/${annotationId}`, {
                method: 'DELETE'
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || 'Failed to delete annotation');
            }
            showAlert('Annotation deleted successfully!', 'success');
            await loadAnnotations(articleUri); // Refresh list
        } catch (error) {
            console.error('Error deleting annotation:', error);
            showAlert(`Failed to delete annotation: ${error.message}`, 'danger');
        }
    }

    // Utility for unescaping HTML (simple version for this context)
    function unescapeHTML(html) {
        const temp = document.createElement("div");
        temp.innerHTML = html;
        return temp.textContent || temp.innerText || "";
    }

    // Add a basic showAlert if not already present (can be enhanced)
    if (typeof showAlert !== 'function') {
        window.showAlert = function(message, type = 'info') {
            const alertContainer = document.getElementById('alert-container'); // Assuming you have a div with this ID in base.html or similar
            if (!alertContainer) {
                console.warn("Alert container not found, logging to console:", type, message);
                alert(`${type.toUpperCase()}: ${message}`);
                return;
            }
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show m-2`;
            alertDiv.role = 'alert';
            alertDiv.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
            alertContainer.appendChild(alertDiv);
            setTimeout(() => bootstrap.Alert.getOrCreateInstance(alertDiv)?.close(), 5000);
        }
    }
</script>

{% endblock %} 