{% extends "base.html" %}

{% block title %}Newsletter Composer{% endblock %}

{% block styles %}

<!-- SimpleMDE Markdown Editor CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simplemde@1.11.2/dist/simplemde.min.css">
<!-- Font Awesome for editor toolbar icons - using preload to prioritize loading -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" as="style">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Highlight.js for code syntax highlighting -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.min.css">
<style>
    /* Custom container styling */
    .newsletter-container {
        padding: 20px;
        max-width: 100%;
    }

    #editorPane { 
        height: 500px;
        position: relative;
        border: none;
        padding: 0;
    }
    
    #previewPane {
        height: 500px;
        border: 1px solid #ccc;
        box-sizing: border-box;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        padding: 10px;
        overflow-y: auto;
    }
    
    /* SimpleMDE Specific Overrides and Styling */
    .editor-toolbar {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-bottom: none;
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
        opacity: 1 !important;
        padding: 4px;
    }

    .editor-toolbar a {
        color: #495057 !important;
        border: 1px solid transparent !important;
        margin: 2px !important;
        width: 30px !important;
        height: 30px !important;
        text-align: center;
        line-height: 30px !important;
    }

    .editor-toolbar a:before {
        line-height: 30px !important;
    }

    .editor-toolbar a.active,
    .editor-toolbar a:hover {
        background: #e9ecef !important;
        border-color: #ced4da !important;
        color: #000 !important;
    }
    
    .CodeMirror-fullscreen, .editor-preview-full {
        z-index: 1050 !important;
    }

    /* Ensure CodeMirror (editor area) fits within #editorPane and card */
    .CodeMirror {
        height: 100% !important;
        border: 1px solid #dee2e6 !important;
        border-top: none !important;
        border-bottom-left-radius: 4px;
        border-bottom-right-radius: 4px;
        font-size: 16px;
        line-height: 1.5;
        padding: 10px;
        box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    }

    /* Fix cursor visibility issues */
    .CodeMirror-cursor {
        border-left: 1px solid black !important;
        border-right: none !important;
        width: 0 !important;
        opacity: 1 !important;
    }
    
    /* Improve focus and selection styling */
    .CodeMirror-focused .CodeMirror-selected {
        background: rgba(0, 0, 255, 0.1) !important;
    }
    
    /* Make sure cursor is visible in editor */
    .CodeMirror pre.CodeMirror-line, 
    .CodeMirror pre.CodeMirror-line-like {
        z-index: 1;
    }

    .CodeMirror-scroll {
        min-height: 450px;
    }
    
    .editor-preview-side {
        z-index: 100;
        border-left: 1px solid #dee2e6 !important; 
    }
    
    #htmlPreview {
        height: 100%;
        overflow-y: auto;
        padding: 15px;
    }
    
    .control-panel {
        margin-bottom: 20px;
    }
    
    .form-group {
        margin-bottom: 15px;
    }
    
    .content-type-item {
        margin: 10px 0;
    }
    
    .loading-spinner {
        display: none;
        text-align: center;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        padding: 25px;
        max-width: 90%;
        width: 500px;
    }

    .editor-section {
        margin-bottom: 20px;
    }
    
    .editor-card { 
        background-color: white;
        border-radius: 0.25rem;
        margin-bottom: 20px;
        overflow: hidden; 
    }
    
    .editor-card-header {
        padding: 0.75rem 1.25rem;
        margin-bottom: 0;
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        border-top-left-radius: calc(0.25rem - 1px);
        border-top-right-radius: calc(0.25rem - 1px);
    }

    .editor-card-header h5 {
        margin-bottom: 0;
        font-size: 1rem;
        font-weight: 500;
    }
    
    /* Style for code blocks in preview */
    #htmlPreview pre {
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 10px;
    }
    
    #htmlPreview code {
        font-family: 'Courier New', Courier, monospace;
    }
    
    @media (max-width: 768px) {
        #editorPane, #previewPane {
            height: 400px;
        }
        .CodeMirror-scroll {
            min-height: 350px; 
        }
    }

    /* Ensure Font Awesome icons display correctly in the toolbar */
    .editor-toolbar a:before {
        font-family: FontAwesome, sans-serif !important;
        display: inline-block;
        font-size: 16px;
        width: 100%;
        text-align: center;
    }
    
    /* Fix specific icon issues by providing direct icon code points */
    .editor-toolbar a.fa-header:before { content: "\f1dc"; }
    .editor-toolbar a.fa-bold:before { content: "\f032"; }
    .editor-toolbar a.fa-italic:before { content: "\f033"; }
    .editor-toolbar a.fa-strikethrough:before { content: "\f0cc"; }
    .editor-toolbar a.fa-link:before { content: "\f0c1"; }
    .editor-toolbar a.fa-quote-left:before { content: "\f10d"; }
    .editor-toolbar a.fa-list-ul:before { content: "\f0ca"; }
    .editor-toolbar a.fa-list-ol:before { content: "\f0cb"; }
    .editor-toolbar a.fa-table:before { content: "\f0ce"; }
    .editor-toolbar a.fa-picture-o:before { content: "\f03e"; }
    .editor-toolbar a.fa-code:before { content: "\f121"; }
    .editor-toolbar a.fa-question-circle:before { content: "\f059"; }
    .editor-toolbar a.fa-eye:before { content: "\f06e"; }
    .editor-toolbar a.fa-columns:before { content: "\f0db"; }
    .editor-toolbar a.fa-arrows-alt:before { content: "\f0b2"; }
    .editor-toolbar a.fa-minus:before { content: "\f068"; }

    /* Improved content type selection layout */
    .content-types-container {
        display: block;
        margin-bottom: 15px;
    }
    
    .content-type-item {
        padding: 8px 12px;
        margin-bottom: 8px;
        border: 1px solid #eee;
        border-radius: 4px;
        background-color: #f9f9f9;
    }
    
    .content-type-checkbox-wrapper {
        display: flex;
        align-items: center;
    }
    
    .content-type-item label {
        font-weight: 500;
        margin-left: 8px;
        margin-bottom: 0;
        cursor: pointer;
    }
    
    .content-type-item small {
        display: block;
        margin-left: 25px;
        margin-top: 5px;
        color: #6c757d;
    }
    
    /* Control chart sizes in the preview - more aggressive size limitations */
    .preview-container img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 15px auto;
    }
    
    /* Specifically target chart images to ensure they're not too large */
    .preview-container img[src*="chart"], 
    .preview-container img[alt*="Chart"],
    .preview-container img[alt*="chart"],
    .preview-container img[src*="sentiment"],
    .preview-container img[src*="radar"],
    .preview-container img[src*="graph"] {
        max-width: 550px;
        max-height: 400px;
        width: auto !important;
        height: auto !important;
        object-fit: contain;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 5px;
        background-color: white;
    }
    
    /* Ensure the loading spinner is centered and visible */
    #loadingSpinner {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
    }

    /* Navigation styles */
    .breadcrumb-container {
        background-color: #f5f5f5;
        padding: 8px 15px;
        margin-bottom: 20px;
        border-radius: 4px;
    }
    
    .breadcrumb {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
    }
    
    .breadcrumb-item {
        display: inline-block;
        margin-right: 5px;
    }
    
    .breadcrumb-item + .breadcrumb-item::before {
        content: "/";
        padding: 0 5px;
        color: #6c757d;
    }

    /* Add tooltip styles */
    .tooltip-inner {
        max-width: 300px;
        padding: 8px 12px;
        font-size: 14px;
        line-height: 1.4;
    }

    [data-toggle="tooltip"] {
        cursor: help;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid newsletter-container" id="newsletterCompilerApp">
    <h1>Newsletter Composer</h1>
    
    <!-- Row 1: Newsletter Configuration -->
    <div class="row mb-4">
        <div class="col-md-12">
            <!-- Newsletter Configuration Form -->
            <div class="card">
                <div class="card-header">
                    <h5>Newsletter Configuration</h5>
                </div>
                <div class="card-body">
                    <form id="newsletterForm">
                        <div class="row">
                            <div class="col-md-8">
                                <div class="form-group">
                                    <label for="topics" data-toggle="tooltip" data-placement="right" 
                                           title="Select one or more topics to include in your newsletter">Topics:</label>
                                    <select class="form-control" id="topics" name="topics" multiple required
                                            data-toggle="tooltip" data-placement="right" 
                                            title="Hold Ctrl/Cmd to select multiple topics. These will be the main subjects covered in your newsletter">
                                        <!-- Will be populated via API -->
                                        <option value="" disabled>Loading topics...</option>
                                    </select>
                                    <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple topics</small>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="form-group">
                                            <label for="frequency" data-toggle="tooltip" data-placement="right" 
                                                   title="Select newsletter frequency">Frequency:</label>
                                            <select class="form-control" id="frequency" name="frequency" required
                                                    data-toggle="tooltip" data-placement="right" 
                                                    title="How frequently this newsletter is distributed">
                                                <option value="weekly" selected>Weekly</option>
                                                <option value="daily">Daily</option>
                                                <option value="monthly">Monthly</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="form-group">
                                            <label for="ai_model" data-toggle="tooltip" data-placement="right" 
                                                   title="Select which AI model to use">AI Model:</label>
                                            <select class="form-control" id="ai_model" name="ai_model" required
                                                    data-toggle="tooltip" data-placement="right" 
                                                    title="Different AI models have different capabilities">
                                                <option value="gpt-4o" selected>GPT-4o</option>
                                                <option value="gpt-4o-mini">GPT-4o Mini</option>
                                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                                                <option value="claude-3-7-sonnet-latest">Claude 3.7 Sonnet</option>
                                                <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
                                                <option value="mixtral-8x7b">Mixtral 8x7B</option>
                                                <option value="gemini-pro">Gemini Pro</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label data-toggle="tooltip" data-placement="right" 
                                       title="Choose which types of content to include in your newsletter">Content Types and Prompts:</label>
                                <button type="button" id="selectAllContentTypes" class="btn btn-sm btn-primary"
                                        data-toggle="tooltip" data-placement="right" 
                                        title="Toggle selection of all content types">Select All</button>
                            </div>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Content Type</th>
                                        <th class="text-center">Include</th>
                                        <th class="text-right">Prompt</th>
                                    </tr>
                                </thead>
                                <tbody id="contentTypesTable">
                                    <tr>
                                        <td colspan="3" class="text-muted">Loading content types...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="form-group">
                            <label data-toggle="tooltip" data-placement="right" 
                                   title="Optionally specify a custom date range for the newsletter content">Date Range (Optional):</label>
                            <div class="row mb-2">
                                <div class="col-auto">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="dayRangeBtn"
                                            data-toggle="tooltip" data-placement="top" 
                                            title="Set date range to last 24 hours">Day</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="weekRangeBtn"
                                            data-toggle="tooltip" data-placement="top" 
                                            title="Set date range to last 7 days">Week</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="monthRangeBtn"
                                            data-toggle="tooltip" data-placement="top" 
                                            title="Set date range to last 30 days">Month</button>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <label for="startDate" data-toggle="tooltip" data-placement="right" 
                                           title="Start date for newsletter content">Start Date:</label>
                                    <input type="date" class="form-control" id="startDate" name="startDate"
                                           data-toggle="tooltip" data-placement="right" 
                                           title="Select the start date for content inclusion">
                                </div>
                                <div class="col-md-6">
                                    <label for="endDate" data-toggle="tooltip" data-placement="right" 
                                           title="End date for newsletter content">End Date:</label>
                                    <input type="date" class="form-control" id="endDate" name="endDate"
                                           data-toggle="tooltip" data-placement="right" 
                                           title="Select the end date for content inclusion">
                                </div>
                            </div>
                            <small class="form-text text-muted">If not specified, dates will be calculated based on frequency</small>
                        </div>
                        
                        <div class="card-footer d-flex justify-content-between">
                            <div>
                                <span class="text-muted">Last updated: <span id="lastUpdated">Never</span></span>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Row 2: Actions -->
    <div class="row mb-4">
        <div class="col-md-12">
            <!-- Action Buttons -->
            <div class="card">
                <div class="card-header">
                    <h5>Actions</h5>
                </div>
                <div class="card-body">
                    <div class="d-flex flex-wrap">
                        <!-- Primary Actions -->
                        <div class="btn-group mr-2">
                            <button id="compileButton" type="button" class="btn btn-primary">
                                <i class="fa fa-cogs"></i> Generate
                            </button>
                        </div>
                        <div class="btn-group mr-2">
                            <button id="selectChartButton" type="button" class="btn btn-outline-secondary" onclick="openChartSelectionModal()">
                                <i class="fa fa-chart-bar"></i> Charts
                            </button>
                            <button id="selectPodcastButton" type="button" class="btn btn-outline-secondary" onclick="openPodcastSelectionModal()">
                                <i class="fa fa-podcast"></i> Podcast
                            </button>
                            <button id="selectArticlesButton" type="button" class="btn btn-outline-secondary" onclick="openArticleSelectionModal()">
                                <i class="fa fa-newspaper"></i> Articles
                            </button>
                        </div>
                        
                        <!-- File Actions -->
                        <div class="btn-group mr-2 mb-2">
                            <button type="button" id="downloadMarkdownButton" class="btn btn-success btn-sm"
                                    data-toggle="tooltip" data-placement="top" 
                                    title="Download the newsletter content as a Markdown file">
                                    <i class="fa fa-download"></i> Download Markdown
                            </button>
                            <button type="button" id="downloadPdfButton" class="btn btn-info btn-sm"
                                    data-toggle="tooltip" data-placement="top" 
                                    title="Download the newsletter as PDF">
                                    <i class="fa fa-file-pdf-o"></i> Download PDF
                            </button>
                        </div>
                        
                        <!-- Server/Distribution Actions -->
                        <div class="btn-group mb-2">
                            <button type="button" id="saveToServerButton" class="btn btn-primary btn-sm"
                                    data-toggle="tooltip" data-placement="top" 
                                    title="Save the newsletter on the server">
                                    <i class="fa fa-save"></i> Save to Server
                            </button>
                            <button type="button" id="sendEmailButton" class="btn btn-warning btn-sm"
                                    data-toggle="tooltip" data-placement="top" 
                                    title="Send newsletter via email">
                                    <i class="fa fa-envelope"></i> Send Email
                            </button>
                            <button type="button" id="sendSlackButton" class="btn btn-dark btn-sm"
                                    data-toggle="tooltip" data-placement="top" 
                                    title="Send newsletter to Slack">
                                    <i class="fa fa-slack"></i> Send to Slack
                            </button>
                            <button type="button" id="clearSavedStateButton" class="btn btn-outline-danger btn-sm"
                                    data-toggle="tooltip" data-placement="top"
                                    title="Clear locally saved state">
                                    <i class="fa fa-trash"></i> Clear Saved State
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Saved Newsletters Section -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Saved Newsletters</h5>
                    <button type="button" id="refreshSavedNewslettersBtn" class="btn btn-sm btn-outline-secondary">
                        <i class="fa fa-refresh"></i> Refresh
                    </button>
                </div>
                <div class="card-body">
                    <div id="savedNewslettersContainer" class="list-group">
                        <div class="text-center text-muted py-3">
                            <i class="fa fa-spinner fa-spin mr-2"></i> Loading saved newsletters...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="loading-spinner" id="loadingSpinner" style="display: none; margin: 20px;">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Newsletter Compilation Progress</h5>
                <div id="compilationStatus" class="mb-2">Initializing...</div>
                <div class="progress mb-3">
                    <div id="compilationProgress" class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                        0%
                    </div>
                </div>
                <div id="compilationStep" class="text-muted small">Starting compilation...</div>
                <div id="compilationID" class="text-muted small mt-2"></div>
            </div>
        </div>
    </div>
    
    <!-- Row 3: Editor and Preview -->
    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Markdown Editor</h5>
                </div>
                <div class="card-body p-0">
                    <textarea id="basic-editor"></textarea>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Preview</h5>
                </div>
                <div class="card-body p-0">
                    <div id="preview-content" class="preview-container">
                        <p>Preview will appear here...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <!-- Prompt Editor Modal -->
    <div class="modal" id="promptEditorModal" tabindex="-1" role="dialog" aria-labelledby="promptEditorModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="promptEditorModalTitle">Edit Prompt</h5>
                    <button type="button" class="close" id="closePromptEditorModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="promptEditorForm">
                        <input type="hidden" id="promptEditorContentTypeId" name="contentTypeId">
                        <div class="form-group">
                            <label for="promptEditorText">Prompt Template</label>
                            <textarea class="form-control" id="promptEditorText" name="promptTemplate" rows="10" 
                                      placeholder="Enter your custom prompt template here..."></textarea>
                            <small class="form-text text-muted">
                                <h6 class="mt-3 mb-2">Available Variables for Prompt Templates:</h6>
                                <ul class="list-unstyled">
                                    <li><code>{{topic}}</code> - The current topic being processed</li>
                                    <li><code>{{article_data}}</code> - Formatted article data with titles, URLs, sources</li>
                                    <li><code>{{articles}}</code> - Alternative way to access article data</li>
                                    <li><code>{{start_date}}</code> - Start date for content (YYYY-MM-DD format)</li>
                                    <li><code>{{end_date}}</code> - End date for content (YYYY-MM-DD format)</li>
                                    <li><code>{{formatted_date}}</code> - Current date in human-readable format</li>
                                    <li><code>{{frequency}}</code> - Newsletter frequency (daily, weekly, monthly)</li>
                                    <li><code>{{topics}}</code> - Comma-separated list of all newsletter topics</li>
                                    <li><code>{{content_instructions}}</code> - Special instructions for this content type</li>
                                    <li><code>{{article_count}}</code> - Number of articles available</li>
                                </ul>
                            </small>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelPromptEditorModal">Cancel</button>
                    <button type="button" class="btn btn-warning" id="restorePromptButton">
                        <i class="fa fa-undo"></i> Restore Default
                    </button>
                    <button type="button" class="btn btn-primary" id="savePromptButton">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Chart Selection Modal -->
    <div class="modal" id="chartSelectionModal" tabindex="-1" role="dialog" aria-labelledby="chartSelectionModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="chartSelectionModalTitle">Select Charts</h5>
                    <button type="button" class="close" id="closeChartSelectionModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-muted mb-3">Choose which charts to include in your newsletter:</p>
                    <form id="chartSelectionForm">
                        <div class="form-group">
                            <div class="custom-control custom-checkbox mb-3">
                                <input type="checkbox" class="custom-control-input" id="chart_sentiment_trends" name="selected_charts" value="sentiment_trends" checked>
                                <label class="custom-control-label" for="chart_sentiment_trends">
                                    <strong>Sentiment Trends</strong>
                                    <small class="text-muted d-block">Shows sentiment analysis over time for selected topics</small>
                                </label>
                            </div>
                            <div class="custom-control custom-checkbox mb-3">
                                <input type="checkbox" class="custom-control-input" id="chart_future_signals" name="selected_charts" value="future_signals" checked>
                                <label class="custom-control-label" for="chart_future_signals">
                                    <strong>Future Signals Analysis</strong>
                                    <small class="text-muted d-block">Radar chart showing future impact signals for the selected topics</small>
                                </label>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelChartSelectionModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveChartSelectionButton">Save Selection</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Save Newsletter Modal -->
    <div class="modal" id="saveNewsletterModal" tabindex="-1" role="dialog" aria-labelledby="saveNewsletterModalTitle" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="saveNewsletterModalTitle">Save Newsletter</h5>
                    <button type="button" class="close" id="closeSaveNewsletterModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="saveNewsletterForm">
                        <div class="form-group">
                            <label for="newsletterFilename">Filename</label>
                            <input type="text" class="form-control" id="newsletterFilename" 
                                   placeholder="Enter filename (without extension)" required>
                            <small class="form-text text-muted">
                                The .md extension will be added automatically. 
                                Use a descriptive name like "weekly_ai_2023-05-01".
                            </small>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelSaveNewsletterModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveNewsletterButton">Save</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Podcast Selection Modal -->
    <div class="modal" id="podcastSelectionModal" tabindex="-1" role="dialog" aria-labelledby="podcastSelectionModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="podcastSelectionModalTitle">Select Podcast</h5>
                    <button type="button" class="close" id="closePodcastSelectionModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-muted mb-3">Choose a podcast to include in your newsletter:</p>
                    <div id="podcastListContainer" class="list-group mb-3">
                        <div class="text-center py-3">
                            <i class="fa fa-spinner fa-spin mr-2"></i> Loading podcasts...
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelPodcastSelectionModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="savePodcastSelectionButton">Select Podcast</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Article Selection Modal -->
    <div class="modal" id="articleSelectionModal" tabindex="-1" role="dialog" aria-labelledby="articleSelectionModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="articleSelectionModalTitle">Select Articles</h5>
                    <button type="button" class="close" id="closeArticleSelectionModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="articleSearchForm" class="mb-3">
                        <div class="form-row">
                            <div class="col-md-5">
                                <div class="form-group">
                                    <label for="articleSearchQuery">Search</label>
                                    <input type="text" class="form-control" id="articleSearchQuery" placeholder="Enter search terms">
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="form-group">
                                    <label for="articleSearchTopic">Topic</label>
                                    <select class="form-control" id="articleSearchTopic">
                                        <option value="">All Topics</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-2">
                                <div class="form-group">
                                    <label for="articleSearchStartDate">From</label>
                                    <input type="date" class="form-control" id="articleSearchStartDate">
                                </div>
                            </div>
                            <div class="col-md-2">
                                <div class="form-group">
                                    <label for="articleSearchEndDate">To</label>
                                    <input type="date" class="form-control" id="articleSearchEndDate">
                                </div>
                            </div>
                        </div>
                        <button type="button" id="articleSearchButton" class="btn btn-primary">Search</button>
                    </form>
                    
                    <div id="articleListContainer" class="list-group mb-3">
                        <div class="text-center py-3 text-muted">
                            Enter search terms and click Search
                        </div>
                    </div>
                    
                    <div class="selected-articles-container mb-3">
                        <h6>Selected Articles: <span id="selectedArticlesCount">0</span></h6>
                        <div id="selectedArticlesList" class="list-group">
                            <!-- Selected articles will appear here -->
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelArticleSelectionModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveArticleSelectionButton">Add Selected Articles</button>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
<!-- Keep the working SimpleMDE implementation -->
<script src="https://unpkg.com/simplemde@1.11.2/dist/simplemde.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/simplemde@1.11.2/dist/simplemde.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!-- Add back the marked library for markdown parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/lib/marked.umd.min.js"></script>

<script>
// Global variables
let editor; // Our SimpleMDE editor instance
const loadingSpinner = document.getElementById('loadingSpinner');
let originalMarkdownContent = ""; // Store the full content with base64
let selectedCharts = ['sentiment_trends', 'topic_distribution']; // Default selected charts

// Initialize SimpleMDE editor
window.onload = function() {
    console.log("Window loaded, initializing SimpleMDE editor");
    
    // Check if the textarea exists
    const textArea = document.getElementById('basic-editor');
    if (!textArea) {
        console.error("Textarea not found");
        return;
    }
    
    // Check if SimpleMDE exists
    if (typeof SimpleMDE === 'undefined') {
        console.error("SimpleMDE library not loaded");
        textArea.value = "SimpleMDE library could not be loaded. Please check your internet connection.";
        return;
    }
    
    try {
        // Initialize SimpleMDE
        editor = new SimpleMDE({ 
            element: textArea,
            spellChecker: false,
            autofocus: true,
            placeholder: "Type markdown content here...",
            initialValue: "# Newsletter Content\n\nClick the 'Generate Newsletter' button to compile your newsletter based on the settings above.",
            toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", 
                     "link", "image", "table", "|", "preview", "side-by-side", "fullscreen"]
        });
        
        console.log("SimpleMDE initialized successfully");
        
        // Save original value method
        const originalGetValue = editor.value.bind(editor);
        const originalSetValue = editor.value;
        
        // Override the value() method to handle base64 images
        editor.value = function(val) {
            if (val === undefined) {
                // Getting the value - return original content with base64
                return originalMarkdownContent || originalGetValue();
            } else {
                // Setting the value - store original and set condensed version
                originalMarkdownContent = val;
                
                // Replace base64 content with placeholders in the editor
                const condensedVal = replaceBase64WithPlaceholders(val);
                originalSetValue.call(editor, condensedVal);
                
                return editor;
            }
        };
        
        // Set up change handler for preview updates and auto-save
        editor.codemirror.on("change", function() {
            // Get editor content (which may have placeholders)
            const editorContent = editor.codemirror.getValue();
            
            // If user edited something, update the original content too
            if (editorContent !== replaceBase64WithPlaceholders(originalMarkdownContent)) {
                // Find and restore any image placeholders that might have been edited
                originalMarkdownContent = restorePlaceholdersIfNeeded(editorContent, originalMarkdownContent);
            }
            
            updatePreview();
            
            // Auto-save with delay to avoid too many saves during typing
            clearTimeout(window.editorSaveTimeout);
            window.editorSaveTimeout = setTimeout(saveNewsletterState, 1000);
        });
        
        // Initial preview update
        updatePreview();
        
        // Load saved newsletters on page load
        loadSavedNewsletters();
        
    } catch (error) {
        console.error("Error initializing SimpleMDE:", error);
        textArea.value = "Error initializing editor: " + error.message;
    }
};

// Function to replace base64 content with placeholders
function replaceBase64WithPlaceholders(markdown) {
    if (!markdown) return markdown;
    
    // Pattern to match Markdown image syntax with base64 data
    const imagePattern = /!\[([^\]]*)\]\(data:image\/[^;]+;base64,([A-Za-z0-9+/=]{30})[A-Za-z0-9+/=]+\)/g;
    
    // Replace with placeholder but keep alt text and image type
    return markdown.replace(imagePattern, (match, altText, base64Start) => {
        return `![${altText}][IMAGE: ${base64Start}...]`;
    });
}

// Function to restore placeholders when needed
function restorePlaceholdersIfNeeded(editorContent, originalContent) {
    if (!editorContent || !originalContent) return originalContent;
    
    // Look for placeholder pattern
    const placeholderPattern = /!\[([^\]]*)\]\[IMAGE: ([A-Za-z0-9+/=]{30})...\]/g;
    
    return editorContent.replace(placeholderPattern, (match, altText, base64Start) => {
        // Try to find the corresponding original image in the stored content
        const originalImagePattern = new RegExp(`!\\[${altText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\]\\(data:image\\/[^;]+;base64,${base64Start}[A-Za-z0-9+/=]+\\)`, 'g');
        const originalMatches = originalContent.match(originalImagePattern);
        
        if (originalMatches && originalMatches.length > 0) {
            return originalMatches[0]; // Return the original image markdown with full base64
        }
        
        // If not found, just return the placeholder
        return match;
    });
}

// Function to get markdown content
function getMarkdownContent() {
    if (editor) {
        // Return original content with full base64 images
        return originalMarkdownContent || editor.value();
    }
    return "";
}

// Function to set markdown content
function setMarkdownContent(markdown) {
    if (editor) {
        editor.value(markdown);
        updatePreview();
    }
}

// Update the preview from markdown content
function updatePreview() {
    // Use original content with full base64 data for preview
    const markdownContent = getMarkdownContent();
    const previewElement = document.getElementById('preview-content');
    
    if (!markdownContent || !markdownContent.trim()) {
        previewElement.innerHTML = '<p>Preview will appear here...</p>';
        return;
    }
    
    try {
        // Use marked for markdown rendering
        if (typeof marked !== 'undefined') {
            const html = marked.parse(markdownContent);
            previewElement.innerHTML = html;
            
            // Apply image processing to ensure color charts display properly
            const images = previewElement.querySelectorAll('img');
            images.forEach(img => {
                // Fix data URLs - ensure no space after base64,
                if (img.src && img.src.startsWith('data:image') && img.src.includes('base64, ')) {
                    img.src = img.src.replace('base64, ', 'base64,');
                }
                
                // Skip cache busting for data URLs
                if (img.src && !img.src.startsWith('data:') && !img.src.includes('cache=')) {
                    img.src = img.src + (img.src.includes('?') ? '&' : '?') + 'cache=' + new Date().getTime();
                }
                
                // Add specific classes for charts
                if (img.src && (img.src.includes('chart') || img.src.includes('sentiment') || 
                    img.src.includes('radar') || img.alt && (img.alt.includes('Chart') || 
                    img.alt.includes('chart')))) {
                    img.classList.add('newsletter-chart');
                    // Explicitly set dimensions to override any inline styles
                    img.style.maxWidth = '550px';
                    img.style.maxHeight = '400px';
                    img.style.width = 'auto';
                    img.style.height = 'auto';
                }
                
                // Add error handler to log any issues with images
                img.onerror = function() {
                    console.error('Error loading image:', this.src);
                    // Replace with error message directly in the image
                    this.style.display = 'inline-block';
                    this.style.padding = '5px';
                    this.style.border = '1px solid #f55';
                    this.style.backgroundColor = '#fee';
                    this.style.color = '#333';
                    this.style.fontStyle = 'italic';
                    this.style.fontSize = '14px';
                    this.style.height = 'auto';
                    this.style.width = 'auto';
                    this.style.minHeight = '50px';
                    this.style.textAlign = 'center';
                    this.style.lineHeight = '50px';
                    this.alt = 'Image failed to load';
                    
                    // Set a data attribute to mark this as an error
                    this.setAttribute('data-load-error', 'true');
                    
                    // Replace the src with a transparent pixel so it stops trying to load
                    // but only if it's not a data URL to avoid recursive errors
                    if (!this.src.startsWith('data:')) {
                        this.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
                    }
                };
            });
        } else {
            // Fallback to basic rendering
            let html = markdownContent
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/\*\*(.*)\*\*/gm, '<strong>$1</strong>')
                .replace(/\*(.*)\*/gm, '<em>$1</em>')
                .replace(/\[([^\]]+)\]\(([^)]+)\)/gm, '<a href="$2">$1</a>')
                .replace(/\n/gm, '<br>');
            
            previewElement.innerHTML = html;
        }
    } catch (error) {
        console.error("Error updating preview:", error);
        previewElement.innerHTML = "<p>Error rendering preview: " + error.message + "</p>";
    }
}

// Download markdown content - use full content with base64
function downloadMarkdown() {
    const markdownContent = getMarkdownContent();
    
    if (!markdownContent.trim()) {
        alert('No content to download');
        return;
    }
    
    // Create filename with date
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    const frequency = document.getElementById('frequency').value;
    const topicsSelect = document.getElementById('topics');
    const topics = Array.from(topicsSelect.selectedOptions).map(option => option.value).join('-');
    
    const filename = `${frequency}_${topics || 'newsletter'}_${dateStr}.md`;
    
    // Create download link
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(markdownContent));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    
    // Add to body, click, and remove
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

// Load topics from API
async function loadTopics() {
    try {
        console.log('Fetching topics...');
        const topicsSelect = document.getElementById('topics');
        if (!topicsSelect) {
            console.error('Topics select element not found');
            return;
        }
        
        // Clear existing options and show loading
        topicsSelect.innerHTML = '<option value="" disabled selected>Loading topics...</option>';
        
        const response = await fetch('/api/newsletter/topics');
        console.log('Topics API response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`API returned status: ${response.status}`);
        }
        
        const topics = await response.json();
        console.log('Fetched topics:', topics);
        
        // Clear the select
        topicsSelect.innerHTML = '';
        
        if (!Array.isArray(topics)) {
            console.error('Topics data is not an array:', topics);
            topicsSelect.innerHTML = '<option value="" disabled selected>Error: Invalid data format</option>';
            return;
        }
        
        if (topics.length === 0) {
            console.warn('No topics returned from API');
            topicsSelect.innerHTML = '<option value="" disabled selected>No topics available</option>';
            return;
        }
        
        // Add topics to select
        topics.forEach(topic => {
            const option = document.createElement('option');
            
            // Handle both object format and simple string format
            if (typeof topic === 'string') {
                option.value = topic;
                option.textContent = topic;
            } else {
                // Object format with properties
                option.value = topic.id || topic.name || topic;
                option.textContent = topic.name || topic;
                
                if (topic.description) {
                    option.title = topic.description;
                }
                if (topic.default_selected) {
                    option.selected = true;
                }
            }
            
            topicsSelect.appendChild(option);
        });
        
        console.log('Topics loaded successfully');
        
    } catch (error) {
        console.error('Error loading topics:', error);
        const topicsSelect = document.getElementById('topics');
        if (topicsSelect) {
            topicsSelect.innerHTML = `<option value="" disabled selected>Error loading topics: ${error.message}</option>`;
        }
    }
}

// Load content types from API
async function loadContentTypes() {
    try {
        console.log('Fetching content types...');
        const contentTypesTable = document.getElementById('contentTypesTable');
        if (!contentTypesTable) {
            console.error('Content types table element not found');
            return;
        }
        
        // Get the tbody element
        const tbody = contentTypesTable;
        tbody.innerHTML = '<tr><td colspan="3" class="text-muted">Loading content types...</td></tr>';
        
        const response = await fetch('/api/newsletter/content_types');
        console.log('Content types API response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`API returned status: ${response.status}`);
        }
        
        const contentTypes = await response.json();
        console.log('Fetched content types:', contentTypes);
        
        // Clear container
        tbody.innerHTML = '';
        
        if (!Array.isArray(contentTypes)) {
            console.error('Content types data is not an array:', contentTypes);
            tbody.innerHTML = '<tr><td colspan="3" class="text-danger">Error: Invalid data format</td></tr>';
            return;
        }
        
        if (contentTypes.length === 0) {
            console.warn('No content types returned from API');
            tbody.innerHTML = '<tr><td colspan="3" class="text-muted">No content types available</td></tr>';
            return;
        }
        
        // Render content types
        contentTypes.forEach(contentType => {
            const row = document.createElement('tr');
            
            // Content type name cell
            const nameCell = document.createElement('td');
            nameCell.textContent = contentType.name || 'Unnamed';
            if (contentType.description) {
                const description = document.createElement('small');
                description.className = 'text-muted d-block';
                description.textContent = contentType.description;
                nameCell.appendChild(description);
            }
            
            // Include checkbox cell
            const includeCell = document.createElement('td');
            includeCell.className = 'text-center';
            
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.className = 'form-check';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-check-input content-type-checkbox';
            checkbox.id = `content-type-${contentType.id}`;
            checkbox.name = `content-type-${contentType.id}`;
            checkbox.value = contentType.id;
            checkbox.checked = contentType.default_enabled || false;
            
            checkboxWrapper.appendChild(checkbox);
            includeCell.appendChild(checkboxWrapper);
            
            // Prompt input cell
            const promptCell = document.createElement('td');
            
            // Create a container for the edit button (no input field)
            const promptContainer = document.createElement('div');
            promptContainer.className = 'd-flex justify-content-end';
            
            // Create hidden input for storing the prompt value
            const promptInput = document.createElement('input');
            promptInput.type = 'hidden';
            promptInput.id = `prompt-${contentType.id}`;
            promptInput.name = `prompt-${contentType.id}`;
            promptInput.value = contentType.default_prompt || '';
            
            // Create edit button (icon only)
            const editButton = document.createElement('button');
            editButton.className = 'btn btn-sm btn-outline-secondary';
            editButton.type = 'button';
            editButton.innerHTML = '<i class="fa fa-pencil"></i>';
            editButton.title = 'Edit custom prompt template';
            editButton.setAttribute('data-toggle', 'tooltip');
            editButton.setAttribute('data-placement', 'top');
            
            // Special handling for Key Charts content type
            if (contentType.id === 'key_charts') {
                editButton.innerHTML = '<i class="fa fa-bar-chart"></i>';
                editButton.title = 'Select charts to include';
                
                // Add click handler for the chart selection instead of prompt editing
                editButton.addEventListener('click', function() {
                    openChartSelectionModal();
                });
            } else {
                // Regular prompt editing for other content types
                editButton.addEventListener('click', function() {
                    // Get the content type ID from the prompt input ID
                    const contentTypeId = contentType.id;
                    
                    // Load the prompt from the database first
                    fetch(`/api/newsletter/prompts/${contentTypeId}`)
                        .then(response => {
                            if (!response.ok) {
                                if (response.status === 404) {
                                    // If not found, just use the current value
                                    return { 
                                        prompt_template: promptInput.value,
                                        description: contentType.description || ''
                                    };
                                }
                                throw new Error(`API returned status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Populate and show the prompt editor modal
                            const modal = document.getElementById('promptEditorModal');
                            const modalTitle = document.getElementById('promptEditorModalTitle');
                            const modalPromptTextarea = document.getElementById('promptEditorText');
                            const contentTypeIdInput = document.getElementById('promptEditorContentTypeId');
                            
                            if (modal && modalTitle && modalPromptTextarea && contentTypeIdInput) {
                                // Set modal title
                                modalTitle.textContent = `Edit Prompt: ${contentType.name || contentTypeId}`;
                                
                                // Set prompt text
                                modalPromptTextarea.value = data.prompt_template || promptInput.value;
                                
                                // Store original prompt for restoration
                                modalPromptTextarea.dataset.originalPrompt = data.prompt_template || promptInput.value;
                                modalPromptTextarea.dataset.defaultPrompt = data.default_prompt || '';
                                
                                // Set content type ID (hidden field)
                                contentTypeIdInput.value = contentTypeId;
                                
                                // Show modal using native JavaScript (not jQuery)
                                modal.classList.add('show');
                                modal.style.display = 'block';
                                modal.setAttribute('aria-hidden', 'false');
                                document.body.classList.add('modal-open');
                            } else {
                                console.error('Prompt editor modal elements not found');
                                alert('Error: Could not open prompt editor. Please try again.');
                            }
                        })
                        .catch(error => {
                            console.error('Error loading prompt:', error);
                            alert(`Error loading prompt: ${error.message}`);
                        });
                });
            }
            
            // Add elements to container
            promptContainer.appendChild(promptInput);
            promptContainer.appendChild(editButton);
            
            // Add the container to the cell
            promptCell.appendChild(promptContainer);
            
            // Add cells to row
            row.appendChild(nameCell);
            row.appendChild(includeCell);
            row.appendChild(promptCell);
            
            // Add row to table
            tbody.appendChild(row);
        });
        
        console.log('Content types loaded successfully');
        
    } catch (error) {
        console.error('Error loading content types:', error);
        const contentTypesTable = document.getElementById('contentTypesTable');
        if (contentTypesTable) {
            contentTypesTable.innerHTML = `<tr><td colspan="3" class="text-danger">Error loading content types: ${error.message}</td></tr>`;
        }
    }
}

// Compile newsletter content
async function compileNewsletter() {
    try {
        console.log('Compiling newsletter...');
        
        // Show loading spinner
        const loadingSpinner = document.getElementById('loadingSpinner');
        if (loadingSpinner) {
            loadingSpinner.style.display = 'block';
        }
        
        // Get selected topics
        const topicsSelect = document.getElementById('topics');
        if (!topicsSelect) {
            throw new Error('Topics select element not found');
        }
        
        const selectedTopics = Array.from(topicsSelect.selectedOptions).map(option => option.value);
        if (selectedTopics.length === 0) {
            throw new Error('Please select at least one topic');
        }
        
        console.log('Selected topics:', selectedTopics);
        
        // Get selected content types and their prompts
        const contentTypeCheckboxes = document.querySelectorAll('.content-type-checkbox:checked');
        if (contentTypeCheckboxes.length === 0) {
            throw new Error('Please select at least one content type');
        }
        
        // The API expects a list of content type IDs (strings), not objects
        const selectedContentTypes = Array.from(contentTypeCheckboxes).map(checkbox => {
            return checkbox.value;
        });
        
        console.log('Selected content types:', selectedContentTypes);
        
        // Get date range
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        // Get frequency (required by API)
        const frequency = document.getElementById('frequency');
        let frequencyValue = 'weekly'; // Default to weekly if frequency element doesn't exist
        
        if (frequency) {
            frequencyValue = frequency.value || 'weekly';
        } else {
            console.warn('Frequency input not found, using default value "weekly"');
        }
        
        // Get AI model selection
        const aiModelSelect = document.getElementById('ai_model');
        let aiModel = 'gpt-4-turbo'; // Default model
        
        if (aiModelSelect) {
            aiModel = aiModelSelect.value;
        } else {
            console.warn('AI model select not found, using default model "gpt-4-turbo"');
        }
        
        // Prepare request payload
        const payload = {
            frequency: frequencyValue,
            topics: selectedTopics,
            content_types: selectedContentTypes,
            start_date: startDate || null,
            end_date: endDate || null,
            ai_model: aiModel
        };
        
        console.log('Sending compilation request with payload:', payload);
        
        // Send compilation request
        const response = await fetch('/api/newsletter/compile', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API returned status ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Compilation result:', data);
        
        // Log the entire response for debugging
        console.log('Full API response:', data);
        
        // Check if compilation has started and we have an ID for progress tracking
        if (data.message && data.message.includes('Newsletter compilation started with ID:')) {
            // Extract compilation ID
            const compilationId = data.message.split('ID: ')[1].trim();
            console.log('Compilation ID:', compilationId);
            
            // Update the compilation ID in the UI
            const compilationIdElement = document.getElementById('compilationID');
            if (compilationIdElement) {
                compilationIdElement.textContent = `Compilation ID: ${compilationId}`;
            }
            
            // Make sure loading spinner is visible with proper initial state
            showLoadingSpinner(compilationId);
            
            // Connect to WebSocket for progress updates
            connectToProgressWebsocket(compilationId);
            
            // Start polling for updates
            pollCompilationProgress(compilationId);
            
            // Don't modify editor content, use the progress display
            // Just return, the editor content will be updated when compilation is complete
            return;
        }
        
        // Update editor with compiled content when available
        if (data.compiled_markdown) {
            setMarkdownContent(data.compiled_markdown);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleString();
            }
            
            // Hide the spinner
            hideLoadingSpinner();
        } else if (data.result) {
            // Some API endpoints might return 'result' instead
            setMarkdownContent(data.result);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleString();
            }
            
            // Hide the spinner
            hideLoadingSpinner();
        } else {
            // Show the API message in the editor if no content
            if (data.message) {
                setMarkdownContent(`# Newsletter Compilation Status\n\n${data.message}\n\nPlease check the server logs for more details.`);
                console.warn('API returned a message but no content:', data.message);
            } else {
                throw new Error('No content returned from API');
            }
        }
        
    } catch (error) {
        console.error('Error compiling newsletter:', error);
        // Hide loading spinner on error
        hideLoadingSpinner();
        alert(`Error compiling newsletter: ${error.message}`);
    }
}

    // Function to connect to the WebSocket for real-time progress updates
function connectToProgressWebsocket(compilationId) {
    try {
        // Get the current protocol (http or https)
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Construct WebSocket URL using the current host
        const wsUrl = `${protocol}//${window.location.host}/ws/newsletter/progress/${compilationId}`;
        console.log(`Connecting to WebSocket: ${wsUrl}`);
        
        const socket = new WebSocket(wsUrl);
        
        socket.onopen = () => {
            console.log('WebSocket connection established');
        };
        
        socket.onmessage = (event) => {
            console.log('WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                updateProgressUI(data);
                
                // If compilation is complete, get the final result
                if (data.status === 'completed' && data.progress >= 100) {
                    fetchCompilationResult(compilationId);
                }
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };
        
        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        socket.onclose = () => {
            console.log('WebSocket connection closed');
        };
        
        // Store socket reference for cleanup
        window.newsletterWebSocket = socket;
    } catch (error) {
        console.error('Error connecting to WebSocket:', error);
    }
}

// Function to poll for compilation progress
function pollCompilationProgress(compilationId) {
    let pollingInterval = null;
    
    // Start polling
    pollingInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/newsletter/progress/${compilationId}`);
            
            if (!response.ok) {
                console.error(`Progress polling error: ${response.status}`);
                return;
            }
            
            const data = await response.json();
            console.log('Progress polling result:', data);
            
            // Update the UI
            updateProgressUI(data);
            
            // If we have the final result, update the editor and stop polling
            if ((data.status === 'completed' || data.progress >= 100) && data.result) {
                clearInterval(pollingInterval);
                hideLoadingSpinner();
                setMarkdownContent(data.result);
                
                // Update last updated time
                const lastUpdatedElement = document.getElementById('lastUpdated');
                if (lastUpdatedElement) {
                    const now = new Date();
                    lastUpdatedElement.textContent = now.toLocaleString();
                }
            }
        } catch (error) {
            console.error('Error polling for compilation progress:', error);
        }
    }, 2000); // Poll every 2 seconds
    
    // Store interval ID for cleanup
    window.newsletterPollingInterval = pollingInterval;
    
    // Auto-cleanup after 5 minutes (300000 ms) to prevent infinite polling
    setTimeout(() => {
        if (window.newsletterPollingInterval) {
            clearInterval(window.newsletterPollingInterval);
            window.newsletterPollingInterval = null;
        }
    }, 300000);
}

// Function to fetch the final compilation result
async function fetchCompilationResult(compilationId) {
    try {
        const response = await fetch(`/api/newsletter/progress/${compilationId}`);
        
        if (!response.ok) {
            throw new Error(`Failed to fetch compilation result: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Fetched final compilation result:', data);
        
        if (data.result) {
            hideLoadingSpinner();
            setMarkdownContent(data.result);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleString();
            }
            
            // Clean up WebSocket and polling
            cleanupProgressMonitoring();
        }
    } catch (error) {
        console.error('Error fetching compilation result:', error);
    }
}

// Function to update the progress UI
function updateProgressUI(data) {
    // Update progress bar
    const progressBar = document.getElementById('compilationProgress');
    if (progressBar) {
        const progress = Math.min(Math.max(data.progress || 0, 0), 100);
        progressBar.style.width = `${progress}%`;
        progressBar.setAttribute('aria-valuenow', progress);
        progressBar.textContent = `${Math.round(progress)}%`;
    }
    
    // Update status text
    const statusElement = document.getElementById('compilationStatus');
    if (statusElement) {
        statusElement.textContent = data.status === 'in_progress' ? 
            'Compilation in progress...' : 
            (data.status === 'completed' ? 'Compilation completed!' : data.status);
    }
    
    // Update step description
    const stepElement = document.getElementById('compilationStep');
    if (stepElement && data.current_step) {
        stepElement.textContent = data.current_step;
        if (data.message) {
            stepElement.textContent += `: ${data.message}`;
        }
    }
}

// Function to clean up progress monitoring
function cleanupProgressMonitoring() {
    // Close WebSocket if open
    if (window.newsletterWebSocket) {
        window.newsletterWebSocket.close();
        window.newsletterWebSocket = null;
    }
    
    // Clear polling interval if active
    if (window.newsletterPollingInterval) {
        clearInterval(window.newsletterPollingInterval);
        window.newsletterPollingInterval = null;
    }
}

// Helper function to hide the loading spinner
function hideLoadingSpinner() {
    const loadingSpinner = document.getElementById('loadingSpinner');
    if (loadingSpinner) {
        loadingSpinner.style.display = 'none';
    }
}

// Helper function to show and initialize the loading spinner
function showLoadingSpinner(compilationId) {
    const loadingSpinner = document.getElementById('loadingSpinner');
    if (!loadingSpinner) return;
    
    // Show the spinner
    loadingSpinner.style.display = 'block';
    
    // Initialize progress UI elements
    const progressBar = document.getElementById('compilationProgress');
    const statusElement = document.getElementById('compilationStatus');
    const stepElement = document.getElementById('compilationStep');
    
    if (progressBar) {
        progressBar.style.width = '0%';
        progressBar.setAttribute('aria-valuenow', 0);
        progressBar.textContent = '0%';
    }
    
    if (statusElement) {
        statusElement.textContent = 'Compilation in progress...';
    }
    
    if (stepElement) {
        stepElement.textContent = 'Starting compilation... This may take a few minutes.';
    }
    
    // Set compilation ID if available
    const compilationIdElement = document.getElementById('compilationID');
    if (compilationIdElement && compilationId) {
        compilationIdElement.textContent = `Compilation ID: ${compilationId}`;
    }
}

    // Function to save the prompt template
async function savePromptTemplate() {
    try {
        const contentTypeId = document.getElementById('promptEditorContentTypeId').value;
        const promptTemplate = document.getElementById('promptEditorText').value;
        
        if (!contentTypeId) {
            throw new Error('Content type ID is missing');
        }
        
        if (!promptTemplate || !promptTemplate.trim()) {
            throw new Error('Prompt template cannot be empty');
        }
        
        console.log(`Saving prompt for content type ${contentTypeId}`);
        
        // Prepare the request
        const payload = {
            prompt_template: promptTemplate
        };
        
        // Send update request
        const response = await fetch(`/api/newsletter/prompts/${contentTypeId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API returned status ${response.status}: ${errorText}`);
        }
        
        // Update the input field with the new value
        const promptInput = document.getElementById(`prompt-${contentTypeId}`);
        if (promptInput) {
            promptInput.value = promptTemplate;
        }
        
        // Hide the modal using native JavaScript
        const modal = document.getElementById('promptEditorModal');
        if (modal) {
            modal.classList.remove('show');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }
        
        // Show success message
        console.log('Prompt saved successfully');
        alert('Prompt saved successfully!');
        
    } catch (error) {
        console.error('Error saving prompt:', error);
        alert(`Error saving prompt: ${error.message}`);
    }
}

// Function to restore default prompt
function restoreDefaultPrompt() {
    try {
        const modalPromptTextarea = document.getElementById('promptEditorText');
        if (!modalPromptTextarea) {
            throw new Error('Prompt textarea not found');
        }
        
        // First try to restore the default prompt, fall back to original if not available
        if (modalPromptTextarea.dataset.defaultPrompt) {
            modalPromptTextarea.value = modalPromptTextarea.dataset.defaultPrompt;
        } else if (modalPromptTextarea.dataset.originalPrompt) {
            modalPromptTextarea.value = modalPromptTextarea.dataset.originalPrompt;
        } else {
            throw new Error('No default or original prompt available to restore');
        }
        
        console.log('Prompt restored to default');
    } catch (error) {
        console.error('Error restoring default prompt:', error);
        alert(`Error restoring default prompt: ${error.message}`);
    }
}

// Chart Selection Modal Functions
function openChartSelectionModal() {
    // Load previously selected charts
    const chartCheckboxes = document.querySelectorAll('#chartSelectionForm input[type="checkbox"]');
    chartCheckboxes.forEach(checkbox => {
        checkbox.checked = selectedCharts.includes(checkbox.value);
    });
    
    // Show modal
    const modal = document.getElementById('chartSelectionModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');
    }
}

function saveChartSelection() {
    // Get selected charts
    const chartCheckboxes = document.querySelectorAll('#chartSelectionForm input[type="checkbox"]:checked');
    selectedCharts = Array.from(chartCheckboxes).map(checkbox => checkbox.value);
    
    // Close modal
    closeChartSelectionModal();
    
    console.log('Selected charts:', selectedCharts);
}

function closeChartSelectionModal() {
    const modal = document.getElementById('chartSelectionModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
    }
}

// Save Newsletter Functions
function openSaveNewsletterModal() {
    // Generate a default filename
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    const frequency = document.getElementById('frequency').value;
    const topicsSelect = document.getElementById('topics');
    const topics = Array.from(topicsSelect.selectedOptions).map(option => option.textContent).join('_').toLowerCase();
    
    const defaultFilename = `${frequency}_${topics || 'newsletter'}_${dateStr}`;
    
    // Set default filename
    document.getElementById('newsletterFilename').value = defaultFilename;
    
    // Show modal
    const modal = document.getElementById('saveNewsletterModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');
    }
}

function closeSaveNewsletterModal() {
    const modal = document.getElementById('saveNewsletterModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
    }
}

async function saveNewsletterToServer() {
    try {
        const filename = document.getElementById('newsletterFilename').value.trim();
        if (!filename) {
            alert('Please enter a filename');
            return;
        }
        
        const markdownContent = getMarkdownContent();
        if (!markdownContent.trim()) {
            alert('No content to save');
            return;
        }
        
        // Close modal
        closeSaveNewsletterModal();
        
        // Show loading indicator
        const saveBtn = document.getElementById('saveNewsletterButton');
        const originalBtnText = saveBtn.innerHTML;
        saveBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Saving...';
        saveBtn.disabled = true;
        
        // Send save request
        const response = await fetch('/api/newsletter/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: markdownContent,
                filename: filename
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to save newsletter: ${errorText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            alert('Newsletter saved successfully!');
            // Refresh saved newsletters list
            loadSavedNewsletters();
        } else {
            throw new Error(result.error || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Error saving newsletter:', error);
        alert(`Error saving newsletter: ${error.message}`);
    } finally {
        // Restore button
        const saveBtn = document.getElementById('saveNewsletterButton');
        if (saveBtn) {
            saveBtn.innerHTML = '<i class="fa fa-save"></i> Save';
            saveBtn.disabled = false;
        }
    }
}

// Function to load saved newsletters
async function loadSavedNewsletters() {
    try {
        const container = document.getElementById('savedNewslettersContainer');
        if (!container) {
            console.error('savedNewslettersContainer element not found');
            return;
        }
        
        // Show loading
        container.innerHTML = '<div class="text-center text-muted py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Loading saved newsletters...</div>';
        
        console.log('Fetching saved newsletters from API...');
        const response = await fetch('/api/newsletter/saved');
        console.log('API response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`Failed to load saved newsletters: ${response.status} ${response.statusText}`);
        }
        
        const newsletters = await response.json();
        console.log('Loaded newsletters:', newsletters);
        
        // Clear container
        container.innerHTML = '';
        
        if (!Array.isArray(newsletters)) {
            console.error('API returned non-array response:', newsletters);
            container.innerHTML = '<div class="text-center text-danger py-3">Error: Invalid response format</div>';
            return;
        }
        
        if (newsletters.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No saved newsletters found</div>';
            return;
        }
        
        // Sort newsletters by date (most recent first)
        newsletters.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));
        
        // Create list items
        newsletters.forEach(newsletter => {
            try {
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    loadNewsletter(newsletter.id);
                });
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'd-flex flex-column';
                
                const title = document.createElement('strong');
                title.textContent = newsletter.filename || 'Unnamed Newsletter';
                contentDiv.appendChild(title);
                
                if (newsletter.date) {
                    const date = document.createElement('small');
                    date.className = 'text-muted';
                    date.textContent = new Date(newsletter.date).toLocaleString();
                    contentDiv.appendChild(date);
                }
                
                item.appendChild(contentDiv);
                
                const btnGroup = document.createElement('div');
                btnGroup.className = 'btn-group btn-group-sm';
                
                const editBtn = document.createElement('button');
                editBtn.type = 'button';
                editBtn.className = 'btn btn-outline-primary';
                editBtn.innerHTML = '<i class="fa fa-pencil"></i>';
                editBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    loadNewsletter(newsletter.id);
                });
                btnGroup.appendChild(editBtn);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'btn btn-outline-danger';
                deleteBtn.innerHTML = '<i class="fa fa-trash"></i>';
                deleteBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (confirm(`Are you sure you want to delete "${newsletter.filename}"?`)) {
                        deleteNewsletter(newsletter.id);
                    }
                });
                btnGroup.appendChild(deleteBtn);
                
                item.appendChild(btnGroup);
                container.appendChild(item);
            } catch (itemError) {
                console.error('Error creating newsletter item:', itemError, newsletter);
            }
        });
        
    } catch (error) {
        console.error('Error loading saved newsletters:', error);
        const container = document.getElementById('savedNewslettersContainer');
        if (container) {
            container.innerHTML = `<div class="text-center text-danger py-3">Error loading newsletters: ${error.message}</div>`;
        }
    }
}

// Function to load a saved newsletter
async function loadNewsletter(id) {
    try {
        const response = await fetch(`/api/newsletter/saved/${id}`);
        
        if (!response.ok) {
            throw new Error(`Failed to load newsletter: ${response.status}`);
        }
        
        const newsletter = await response.json();
        
        // Update editor with newsletter content
        if (newsletter.content) {
            setMarkdownContent(newsletter.content);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const dateStr = newsletter.date ? 
                    new Date(newsletter.date).toLocaleString() : 
                    'Just loaded';
                lastUpdatedElement.textContent = dateStr;
            }
        } else {
            throw new Error('No content found in the newsletter');
        }
        
    } catch (error) {
        console.error('Error loading newsletter:', error);
        alert(`Error loading newsletter: ${error.message}`);
    }
}

// Function to delete a saved newsletter
async function deleteNewsletter(id) {
    try {
        const response = await fetch(`/api/newsletter/saved/${id}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to delete newsletter: ${response.status}`);
        }
        
        // Refresh saved newsletters list
        loadSavedNewsletters();
        
    } catch (error) {
        console.error('Error deleting newsletter:', error);
        alert(`Error deleting newsletter: ${error.message}`);
    }
}

// PDF Export Function
async function downloadPDF() {
    try {
        const markdownContent = getMarkdownContent();
        
        if (!markdownContent.trim()) {
            alert('No content to convert to PDF');
            return;
        }
        
        // Show loading indicator
        const pdfBtn = document.getElementById('downloadPdfButton');
        const originalBtnText = pdfBtn.innerHTML;
        pdfBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Generating PDF...';
        pdfBtn.disabled = true;
        
        // Convert markdown to PDF
        const response = await fetch('/api/newsletter/export_pdf', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                markdown_content: markdownContent
            })
        });
        
        if (!response.ok) {
            throw new Error(`Failed to generate PDF: ${response.status}`);
        }
        
        // Get the PDF file as blob
        const blob = await response.blob();
        
        // Create filename with date
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        const frequency = document.getElementById('frequency').value;
        const topicsSelect = document.getElementById('topics');
        const topics = Array.from(topicsSelect.selectedOptions).map(option => option.value).join('-');
        
        const filename = `${frequency}_${topics || 'newsletter'}_${dateStr}.pdf`;
        
        // Create download link
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
    } catch (error) {
        console.error('Error generating PDF:', error);
        alert(`Error generating PDF: ${error.message}`);
    } finally {
        // Restore button
        const pdfBtn = document.getElementById('downloadPdfButton');
        if (pdfBtn) {
            pdfBtn.innerHTML = '<i class="fa fa-file-pdf-o"></i> Download PDF';
            pdfBtn.disabled = false;
        }
    }
}

// Send Email Function
async function sendEmailNewsletter() {
    try {
        // Get email recipients from user
        const recipients = prompt('Enter email addresses (comma-separated):');
        if (!recipients) return;
        
        const markdownContent = getMarkdownContent();
        if (!markdownContent.trim()) {
            alert('No content to send');
            return;
        }
        
        // Show loading indicator
        const emailBtn = document.getElementById('sendEmailButton');
        const originalBtnText = emailBtn.innerHTML;
        emailBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Sending...';
        emailBtn.disabled = true;
        
        // Create subject
        const frequency = document.getElementById('frequency').value;
        const topicsSelect = document.getElementById('topics');
        const topics = Array.from(topicsSelect.selectedOptions).map(option => option.textContent).join(', ');
        const today = new Date();
        const dateStr = today.toLocaleDateString();
        
        const subject = `${frequency.charAt(0).toUpperCase() + frequency.slice(1)} Newsletter: ${topics} - ${dateStr}`;
        
        // Send email request
        const response = await fetch('/api/newsletter/send_email', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                recipients: recipients.split(',').map(email => email.trim()),
                subject: subject,
                markdown_content: markdownContent
            })
        });
        
        if (!response.ok) {
            throw new Error(`Failed to send email: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            alert('Newsletter sent successfully!');
        } else {
            throw new Error(result.error || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Error sending email:', error);
        alert(`Error sending email: ${error.message}`);
    } finally {
        // Restore button
        const emailBtn = document.getElementById('sendEmailButton');
        if (emailBtn) {
            emailBtn.innerHTML = '<i class="fa fa-envelope"></i> Send Email';
            emailBtn.disabled = false;
        }
    }
}

// Function to save the current newsletter state to localStorage
function saveNewsletterState() {
    try {
        // Save editor content
        if (editor) {
            const content = getMarkdownContent();
            localStorage.setItem('newsletter_content', content);
        }
        
        // Save configuration
        const topicsSelect = document.getElementById('topics');
        const frequencySelect = document.getElementById('frequency');
        const aiModelSelect = document.getElementById('ai_model');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        
        const config = {
            topics: topicsSelect ? Array.from(topicsSelect.selectedOptions).map(opt => opt.value) : [],
            frequency: frequencySelect ? frequencySelect.value : 'weekly',
            aiModel: aiModelSelect ? aiModelSelect.value : 'gpt-4o',
            startDate: startDateInput ? startDateInput.value : '',
            endDate: endDateInput ? endDateInput.value : ''
        };
        
        localStorage.setItem('newsletter_config', JSON.stringify(config));
        console.log('Newsletter state saved to localStorage');
    } catch (e) {
        console.error('Error saving newsletter state:', e);
    }
}

// Function to check for and load any saved local state
function checkSavedState() {
    try {
        // Look for saved content in localStorage
        const savedContent = localStorage.getItem('newsletter_content');
        if (savedContent) {
            console.log('Found saved content in localStorage');
            // Set the editor content if we have the editor initialized
            if (editor) {
                editor.value(savedContent);
                updatePreview();
            }
        }
        
        // Load saved configuration from localStorage if available
        const savedConfig = localStorage.getItem('newsletter_config');
        if (savedConfig) {
            try {
                const config = JSON.parse(savedConfig);
                console.log('Found saved configuration', config);
                
                // Restore topic selections
                if (config.topics && Array.isArray(config.topics)) {
                    const topicSelect = document.getElementById('topics');
                    if (topicSelect) {
                        // Wait until topics are loaded
                        const checkTopicsInterval = setInterval(() => {
                            if (topicSelect.options.length > 0) {
                                clearInterval(checkTopicsInterval);
                                
                                // Select topics
                                for (let i = 0; i < topicSelect.options.length; i++) {
                                    topicSelect.options[i].selected = config.topics.includes(topicSelect.options[i].value);
                                }
                            }
                        }, 100);
                    }
                }
                
                // Restore frequency
                if (config.frequency) {
                    const frequencySelect = document.getElementById('frequency');
                    if (frequencySelect) {
                        frequencySelect.value = config.frequency;
                    }
                }
                
                // Restore AI model
                if (config.aiModel) {
                    const aiModelSelect = document.getElementById('ai_model');
                    if (aiModelSelect) {
                        aiModelSelect.value = config.aiModel;
                    }
                }
                
                // Restore date range
                if (config.startDate) {
                    document.getElementById('startDate').value = config.startDate;
                }
                if (config.endDate) {
                    document.getElementById('endDate').value = config.endDate;
                }
            } catch (e) {
                console.error('Error parsing saved configuration:', e);
                localStorage.removeItem('newsletter_config');
            }
        }
    } catch (e) {
        console.error('Error checking saved state:', e);
        // If there's an error, clear the saved state to prevent future errors
        localStorage.removeItem('newsletter_content');
        localStorage.removeItem('newsletter_config');
    }
}

// Initialize everything when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Load newsletter saved state if available
    checkSavedState();
    
    // Load saved newsletters
    loadSavedNewsletters();
    
    // Load available topics
    loadTopics();
    
    // Load content types
    loadContentTypes();
    
    // Add event listeners to save state when changes are made
    const topicsSelect = document.getElementById('topics');
    const frequencySelect = document.getElementById('frequency');
    const aiModelSelect = document.getElementById('ai_model');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    // Add event listeners for date range buttons
    const dayRangeBtn = document.getElementById('dayRangeBtn');
    const weekRangeBtn = document.getElementById('weekRangeBtn');
    const monthRangeBtn = document.getElementById('monthRangeBtn');
    
    if (dayRangeBtn) dayRangeBtn.addEventListener('click', setDayRange);
    if (weekRangeBtn) weekRangeBtn.addEventListener('click', setWeekRange);
    if (monthRangeBtn) monthRangeBtn.addEventListener('click', setMonthRange);
    
    // Save state when form elements change
    if (topicsSelect) topicsSelect.addEventListener('change', saveNewsletterState);
    if (frequencySelect) frequencySelect.addEventListener('change', saveNewsletterState);
    if (aiModelSelect) aiModelSelect.addEventListener('change', saveNewsletterState);
    if (startDateInput) {
        startDateInput.addEventListener('change', function() {
            saveNewsletterState();
            resetDateRangeButtonStyles();
        });
    }
    if (endDateInput) {
        endDateInput.addEventListener('change', function() {
            saveNewsletterState();
            resetDateRangeButtonStyles();
        });
    }
    
    // Add clear saved state button handler
    const clearSavedStateBtn = document.getElementById('clearSavedStateButton');
    if (clearSavedStateBtn) {
        clearSavedStateBtn.addEventListener('click', clearSavedState);
    }
    
    // Add event listener to save editor content when it changes
    if (editor) {
        editor.codemirror.on("change", function() {
            // Delay saving to avoid too many saves during typing
            clearTimeout(window.editorSaveTimeout);
            window.editorSaveTimeout = setTimeout(saveNewsletterState, 1000);
        });
    }
    
    // Set up action buttons
    const compileButton = document.getElementById('compileButton');
    const downloadMarkdownButton = document.getElementById('downloadMarkdownButton');
    const downloadPdfButton = document.getElementById('downloadPdfButton');
    const saveToServerButton = document.getElementById('saveToServerButton');
    const sendEmailButton = document.getElementById('sendEmailButton');
    const sendSlackButton = document.getElementById('sendSlackButton');
    
    if (compileButton) compileButton.addEventListener('click', compileNewsletter);
    if (downloadMarkdownButton) downloadMarkdownButton.addEventListener('click', downloadMarkdown);
    if (downloadPdfButton) downloadPdfButton.addEventListener('click', downloadPDF);
    if (saveToServerButton) saveToServerButton.addEventListener('click', openSaveNewsletterModal);
    if (sendEmailButton) sendEmailButton.addEventListener('click', sendEmailNewsletter);
    if (sendSlackButton) sendSlackButton.addEventListener('click', function() {
        alert('Slack integration not implemented yet.');
    });
    
    // Set up save newsletter modal buttons
    const closeSaveNewsletterModalBtn = document.getElementById('closeSaveNewsletterModal');
    const cancelSaveNewsletterModalBtn = document.getElementById('cancelSaveNewsletterModal');
    const saveNewsletterBtn = document.getElementById('saveNewsletterButton');
    
    if (closeSaveNewsletterModalBtn) closeSaveNewsletterModalBtn.addEventListener('click', closeSaveNewsletterModal);
    if (cancelSaveNewsletterModalBtn) cancelSaveNewsletterModalBtn.addEventListener('click', closeSaveNewsletterModal);
    if (saveNewsletterBtn) saveNewsletterBtn.addEventListener('click', saveNewsletterToServer);
    
    // Set up select all content types button
    const selectAllContentTypesBtn = document.getElementById('selectAllContentTypes');
    if (selectAllContentTypesBtn) {
        selectAllContentTypesBtn.addEventListener('click', toggleSelectAllContentTypes);
    }
    
    // Set up events for modals
    const closePodcastSelectionModalBtn = document.getElementById('closePodcastSelectionModal');
    const cancelPodcastSelectionModalBtn = document.getElementById('cancelPodcastSelectionModal');
    const savePodcastSelectionBtn = document.getElementById('savePodcastSelectionButton');
    
    if (closePodcastSelectionModalBtn) {
        closePodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (cancelPodcastSelectionModalBtn) {
        cancelPodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (savePodcastSelectionBtn) {
        savePodcastSelectionBtn.addEventListener('click', savePodcastSelection);
    }
    
    // Setup article search modal
    const closeArticleSelectionModalBtn = document.getElementById('closeArticleSelectionModal');
    const cancelArticleSelectionModalBtn = document.getElementById('cancelArticleSelectionModal');
    const saveArticleSelectionBtn = document.getElementById('saveArticleSelectionButton');
    const articleSearchBtn = document.getElementById('articleSearchButton');
    
    if (closeArticleSelectionModalBtn) {
        closeArticleSelectionModalBtn.addEventListener('click', closeArticleSelectionModal);
    }
    
    if (cancelArticleSelectionModalBtn) {
        cancelArticleSelectionModalBtn.addEventListener('click', closeArticleSelectionModal);
    }
    
    if (saveArticleSelectionBtn) {
        saveArticleSelectionBtn.addEventListener('click', saveArticleSelection);
    }
    
    if (articleSearchBtn) {
        articleSearchBtn.addEventListener('click', searchArticles);
    }
    
    // Load topics for the article search dropdown
    loadTopicsForArticleSearch();
});

// Podcast Selection Modal Functions
let selectedPodcast = null;

function openPodcastSelectionModal() {
    // Load podcasts from API
    loadPodcasts();
    
    // Show modal
    const modal = document.getElementById('podcastSelectionModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');
    }
}

async function loadPodcasts() {
    try {
        const container = document.getElementById('podcastListContainer');
        if (!container) return;
        
        // Show loading
        container.innerHTML = '<div class="text-center py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Loading podcasts...</div>';
        
        // Fetch podcasts from API
        const response = await fetch('/api/newsletter/podcasts');
        
        if (!response.ok) {
            throw new Error(`Failed to load podcasts: ${response.status}`);
        }
        
        const podcasts = await response.json();
        
        // Clear container
        container.innerHTML = '';
        
        if (podcasts.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No podcasts found</div>';
            return;
        }
        
        // Create list items for each podcast
        podcasts.forEach(podcast => {
            const item = document.createElement('a');
            item.href = '#';
            item.className = 'list-group-item list-group-item-action';
            item.dataset.podcastId = podcast.id;
            
            // Create podcast item content
            const title = document.createElement('h5');
            title.className = 'mb-1';
            title.textContent = podcast.title || 'Untitled Podcast';
            
            const details = document.createElement('div');
            details.className = 'small text-muted';
            
            // Format created date if available
            let dateText = '';
            if (podcast.created_at) {
                dateText = new Date(podcast.created_at).toLocaleDateString();
            }
            
            // Add topic if available
            let topicText = '';
            if (podcast.topic) {
                topicText = `Topic: ${podcast.topic}`;
            }
            
            details.textContent = [dateText, topicText].filter(Boolean).join(' | ');
            
            item.appendChild(title);
            item.appendChild(details);
            
            // Add click handler to select this podcast
            item.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Deselect any previously selected podcast
                document.querySelectorAll('#podcastListContainer .list-group-item.active').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Select this podcast
                item.classList.add('active');
                selectedPodcast = podcast;
            });
            
            container.appendChild(item);
        });
        
    } catch (error) {
        console.error('Error loading podcasts:', error);
        const container = document.getElementById('podcastListContainer');
        if (container) {
            container.innerHTML = `<div class="text-center text-danger py-3">Error loading podcasts: ${error.message}</div>`;
        }
    }
}

function savePodcastSelection() {
    if (!selectedPodcast) {
        alert('Please select a podcast first');
        return;
    }
    
    // Insert selected podcast into the editor
    let podcastContent = `## Latest Podcast: ${selectedPodcast.title || 'Podcast'}\n\n`;
    
    if (selectedPodcast.created_at) {
        const date = new Date(selectedPodcast.created_at).toLocaleDateString();
        podcastContent += `**Published:** ${date}\n\n`;
    }
    
    if (selectedPodcast.audio_url) {
        podcastContent += `[** Listen Now**](${selectedPodcast.audio_url})\n\n`;
    }
    
    if (selectedPodcast.topic) {
        podcastContent += `**Topic:** ${selectedPodcast.topic}\n\n`;
    }
    
    podcastContent += "**Summary:** Listen to our latest podcast episode covering important developments and insights.\n\n";
    
    // Add the podcast content to the editor
    const currentContent = getMarkdownContent();
    setMarkdownContent(currentContent + "\n\n" + podcastContent);
    
    // Close modal
    closePodcastSelectionModal();
}

function closePodcastSelectionModal() {
    const modal = document.getElementById('podcastSelectionModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
    }
}

// Add new modal event handlers in the DOMContentLoaded event
document.addEventListener('DOMContentLoaded', function() {
    // Set up podcast selection modal buttons
    const closePodcastSelectionModalBtn = document.getElementById('closePodcastSelectionModal');
    const cancelPodcastSelectionModalBtn = document.getElementById('cancelPodcastSelectionModal');
    const savePodcastSelectionBtn = document.getElementById('savePodcastSelectionButton');
    
    if (closePodcastSelectionModalBtn) {
        closePodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (cancelPodcastSelectionModalBtn) {
        cancelPodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (savePodcastSelectionBtn) {
        savePodcastSelectionBtn.addEventListener('click', savePodcastSelection);
    }
});

// Article Selection Modal Functions
function openArticleSelectionModal() {
    // Show the article selection modal
    const modal = document.getElementById('articleSelectionModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');
    }
}

function closeArticleSelectionModal() {
    // Hide the article selection modal
    const modal = document.getElementById('articleSelectionModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
    }
}

function saveArticleSelection() {
    // Get selected articles
    const selectedArticles = document.querySelectorAll('#selectedArticlesList .list-group-item');
    const selectedArticlesData = Array.from(selectedArticles).map(article => {
        return {
            title: article.querySelector('strong').textContent,
            url: article.querySelector('a').href,
            source: article.querySelector('small').textContent
        };
    });
    
    // Insert selected articles into the editor
    let articleContent = '';
    selectedArticlesData.forEach(article => {
        articleContent += `## ${article.title}\n\n${article.url}\n\n**Source:** ${article.source}\n\n`;
    });
    
    // Add the article content to the editor
    const currentContent = getMarkdownContent();
    setMarkdownContent(currentContent + "\n\n" + articleContent);
    
    // Close modal
    closeArticleSelectionModal();
}

// Add new event listeners for article selection
document.addEventListener('DOMContentLoaded', function() {
    // Set up article selection modal buttons
    const closeArticleSelectionModalBtn = document.getElementById('closeArticleSelectionModal');
    const cancelArticleSelectionModalBtn = document.getElementById('cancelArticleSelectionModal');
    const saveArticleSelectionBtn = document.getElementById('saveArticleSelectionButton');
    
    if (closeArticleSelectionModalBtn) {
        closeArticleSelectionModalBtn.addEventListener('click', closeArticleSelectionModal);
    }
    
    if (cancelArticleSelectionModalBtn) {
        cancelArticleSelectionModalBtn.addEventListener('click', closeArticleSelectionModal);
    }
    
    if (saveArticleSelectionBtn) {
        saveArticleSelectionBtn.addEventListener('click', saveArticleSelection);
    }
});

// Function to load topics for article search dropdown
async function loadTopicsForArticleSearch() {
    try {
        const topicSelect = document.getElementById('articleSearchTopic');
        if (!topicSelect) return;
        
        // Clear existing options except the first one (All Topics)
        const firstOption = topicSelect.options[0];
        topicSelect.innerHTML = '';
        topicSelect.appendChild(firstOption);
        
        // Fetch topics from API
        const response = await fetch('/api/newsletter/topics');
        
        if (!response.ok) {
            throw new Error(`Failed to load topics: ${response.status}`);
        }
        
        const topics = await response.json();
        
        // Add topic options
        topics.forEach(topic => {
            const option = document.createElement('option');
            option.value = topic;
            option.textContent = topic;
            topicSelect.appendChild(option);
        });
        
    } catch (error) {
        console.error('Error loading topics for article search:', error);
    }
}

// Function to search for articles
async function searchArticles() {
    try {
        const container = document.getElementById('articleListContainer');
        if (!container) return;
        
        // Get search parameters
        const query = document.getElementById('articleSearchQuery').value;
        const topic = document.getElementById('articleSearchTopic').value;
        const startDate = document.getElementById('articleSearchStartDate').value;
        const endDate = document.getElementById('articleSearchEndDate').value;
        
        // Show loading
        container.innerHTML = '<div class="text-center py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Searching articles...</div>';
        
        // Build query string
        let queryParams = new URLSearchParams();
        if (query) queryParams.append('query', query);
        if (topic) queryParams.append('topic', topic);
        if (startDate) queryParams.append('start_date', startDate);
        if (endDate) queryParams.append('end_date', endDate);
        
        // Fetch articles from API
        const response = await fetch(`/api/newsletter/articles/search?${queryParams.toString()}`);
        
        if (!response.ok) {
            throw new Error(`Failed to search articles: ${response.status}`);
        }
        
        const articles = await response.json();
        
        // Clear container
        container.innerHTML = '';
        
        if (articles.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No articles found matching your criteria</div>';
            return;
        }
        
        // Create list items for each article
        articles.forEach(article => {
            const item = document.createElement('div');
            item.className = 'list-group-item';
            item.dataset.articleId = article.id;
            
            // Create article item content
            const title = document.createElement('h5');
            title.className = 'mb-1';
            title.textContent = article.title || 'Untitled Article';
            
            const details = document.createElement('div');
            details.className = 'small text-muted mb-2';
            
            // Format publication date if available
            let dateText = '';
            if (article.publication_date) {
                dateText = `Published: ${article.publication_date}`;
            }
            
            // Add source if available
            let sourceText = '';
            if (article.news_source) {
                sourceText = `Source: ${article.news_source}`;
            }
            
            details.textContent = [dateText, sourceText].filter(Boolean).join(' | ');
            
            // Add summary if available
            const summary = document.createElement('p');
            summary.className = 'mb-2';
            summary.textContent = article.summary || 'No summary available';
            
            // Add URI if available
            const uri = document.createElement('a');
            uri.href = article.uri || '#';
            uri.className = 'small';
            uri.textContent = article.uri || '';
            uri.target = '_blank';
            
            // Add button to select this article
            const selectBtn = document.createElement('button');
            selectBtn.type = 'button';
            selectBtn.className = 'btn btn-sm btn-outline-primary mt-2';
            selectBtn.textContent = 'Add to Selection';
            selectBtn.addEventListener('click', () => {
                addArticleToSelection(article);
                selectBtn.disabled = true;
                selectBtn.textContent = 'Added';
            });
            
            item.appendChild(title);
            item.appendChild(details);
            item.appendChild(summary);
            item.appendChild(uri);
            item.appendChild(selectBtn);
            
            container.appendChild(item);
        });
        
    } catch (error) {
        console.error('Error searching articles:', error);
        const container = document.getElementById('articleListContainer');
        if (container) {
            container.innerHTML = `<div class="text-center text-danger py-3">Error searching articles: ${error.message}</div>`;
        }
    }
}

// Function to add an article to the selection
function addArticleToSelection(article) {
    const container = document.getElementById('selectedArticlesList');
    if (!container) return;
    
    // Create a list item for the selected article
    const item = document.createElement('div');
    item.className = 'list-group-item d-flex justify-content-between align-items-center';
    item.dataset.articleId = article.id;
    
    // Create article details
    const details = document.createElement('div');
    
    const title = document.createElement('strong');
    title.textContent = article.title || 'Untitled Article';
    
    const source = document.createElement('small');
    source.className = 'd-block text-muted';
    source.textContent = article.news_source || 'Unknown Source';
    
    const link = document.createElement('a');
    link.href = article.uri || '#';
    link.className = 'd-block small';
    link.textContent = article.uri || '';
    link.target = '_blank';
    
    details.appendChild(title);
    details.appendChild(source);
    details.appendChild(link);
    
    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-sm btn-outline-danger';
    removeBtn.innerHTML = '<i class="fa fa-times"></i>';
    removeBtn.addEventListener('click', () => {
        item.remove();
        updateSelectedArticlesCount();
    });
    
    item.appendChild(details);
    item.appendChild(removeBtn);
    
    container.appendChild(item);
    
    // Update the count
    updateSelectedArticlesCount();
}

// Function to update the selected articles count
function updateSelectedArticlesCount() {
    const container = document.getElementById('selectedArticlesList');
    const countEl = document.getElementById('selectedArticlesCount');
    
    if (container && countEl) {
        const count = container.querySelectorAll('.list-group-item').length;
        countEl.textContent = count;
    }
}

// Function to add the selected articles to the editor
function saveArticleSelection() {
    const selectedArticles = document.querySelectorAll('#selectedArticlesList .list-group-item');
    if (selectedArticles.length === 0) {
        alert('Please select at least one article');
        return;
    }
    
    // Create the markdown content
    let markdownContent = "## Selected Articles\n\n";
    
    selectedArticles.forEach(articleEl => {
        const title = articleEl.querySelector('strong').textContent;
        const source = articleEl.querySelector('small').textContent;
        const link = articleEl.querySelector('a').getAttribute('href');
        
        markdownContent += `### ${title}\n`;
        markdownContent += `${link} | ${source}\n\n`;
    });
    
    // Add to editor
    const currentContent = getMarkdownContent();
    setMarkdownContent(currentContent + "\n\n" + markdownContent);
    
    // Clear selection and close modal
    document.getElementById('selectedArticlesList').innerHTML = '';
    updateSelectedArticlesCount();
    closeArticleSelectionModal();
}

// Helper function to format dates for input fields (YYYY-MM-DD)
function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Function to set date range to the last 24 hours
function setDayRange() {
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    if (startDateInput && endDateInput) {
        startDateInput.value = formatDateForInput(yesterday);
        endDateInput.value = formatDateForInput(today);
        
        // Update button styles
        setActiveDateRangeButton('dayRangeBtn');
        
        // Trigger save state
        saveNewsletterState();
    }
}

// Function to set date range to the last 7 days
function setWeekRange() {
    const today = new Date();
    const lastWeek = new Date(today);
    lastWeek.setDate(lastWeek.getDate() - 7);
    
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    if (startDateInput && endDateInput) {
        startDateInput.value = formatDateForInput(lastWeek);
        endDateInput.value = formatDateForInput(today);
        
        // Update button styles
        setActiveDateRangeButton('weekRangeBtn');
        
        // Trigger save state
        saveNewsletterState();
    }
}

// Function to set date range to the last 30 days
function setMonthRange() {
    const today = new Date();
    const lastMonth = new Date(today);
    lastMonth.setDate(lastMonth.getDate() - 30);
    
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    if (startDateInput && endDateInput) {
        startDateInput.value = formatDateForInput(lastMonth);
        endDateInput.value = formatDateForInput(today);
        
        // Update button styles
        setActiveDateRangeButton('monthRangeBtn');
        
        // Trigger save state
        saveNewsletterState();
    }
}

// Helper function to reset all date range button styles to default
function resetDateRangeButtonStyles() {
    const rangeButtons = ['dayRangeBtn', 'weekRangeBtn', 'monthRangeBtn'];
    
    rangeButtons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.classList.remove('active');
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-outline-secondary');
        }
    });
}

// Helper function to set active date range button
function setActiveDateRangeButton(activeButtonId) {
    // Get all date range buttons
    const rangeButtons = ['dayRangeBtn', 'weekRangeBtn', 'monthRangeBtn'];
    
    // Remove active class from all buttons
    rangeButtons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.classList.remove('active');
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-outline-secondary');
        }
    });
    
    // Add active class to selected button
    const activeBtn = document.getElementById(activeButtonId);
    if (activeBtn) {
        activeBtn.classList.remove('btn-outline-secondary');
        activeBtn.classList.add('btn-secondary');
        activeBtn.classList.add('active');
    }
}

// Function to clear saved newsletter state
function clearSavedState() {
    try {
        // Clear localStorage items
        localStorage.removeItem('newsletter_content');
        localStorage.removeItem('newsletter_config');
        console.log('Newsletter saved state cleared');
        
        // Show confirmation message
        alert('Saved newsletter state has been cleared. Refresh the page to reset all fields.');
    } catch (e) {
        console.error('Error clearing saved state:', e);
        alert('Error clearing saved state: ' + e.message);
    }
}

// Function to toggle all content type checkboxes
function toggleSelectAllContentTypes() {
    const checkboxes = document.querySelectorAll('.content-type-checkbox');
    
    // First determine if all checkboxes are already checked
    const allChecked = Array.from(checkboxes).every(checkbox => checkbox.checked);
    
    // Toggle all checkboxes based on current state
    checkboxes.forEach(checkbox => {
        checkbox.checked = !allChecked;
    });
    
    // Update the button text
    const selectAllBtn = document.getElementById('selectAllContentTypes');
    if (selectAllBtn) {
        selectAllBtn.textContent = allChecked ? 'Select All' : 'Deselect All';
    }
    
    // Save the updated state
    saveNewsletterState();
}

//
</script>
{% endblock %} 