{% extends "base.html" %}

{% block title %}Newsletter Composer{% endblock %}

{% block styles %}

<!-- SimpleMDE Markdown Editor CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simplemde@1.11.2/dist/simplemde.min.css">
<!-- Font Awesome for editor toolbar icons - using preload to prioritize loading -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" as="style">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Highlight.js for code syntax highlighting -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.min.css">
<style>
    /* Custom container styling */
    .newsletter-container {
        padding: 20px;
        max-width: 100%;
    }
    
    /* Custom button styles */
    .btn-pink {
        background-color: #ff69b4;
        color: white;
    }
    
    .btn-pink:hover {
        background-color: #ff5ba7;
        color: white;
    }
    
    .btn-blue {
        background-color: #4169E1;
        color: white;
    }
    
    .btn-blue:hover {
        background-color: #3a5ecc;
        color: white;
    }
    
    .btn-green {
        background-color: #4CAF50;
        color: white;
    }
    
    .btn-green:hover {
        background-color: #45a049;
        color: white;
    }
    
    .btn-yellow {
        background-color: #FFD700;
        color: black;
    }
    
    .btn-yellow:hover {
        background-color: #f1cc00;
        color: black;
    }
    
    /* Custom form select styling */
    .form-select {
        font-weight: bold;
        text-transform: uppercase;
    }

    #editorPane { 
        height: 500px;
        position: relative;
        border: none;
        padding: 0;
    }
    
    #previewPane {
        height: 500px;
        border: 1px solid #ccc;
        box-sizing: border-box;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        padding: 10px;
        overflow-y: auto;
    }
    
    /* SimpleMDE Specific Overrides and Styling */
    .editor-toolbar {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-bottom: none;
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
        opacity: 1 !important;
        padding: 4px;
    }

    .editor-toolbar a {
        color: #495057 !important;
        border: 1px solid transparent !important;
        margin: 2px !important;
        width: 30px !important;
        height: 30px !important;
        text-align: center;
        line-height: 30px !important;
    }

    .editor-toolbar a:before {
        line-height: 30px !important;
    }

    .editor-toolbar a.active,
    .editor-toolbar a:hover {
        background: #e9ecef !important;
        border-color: #ced4da !important;
        color: #000 !important;
    }
    
    .CodeMirror-fullscreen, .editor-preview-full {
        z-index: 1050 !important;
    }

    /* Ensure CodeMirror (editor area) fits within #editorPane and card */
    .CodeMirror {
        height: 100% !important;
        border: 1px solid #dee2e6 !important;
        border-top: none !important;
        border-bottom-left-radius: 4px;
        border-bottom-right-radius: 4px;
        font-size: 16px;
        line-height: 1.5;
        padding: 10px;
        box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    }

    /* Fix cursor visibility issues */
    .CodeMirror-cursor {
        border-left: 1px solid black !important;
        border-right: none !important;
        width: 0 !important;
        opacity: 1 !important;
    }
    
    /* Improve focus and selection styling */
    .CodeMirror-focused .CodeMirror-selected {
        background: rgba(0, 0, 255, 0.1) !important;
    }
    
    /* Make sure cursor is visible in editor */
    .CodeMirror pre.CodeMirror-line, 
    .CodeMirror pre.CodeMirror-line-like {
        z-index: 1;
    }

    .CodeMirror-scroll {
        min-height: 450px;
    }
    
    .editor-preview-side {
        z-index: 100;
        border-left: 1px solid #dee2e6 !important; 
    }
    
    #htmlPreview {
        height: 100%;
        overflow-y: auto;
        padding: 15px;
    }
    
    .control-panel {
        margin-bottom: 20px;
    }
    
    .form-group {
        margin-bottom: 15px;
    }
    
    .content-type-item {
        margin: 10px 0;
    }
    
    .loading-spinner {
        display: none;
        text-align: center;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        padding: 25px;
        max-width: 90%;
        width: 500px;
    }

    .editor-section {
        margin-bottom: 20px;
    }
    
    .editor-card { 
        background-color: white;
        border-radius: 0.25rem;
        margin-bottom: 20px;
        overflow: hidden; 
    }
    
    .editor-card-header {
        padding: 0.75rem 1.25rem;
        margin-bottom: 0;
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        border-top-left-radius: calc(0.25rem - 1px);
        border-top-right-radius: calc(0.25rem - 1px);
    }

    .editor-card-header h5 {
        margin-bottom: 0;
        font-size: 1rem;
        font-weight: 500;
    }
    
    /* Style for code blocks in preview */
    #htmlPreview pre {
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 10px;
    }
    
    #htmlPreview code {
        font-family: 'Courier New', Courier, monospace;
    }
    
    @media (max-width: 768px) {
        #editorPane, #previewPane {
            height: 400px;
        }
        .CodeMirror-scroll {
            min-height: 350px; 
        }
    }

    /* Ensure Font Awesome icons display correctly in the toolbar */
    .editor-toolbar a:before {
        font-family: FontAwesome, sans-serif !important;
        display: inline-block;
        font-size: 16px;
        width: 100%;
        text-align: center;
    }
    
    /* Fix specific icon issues by providing direct icon code points */
    .editor-toolbar a.fa-header:before { content: "\f1dc"; }
    .editor-toolbar a.fa-bold:before { content: "\f032"; }
    .editor-toolbar a.fa-italic:before { content: "\f033"; }
    .editor-toolbar a.fa-strikethrough:before { content: "\f0cc"; }
    .editor-toolbar a.fa-link:before { content: "\f0c1"; }
    .editor-toolbar a.fa-quote-left:before { content: "\f10d"; }
    .editor-toolbar a.fa-list-ul:before { content: "\f0ca"; }
    .editor-toolbar a.fa-list-ol:before { content: "\f0cb"; }
    .editor-toolbar a.fa-table:before { content: "\f0ce"; }
    .editor-toolbar a.fa-picture-o:before { content: "\f03e"; }
    .editor-toolbar a.fa-code:before { content: "\f121"; }
    .editor-toolbar a.fa-question-circle:before { content: "\f059"; }
    .editor-toolbar a.fa-eye:before { content: "\f06e"; }
    .editor-toolbar a.fa-columns:before { content: "\f0db"; }
    .editor-toolbar a.fa-arrows-alt:before { content: "\f0b2"; }
    .editor-toolbar a.fa-minus:before { content: "\f068"; }

    /* Improved content type selection layout */
    .content-types-container {
        display: block;
        margin-bottom: 15px;
    }
    
    .content-type-item {
        padding: 8px 12px;
        margin-bottom: 8px;
        border: 1px solid #eee;
        border-radius: 4px;
        background-color: #f9f9f9;
    }
    
    .content-type-checkbox-wrapper {
        display: flex;
        align-items: center;
    }
    
    .content-type-item label {
        font-weight: 500;
        margin-left: 8px;
        margin-bottom: 0;
        cursor: pointer;
    }
    
    .content-type-item small {
        display: block;
        margin-left: 25px;
        margin-top: 5px;
        color: #6c757d;
    }
    
    /* Control chart sizes in the preview - more aggressive size limitations */
    .preview-container img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 15px auto;
    }
    
    /* Specifically target chart images to ensure they're not too large */
    .preview-container img[src*="chart"], 
    .preview-container img[alt*="Chart"],
    .preview-container img[alt*="chart"],
    .preview-container img[src*="sentiment"],
    .preview-container img[src*="radar"],
    .preview-container img[src*="graph"] {
        max-width: 550px;
        max-height: 400px;
        width: auto !important;
        height: auto !important;
        object-fit: contain;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 5px;
        background-color: white;
    }
    
    /* Ensure the loading spinner is centered and visible */
    #loadingSpinner {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
    }

    /* Navigation styles */
    .breadcrumb-container {
        background-color: #f5f5f5;
        padding: 8px 15px;
        margin-bottom: 20px;
        border-radius: 4px;
    }
    
    .breadcrumb {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
    }
    
    .breadcrumb-item {
        display: inline-block;
        margin-right: 5px;
    }
    
    .breadcrumb-item + .breadcrumb-item::before {
        content: "/";
        padding: 0 5px;
        color: #6c757d;
    }

    /* Add tooltip styles */
    .tooltip-inner {
        max-width: 300px;
        padding: 8px 12px;
        font-size: 14px;
        line-height: 1.4;
    }

    [data-toggle="tooltip"] {
        cursor: help;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid newsletter-container" id="newsletterCompilerApp">
    <h1>Newsletter Composer</h1>
    
    <!-- Row 1: Newsletter Configuration -->
    <div class="row mb-4">
        <div class="col-md-12">
            <!-- Newsletter Configuration Form -->
            <div class="card">
                <div class="card-header">
                    <h5>Newsletter Configuration</h5>
                </div>
                <div class="card-body">
                    <form id="newsletterForm">
                        <div class="row">
                            <div class="col-md-8">
                                <div class="form-group">
                                    <label for="topics" data-toggle="tooltip" data-placement="right" 
                                           title="Select one or more topics to include in your newsletter">Topics:</label>
                                    <select class="form-control" id="topics" name="topics" multiple required
                                            data-toggle="tooltip" data-placement="right" 
                                            title="Hold Ctrl/Cmd to select multiple topics. These will be the main subjects covered in your newsletter">
                                        <!-- Will be populated via API -->
                                        <option value="" disabled>Loading topics...</option>
                                    </select>
                                    <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple topics</small>
                                </div>
                            </div>
                            <div class="col-md-4">
                                                            <div class="row">
                                <!-- Removed the frequency selector here because it's now in the actions card -->
                                <div class="col-md-12">
                                    <div class="form-group">
                                        <label for="ai_model" data-toggle="tooltip" data-placement="right" 
                                               title="Select which AI model to use">AI Model:</label>
                                        <select class="form-control" id="ai_model" name="ai_model" required
                                                data-toggle="tooltip" data-placement="right" 
                                                title="Different AI models have different capabilities">
                                            <option value="gpt-4o" selected>GPT-4o</option>
                                            <option value="gpt-4o-mini">GPT-4o Mini</option>
                                            <option value="gpt-4.1">GPT-4.1</option>
                                            <option value="gpt-4.1-mini">GPT-4.1 Mini</option>
                                            <option value="gpt-4.1-nano">GPT-4.1 Nano</option>
                                            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                                            <option value="claude-3-7-sonnet-latest">Claude 3.7 Sonnet</option>
                                            <option value="claude-3-5-sonnet-latest">Claude 3.5 Sonnet</option>
                                            <option value="mixtral-8x7b">Mixtral 8x7B</option>
                                            <option value="gemini-pro">Gemini Pro</option>
                                        </select>
                                    </div>
                                </div>
                                <!-- Frequency selector is now visible in the actions card -->
                                <div class="col-md-12 d-none">
                                    <!-- Hidden placeholder to maintain structure -->
                                </div>
                            </div>
                            </div>
                        </div>
                        
                        <!-- Content Types Table -->
                        <div class="form-group">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label data-toggle="tooltip" data-placement="right" 
                                       title="Choose which types of content to include in your newsletter">Content Types and Prompts:</label>
                                <button type="button" id="selectAllContentTypes" class="btn btn-sm btn-primary"
                                        data-toggle="tooltip" data-placement="right" 
                                        title="Toggle selection of all content types">Select All</button>
                            </div>
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Content Type</th>
                                        <th class="text-center">Include</th>
                                        <th class="text-right">Action</th>
                                    </tr>
                                </thead>
                                <tbody id="contentTypesTable">
                                    <tr>
                                        <td colspan="3" class="text-muted">Loading content types...</td>
                                    </tr>
                                </tbody>
                            </table>
                            
                            
    

                            
                                <!-- Additional Reading Selection Option -->
    <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center">
            <h6 class="mb-0">Additional Reading</h6>
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="includeArticles">
                <label class="form-check-label" for="includeArticles">
                    Include
                </label>
            </div>
        </div>
        <div class="mt-2">
            <button id="selectArticlesButton" type="button" class="btn btn-outline-secondary btn-sm" onclick="openArticleSelectionModal()">
                <i class="fa fa-newspaper"></i> Select Articles
            </button>
            <small class="text-muted ms-2" id="selectedArticlesCount">No articles selected</small>
        </div>
    </div>
                        </div>
                        
                        <div class="form-group">
                            <label data-toggle="tooltip" data-placement="right" 
                                   title="Optionally specify a custom date range for the newsletter content">Date Range (Optional):</label>
                            <div class="row mb-2">
                                <div class="col-auto">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="dayRangeBtn"
                                            data-toggle="tooltip" data-placement="top" 
                                            title="Set date range to last 24 hours">Day</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="weekRangeBtn"
                                            data-toggle="tooltip" data-placement="top" 
                                            title="Set date range to last 7 days">Week</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="monthRangeBtn"
                                            data-toggle="tooltip" data-placement="top" 
                                            title="Set date range to last 30 days">Month</button>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <label for="startDate" data-toggle="tooltip" data-placement="right" 
                                           title="Start date for newsletter content">Start Date:</label>
                                    <input type="date" class="form-control" id="startDate" name="startDate"
                                           data-toggle="tooltip" data-placement="right" 
                                           title="Select the start date for content inclusion">
                                </div>
                                <div class="col-md-6">
                                    <label for="endDate" data-toggle="tooltip" data-placement="right" 
                                           title="End date for newsletter content">End Date:</label>
                                    <input type="date" class="form-control" id="endDate" name="endDate"
                                           data-toggle="tooltip" data-placement="right" 
                                           title="Select the end date for content inclusion">
                                </div>
                            </div>
                            <small class="form-text text-muted">If not specified, dates will be calculated based on frequency</small>
                        </div>
                        
                        <div class="card-footer d-flex justify-content-between">
                            <div>
                                <span class="text-muted">Last updated: <span id="lastUpdated" data-toggle="tooltip" data-placement="top" title="'Never' means no newsletter has been generated yet. Generate content or load a saved newsletter to update this.">Never</span></span>
                                <span class="d-inline-block ms-2" data-toggle="tooltip" data-placement="right" title="The last time the newsletter content was generated or saved">
                                    <i class="fa fa-question-circle"></i>
                                </span>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
        <!-- Row 2: Actions -->
    <div class="row mb-4">
        <div class="col-md-12">
            <!-- Action Buttons -->
                            <div class="card">
                <div class="card-header">
                    <h5 class="text-secondary">ACTIONS</h5>
                </div>
                <div class="card-body">
                    <div class="d-flex flex-wrap justify-content-between">
                        <!-- Left Section: Frequency and Generate/Clear -->
                        <div>
                            <h6 class="text-danger mb-2">FREQUENCY</h6>
                            <div class="d-flex flex-wrap align-items-center">
                                <select class="form-select me-2 mb-2" id="frequency" name="frequency" style="width: 120px;">
                                    <option value="weekly" selected>WEEKLY</option>
                                    <option value="daily">DAILY</option>
                                    <option value="monthly">MONTHLY</option>
                                </select>
                                <button id="compileButton" type="button" class="btn btn-pink me-2 mb-2" style="width: 120px;">
                                    GENERATE
                                </button>
                                <button id="clearSavedStateButton" class="btn btn-blue mb-2" style="width: 120px;">
                                    CLEAR
                                </button>
                            </div>
                        </div>
                        
                        <!-- Right Actions Group -->
                        <div>
                            <div class="d-flex flex-wrap justify-content-end mb-2">
                                <button type="button" id="sendEmailButton" class="btn btn-green me-2" style="width: 120px;">
                                    EMAIL
                                </button>
                                <button type="button" id="sendSlackButton" class="btn btn-pink" style="width: 120px;">
                                    SLACK
                                </button>
                            </div>
                            <div class="d-flex flex-wrap justify-content-end">
                                <button type="button" id="downloadMarkdownButton" class="btn btn-blue me-2" style="width: 120px;">
                                    DOWNLOAD
                                </button>
                                <button type="button" id="saveToServerButton" class="btn btn-yellow" style="width: 120px;">
                                    SAVE
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Saved Newsletters Section -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Saved Newsletters</h5>
                    <button type="button" id="refreshSavedNewslettersBtn" class="btn btn-sm btn-outline-secondary">
                        <i class="fa fa-refresh"></i> Refresh
                    </button>
                </div>
                <div class="card-body">
                    <div id="savedNewslettersContainer" class="list-group">
                        <div class="text-center text-muted py-3">
                            <i class="fa fa-spinner fa-spin mr-2"></i> Loading saved newsletters...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="loading-spinner" id="loadingSpinner" style="display: none; margin: 20px;">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Newsletter Compilation Progress</h5>
                <div id="compilationStatus" class="mb-2">Initializing...</div>
                <div class="progress mb-3">
                    <div id="compilationProgress" class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                        0%
                    </div>
                </div>
                <div id="compilationStep" class="text-muted small">Starting compilation...</div>
                <div id="compilationID" class="text-muted small mt-2"></div>
            </div>
        </div>
    </div>
    
    <!-- Row 3: Editor and Preview -->
    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Markdown Editor</h5>
                </div>
                <div class="card-body p-0">
                    <textarea id="basic-editor"></textarea>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Preview</h5>
                </div>
                <div class="card-body p-0">
                    <div id="preview-content" class="preview-container">
                        <p>Preview will appear here...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <!-- Prompt Editor Modal -->
    <div class="modal" id="promptEditorModal" tabindex="-1" role="dialog" aria-labelledby="promptEditorModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="promptEditorModalTitle">Edit Prompt</h5>
                    <button type="button" class="close" id="closePromptEditorModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="promptEditorForm">
                        <input type="hidden" id="promptEditorContentTypeId" name="contentTypeId">
                        <div class="form-group">
                            <label for="promptEditorText">Prompt Template</label>
                            <textarea class="form-control" id="promptEditorText" name="promptTemplate" rows="10" 
                                      placeholder="Enter your custom prompt template here..."></textarea>
                            <small class="form-text text-muted">
                                <h6 class="mt-3 mb-2">Available Variables for Prompt Templates:</h6>
                                <ul class="list-unstyled">
                                    <li><code>{{'{{topic}}'}}</code> - The current topic being processed</li>
                                    <li><code>{{'{{article_data}}'}}</code> - Formatted article data with titles, URLs, sources</li>
                                    <li><code>{{'{{articles}}'}}</code> - Alternative way to access article data</li>
                                    <li><code>{{'{{start_date}}'}}</code> - Start date for content (YYYY-MM-DD format)</li>
                                    <li><code>{{'{{end_date}}'}}</code> - End date for content (YYYY-MM-DD format)</li>
                                    <li><code>{{'{{formatted_date}}'}}</code> - Current date in human-readable format</li>
                                    <li><code>{{'{{frequency}}'}}</code> - Newsletter frequency (daily, weekly, monthly)</li>
                                    <li><code>{{'{{topics}}'}}</code> - Comma-separated list of all newsletter topics</li>
                                    <li><code>{{'{{content_instructions}}'}}</code> - Special instructions for this content type</li>
                                    <li><code>{{'{{article_count}}'}}</code> - Number of articles available</li>
                                </ul>
                            </small>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelPromptEditorModal">Cancel</button>
                    <button type="button" class="btn btn-warning" id="restorePromptButton">
                        <i class="fa fa-undo"></i> Restore Default
                    </button>
                    <button type="button" class="btn btn-primary" id="savePromptButton">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Chart Selection Modal -->
    <div class="modal" id="chartSelectionModal" tabindex="-1" role="dialog" aria-labelledby="chartSelectionModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="chartSelectionModalTitle">Select Charts</h5>
                    <button type="button" class="close" id="closeChartSelectionModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-muted mb-3">Choose which charts to include in your newsletter:</p>
                    <form id="chartSelectionForm">
                        <div class="form-group">
                            <div class="custom-control custom-checkbox mb-3">
                                <input type="checkbox" class="custom-control-input" id="chart_sentiment_trends" name="selected_charts" value="sentiment_trends" checked>
                                <label class="custom-control-label" for="chart_sentiment_trends">
                                    <strong>Sentiment Trends</strong>
                                    <small class="text-muted d-block">Shows sentiment analysis over time for selected topics</small>
                                </label>
                            </div>
                            <div class="custom-control custom-checkbox mb-3">
                                <input type="checkbox" class="custom-control-input" id="chart_future_signals" name="selected_charts" value="future_signals" checked>
                                <label class="custom-control-label" for="chart_future_signals">
                                    <strong>Future Signals Analysis</strong>
                                    <small class="text-muted d-block">Radar chart showing future impact signals for the selected topics</small>
                                </label>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelChartSelectionModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveChartSelectionButton">Save Selection</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Save Newsletter Modal -->
    <div class="modal" id="saveNewsletterModal" tabindex="-1" role="dialog" aria-labelledby="saveNewsletterModalTitle" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="saveNewsletterModalTitle">Save Newsletter</h5>
                    <button type="button" class="close" id="closeSaveNewsletterModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="saveNewsletterForm">
                        <div class="form-group">
                            <label for="newsletterFilename">Filename</label>
                            <input type="text" class="form-control" id="newsletterFilename" 
                                   placeholder="Enter filename (without extension)" required>
                            <small class="form-text text-muted">
                                The .md extension will be added automatically. 
                                Use a descriptive name like "weekly_ai_2023-05-01".
                            </small>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelSaveNewsletterModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveNewsletterButton">Save</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Podcast Selection Modal -->
    <div class="modal" id="podcastSelectionModal" tabindex="-1" role="dialog" aria-labelledby="podcastSelectionModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="podcastSelectionModalTitle">Select Podcast</h5>
                    <button type="button" class="close" id="closePodcastSelectionModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-muted mb-3">Choose a podcast to include in your newsletter:</p>
                    <div id="podcastListContainer" class="list-group mb-3">
                        <div class="text-center py-3">
                            <i class="fa fa-spinner fa-spin mr-2"></i> Loading podcasts...
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelPodcastSelectionModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="savePodcastSelectionButton">Select Podcast</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Article Selection Modal -->
    <div class="modal" id="articleSelectionModal" tabindex="-1" role="dialog" aria-labelledby="articleSelectionModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="articleSelectionModalTitle">Select Articles for Additional Reading</h5>
                    <button type="button" class="close" id="closeArticleSelectionModal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                            <div class="modal-body">
                <div class="row">
                    <!-- Left column: Search filters -->
                    <div class="col-md-4">
                        <form id="articleSearchForm" class="mb-3">
                            <div class="form-group">
                                <label for="articleSearchQuery">Keyword Search</label>
                                <input type="text" class="form-control" id="articleSearchQuery" name="keyword" placeholder="Enter search terms">
                            </div>
                            
                            <div class="form-group">
                                <label for="articleSearchTopic">Topic</label>
                                <select class="form-control" id="articleSearchTopic" name="topic">
                                    <option value="">All Topics</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="category">Category</label>
                                <select id="category" name="category" class="form-select" multiple>
                                    <!-- Categories will be populated dynamically -->
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="futureSignal">Future Signals</label>
                                <select id="futureSignal" name="future_signal" class="form-select" multiple>
                                    <!-- Will be populated dynamically -->
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="sentiment">Sentiment</label>
                                <select id="sentiment" name="sentiment" class="form-select" multiple>
                                    <!-- Will be populated dynamically -->
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="dateRange">Date Range</label>
                                <select id="dateRange" name="dateRange" class="form-control">
                                    <option value="all">All Time</option>
                                    <option value="7">Last 7 Days</option>
                                    <option value="30" selected>Last 30 Days</option>
                                    <option value="90">Last 90 Days</option>
                                    <option value="365">Last 365 Days</option>
                                    <option value="custom">Custom Range</option>
                                </select>
                            </div>
                            
                            <div id="customDateRange" style="display: none;">
                                <div class="form-group">
                                    <label for="articleSearchStartDate">From</label>
                                    <input type="date" class="form-control" id="articleSearchStartDate">
                                </div>
                                <div class="form-group">
                                    <label for="articleSearchEndDate">To</label>
                                    <input type="date" class="form-control" id="articleSearchEndDate">
                                </div>
                            </div>
                            
                            <button type="button" id="articleSearchButton" class="btn btn-primary mt-3">Search</button>
                        </form>
                        
                        <div class="mt-3">
                            <div class="form-group">
                                <label for="articleTemplate">Article Template Format</label>
                                <select class="form-control form-control-sm" id="articleTemplate">
                                    <option value="simple">Simple List</option>
                                    <option value="detailed">Detailed with Summary</option>
                                    <option value="minimal">Title Only</option>
                                    <option value="detailed_metadata">Detailed with Metadata</option>
                                </select>
                                
                                <div class="mt-2">
                                    <div class="card">
                                        <div class="card-body p-2">
                                            <small class="text-muted" id="templatePreview">
                                                <strong>Simple List</strong>: Lists articles with title, source and link
                                            </small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right column: Search results -->
                    <div class="col-md-8">
                        <div class="row">
                            <div class="col-md-12">
                                <h6>Search Results</h6>
                                <div id="articleListContainer" class="list-group mb-3" style="max-height: 400px; overflow-y: auto;">
                                    <div class="text-center py-3 text-muted">
                                        <p>Enter search terms or select a topic to find articles</p>
                                        <p class="small">Default search will show articles from the last 30 days</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="col-md-12 mt-3">
                                <div class="selected-articles-container">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <h6 class="mb-0">Selected Articles: <span id="selectedArticlesCounter">0</span></h6>
                                        <button type="button" id="clearSelectedArticles" class="btn btn-sm btn-outline-danger">
                                            <i class="fa fa-trash"></i> Clear All
                                        </button>
                                    </div>
                                    <div id="selectedArticlesList" class="list-group" style="max-height: 200px; overflow-y: auto;">
                                        <!-- Selected articles will appear here -->
                                        <div class="text-center py-3 text-muted" id="noSelectedArticlesMsg">
                                            No articles selected
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                            </div>
                
                <!-- Template Preview Section -->
                <div class="row mt-4">
                    <div class="col-12">
                        <h6 class="border-bottom pb-2">Template Preview</h6>
                        <div id="templateOutputPreview" class="p-3 border rounded bg-light">
                            <p class="text-muted small">Select an article template format and click Preview to see how your selected articles will appear in the newsletter.</p>
                        </div>
                        <div class="text-end mt-2">
                            <button id="previewTemplateBtn" class="btn btn-sm btn-outline-secondary">
                                <i class="fa fa-eye"></i> Preview
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelArticleSelectionModal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveArticleSelectionButton">Add to Additional Reading</button>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
<!-- Keep the working SimpleMDE implementation -->
<script src="https://unpkg.com/simplemde@1.11.2/dist/simplemde.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/simplemde@1.11.2/dist/simplemde.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!-- Add back the marked library for markdown parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/lib/marked.umd.min.js"></script>

<script>
// Global variables
let editor; // Our SimpleMDE editor instance
const loadingSpinner = document.getElementById('loadingSpinner');
let originalMarkdownContent = ""; // Store the full content with base64
let selectedCharts = ['sentiment_trends', 'topic_distribution']; // Default selected charts

// Initialize SimpleMDE editor
window.onload = function() {
    console.log("Window loaded, initializing SimpleMDE editor");
    
    // Check if the textarea exists
    const textArea = document.getElementById('basic-editor');
    if (!textArea) {
        console.error("Textarea not found");
        return;
    }
    
    // Check if SimpleMDE exists
    if (typeof SimpleMDE === 'undefined') {
        console.error("SimpleMDE library not loaded");
        textArea.value = "SimpleMDE library could not be loaded. Please check your internet connection.";
        return;
    }
    
    try {
        // Initialize SimpleMDE
        editor = new SimpleMDE({ 
            element: textArea,
            spellChecker: false,
            autofocus: true,
            placeholder: "Type markdown content here...",
            initialValue: "# Newsletter Content\n\nClick the 'Generate Newsletter' button to compile your newsletter based on the settings above.",
            toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", 
                     "link", "image", "table", "|", "preview", "side-by-side", "fullscreen"]
        });
        
        console.log("SimpleMDE initialized successfully");
        
        // Save original value method
        const originalGetValue = editor.value.bind(editor);
        const originalSetValue = editor.value;
        
        // Override the value() method to handle base64 images
        editor.value = function(val) {
            if (val === undefined) {
                // Getting the value - return original content with base64
                return originalMarkdownContent || originalGetValue();
            } else {
                // Setting the value - store original and set condensed version
                originalMarkdownContent = val;
                
                // Replace base64 content with placeholders in the editor
                const condensedVal = replaceBase64WithPlaceholders(val);
                originalSetValue.call(editor, condensedVal);
                
                return editor;
            }
        };
        
        // Set up change handler for preview updates and auto-save
        editor.codemirror.on("change", function() {
            // Get editor content (which may have placeholders)
            const editorContent = editor.codemirror.getValue();
            
            // If user edited something, update the original content too
            if (editorContent !== replaceBase64WithPlaceholders(originalMarkdownContent)) {
                // Find and restore any image placeholders that might have been edited
                originalMarkdownContent = restorePlaceholdersIfNeeded(editorContent, originalMarkdownContent);
            }
            
            updatePreview();
            
            // Auto-save with delay to avoid too many saves during typing
            clearTimeout(window.editorSaveTimeout);
            window.editorSaveTimeout = setTimeout(saveNewsletterState, 1000);
        });
        
        // Initial preview update
        updatePreview();
        
        // Load saved newsletters on page load
        loadSavedNewsletters();
        
    } catch (error) {
        console.error("Error initializing SimpleMDE:", error);
        textArea.value = "Error initializing editor: " + error.message;
    }
};

// Function to replace base64 content with placeholders
function replaceBase64WithPlaceholders(markdown) {
    if (!markdown) return markdown;
    
    // Pattern to match Markdown image syntax with base64 data
    const imagePattern = /!\[([^\]]*)\]\(data:image\/[^;]+;base64,([A-Za-z0-9+/=]{30})[A-Za-z0-9+/=]+\)/g;
    
    // Replace with placeholder but keep alt text and image type
    return markdown.replace(imagePattern, (match, altText, base64Start) => {
        return `![${altText}][IMAGE: ${base64Start}...]`;
    });
}

// Function to restore placeholders when needed
function restorePlaceholdersIfNeeded(editorContent, originalContent) {
    if (!editorContent || !originalContent) return originalContent;
    
    // Look for placeholder pattern
    const placeholderPattern = /!\[([^\]]*)\]\[IMAGE: ([A-Za-z0-9+/=]{30})...\]/g;
    
    return editorContent.replace(placeholderPattern, (match, altText, base64Start) => {
        // Try to find the corresponding original image in the stored content
        const originalImagePattern = new RegExp(`!\\[${altText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\]\\(data:image\\/[^;]+;base64,${base64Start}[A-Za-z0-9+/=]+\\)`, 'g');
        const originalMatches = originalContent.match(originalImagePattern);
        
        if (originalMatches && originalMatches.length > 0) {
            return originalMatches[0]; // Return the original image markdown with full base64
        }
        
        // If not found, just return the placeholder
        return match;
    });
}

// Function to get markdown content
function getMarkdownContent() {
    if (editor) {
        // Return original content with full base64 images
        return originalMarkdownContent || editor.value();
    }
    return "";
}

// Function to set markdown content
function setMarkdownContent(markdown) {
    if (!editor) {
        console.error('Editor not initialized, cannot set content');
        return;
    }
    
    try {
        console.log(`Setting markdown content (${markdown ? markdown.length : 0} bytes)`);
        
        // For very large content, use a more efficient approach
        if (markdown && markdown.length > 100000) {
            console.log('Large content detected, using optimized handling');
            
            // Set chunks with timeouts to prevent UI blocking
            const setContentInChunks = () => {
                // Store the content
                originalMarkdownContent = markdown;
                
                // Replace base64 content with placeholders
                const condensedContent = replaceBase64WithPlaceholders(markdown);
                
                // Use the editor's raw CodeMirror setValue method which is more efficient
                // than the SimpleMDE value() method for large content
                editor.codemirror.setValue(condensedContent);
                
                // Ensure the cursor is at the beginning
                editor.codemirror.setCursor({line: 0, ch: 0});
                
                // Schedule preview update
                setTimeout(updatePreview, 100);
            };
            
            // Schedule the chunked update
            setTimeout(setContentInChunks, 10);
        } else {
            // For smaller content, use the normal method
            editor.value(markdown);
            updatePreview();
        }
    } catch (error) {
        console.error('Error setting markdown content:', error);
        alert(`Error setting content: ${error.message}\nPlease try reloading the page.`);
    }
}

// Update the preview from markdown content
function updatePreview() {
    try {
        // Use original content with full base64 data for preview
        const markdownContent = getMarkdownContent();
        const previewElement = document.getElementById('preview-content');
        
        if (!previewElement) {
            console.error('Preview element not found');
            return;
        }
        
        if (!markdownContent || !markdownContent.trim()) {
            previewElement.innerHTML = '<p>Preview will appear here...</p>';
            return;
        }
        
        console.log(`Updating preview with content length: ${markdownContent.length}`);
        
        // For very large content, show a simplified preview to avoid browser freezing
        if (markdownContent.length > 200000) {
            console.log('Content is very large, using simplified preview');
            
            // Get the first ~10,000 characters plus last ~5,000 for preview
            const firstPart = markdownContent.substring(0, 10000);
            const lastPart = markdownContent.substring(markdownContent.length - 5000);
            
            const simplifiedContent = `${firstPart}\n\n...\n\n[Content truncated for preview - ${Math.round(markdownContent.length/1024)}KB total]\n\n...\n\n${lastPart}`;
            
            // Use a timeout to allow UI to remain responsive
            setTimeout(() => {
                try {
                    // Use marked for markdown rendering
                    if (typeof marked !== 'undefined') {
                        const html = marked.parse(simplifiedContent);
                        previewElement.innerHTML = html;
                        
                        // Add a notice at the top
                        const notice = document.createElement('div');
                        notice.className = 'alert alert-info';
                        notice.innerHTML = `<strong>Note:</strong> Preview is truncated for large content (${Math.round(markdownContent.length/1024)}KB)`;
                        previewElement.insertBefore(notice, previewElement.firstChild);
                        
                        console.log('Simplified preview updated');
                    }
                } catch (e) {
                    console.error('Error rendering simplified preview:', e);
                    previewElement.innerHTML = `<p>Error rendering large preview: ${e.message}</p>`;
                }
            }, 10);
            
            return;
        }
        
        // Normal preview rendering for reasonable sized content
        try {
            // Use marked for markdown rendering
            if (typeof marked !== 'undefined') {
                const html = marked.parse(markdownContent);
                previewElement.innerHTML = html;
                
                // Process images after a short delay to allow DOM to update
                setTimeout(() => {
                    // Apply image processing to ensure color charts display properly
                    const images = previewElement.querySelectorAll('img');
                    images.forEach(img => {
                        // Fix various base64 image formatting issues
                        if (img.src) {
                            let src = img.src;
                            
                            // Case 1: Fix space after "base64,"
                            if (src.includes('base64, ')) {
                                src = src.replace('base64, ', 'base64,');
                            }
                            
                            // Case 2: Remove any trailing spaces in the URL
                            src = src.trim();
                            
                            // Case 3: Fix URLs that have been broken by newlines or other whitespace
                            if (src.includes('base64') && !src.includes('base64,')) {
                                src = src.replace('base64', 'base64,');
                            }
                            
                            // Case 4: Handle cases where the URL might have been split
                            if (src.match(/data:image\/[^;]+;$/)) {
                                src = src + 'base64,';
                            }
                            
                            // Apply changes if needed
                            if (src !== img.src) {
                                img.src = src;
                            }
                            
                            // Apply specific styling for chart images
                            if ((src.includes('chart') || src.includes('sentiment') || 
                                src.includes('radar')) || 
                                (img.alt && (img.alt.includes('Chart') || img.alt.includes('chart')))) {
                                img.classList.add('newsletter-chart');
                                img.style.maxWidth = '550px';
                                img.style.maxHeight = '400px';
                                img.style.width = 'auto';
                                img.style.height = 'auto';
                            }
                        }
                        
                        // Add error handler for debugging
                        img.onerror = function() {
                            console.error('Image failed to load:', this.src.substring(0, 100) + '...');
                            // Set a data attribute to mark this as an error and add a visual indication
                            this.setAttribute('data-load-error', 'true');
                            this.style.border = '2px dashed red';
                            this.style.padding = '8px';
                            this.style.backgroundColor = '#ffeeee';
                            this.alt = 'Error loading image';
                        };
                    });
                }, 50);
            } else {
                // Fallback to basic rendering
                let html = markdownContent
                    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                    .replace(/\*\*(.*)\*\*/gm, '<strong>$1</strong>')
                    .replace(/\*(.*)\*/gm, '<em>$1</em>')
                    .replace(/\[([^\]]+)\]\(([^)]+)\)/gm, '<a href="$2">$1</a>')
                    .replace(/\n/gm, '<br>');
                
                previewElement.innerHTML = html;
            }
            
            console.log('Preview updated successfully');
        } catch (error) {
            console.error("Error updating preview:", error);
            previewElement.innerHTML = "<p>Error rendering preview: " + error.message + "</p>";
        }
    } catch (outerError) {
        console.error("Outer error in updatePreview:", outerError);
        const previewElement = document.getElementById('preview-content');
        if (previewElement) {
            previewElement.innerHTML = "<p>Error preparing preview: " + outerError.message + "</p>";
        }
    }
}

// Download markdown content - use full content with base64
function downloadMarkdown() {
    const markdownContent = getMarkdownContent();
    
    if (!markdownContent.trim()) {
        alert('No content to download');
        return;
    }
    
    // Create filename with date
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    const frequency = document.getElementById('frequency').value;
    const topicsSelect = document.getElementById('topics');
    const topics = Array.from(topicsSelect.selectedOptions).map(option => option.value).join('-');
    
    const filename = `${frequency}_${topics || 'newsletter'}_${dateStr}.md`;
    
    // Create download link
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(markdownContent));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    
    // Add to body, click, and remove
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

// Load topics from API
async function loadTopics() {
    try {
        console.log('Fetching topics...');
        const topicsSelect = document.getElementById('topics');
        if (!topicsSelect) {
            console.error('Topics select element not found');
            return;
        }
        
        // Clear existing options and show loading
        topicsSelect.innerHTML = '<option value="" disabled selected>Loading topics...</option>';
        
        const response = await fetch('/api/newsletter/topics');
        console.log('Topics API response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`API returned status: ${response.status}`);
        }
        
        const topics = await response.json();
        console.log('Fetched topics:', topics);
        
        // Clear the select
        topicsSelect.innerHTML = '';
        
        if (!Array.isArray(topics)) {
            console.error('Topics data is not an array:', topics);
            topicsSelect.innerHTML = '<option value="" disabled selected>Error: Invalid data format</option>';
            return;
        }
        
        if (topics.length === 0) {
            console.warn('No topics returned from API');
            topicsSelect.innerHTML = '<option value="" disabled selected>No topics available</option>';
            return;
        }
        
        // Add topics to select
        topics.forEach(topic => {
            const option = document.createElement('option');
            
            // Handle both object format and simple string format
            if (typeof topic === 'string') {
                option.value = topic;
                option.textContent = topic;
            } else {
                // Object format with properties
                option.value = topic.id || topic.name || topic;
                option.textContent = topic.name || topic;
                
                if (topic.description) {
                    option.title = topic.description;
                }
                if (topic.default_selected) {
                    option.selected = true;
                }
            }
            
            topicsSelect.appendChild(option);
        });
        
        console.log('Topics loaded successfully');
        
    } catch (error) {
        console.error('Error loading topics:', error);
        const topicsSelect = document.getElementById('topics');
        if (topicsSelect) {
            topicsSelect.innerHTML = `<option value="" disabled selected>Error loading topics: ${error.message}</option>`;
        }
    }
}

// Load content types from API
async function loadContentTypes() {
    try {
        console.log('Fetching content types...');
        const contentTypesTable = document.getElementById('contentTypesTable');
        if (!contentTypesTable) {
            console.error('Content types table element not found');
            return;
        }
        
        // Get the tbody element
        const tbody = contentTypesTable;
        tbody.innerHTML = '<tr><td colspan="3" class="text-muted">Loading content types...</td></tr>';
        
        const response = await fetch('/api/newsletter/content_types');
        console.log('Content types API response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`API returned status: ${response.status}`);
        }
        
        const contentTypes = await response.json();
        console.log('Fetched content types:', contentTypes);
        
        // Clear container
        tbody.innerHTML = '';
        
        if (!Array.isArray(contentTypes)) {
            console.error('Content types data is not an array:', contentTypes);
            tbody.innerHTML = '<tr><td colspan="3" class="text-danger">Error: Invalid data format</td></tr>';
            return;
        }
        
        if (contentTypes.length === 0) {
            console.warn('No content types returned from API');
            tbody.innerHTML = '<tr><td colspan="3" class="text-muted">No content types available</td></tr>';
            return;
        }
        
        // Render content types
        contentTypes.forEach(contentType => {
            const row = document.createElement('tr');
            
            // Content type name cell
            const nameCell = document.createElement('td');
            nameCell.textContent = contentType.name || 'Unnamed';
            if (contentType.description) {
                const description = document.createElement('small');
                description.className = 'text-muted d-block';
                description.textContent = contentType.description;
                nameCell.appendChild(description);
            }
            
            // Include checkbox cell
            const includeCell = document.createElement('td');
            includeCell.className = 'text-center';
            
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.className = 'form-check';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-check-input content-type-checkbox';
            checkbox.id = `content-type-${contentType.id}`;
            checkbox.name = `content-type-${contentType.id}`;
            checkbox.value = contentType.id;
            checkbox.checked = contentType.default_enabled || false;
            
            checkboxWrapper.appendChild(checkbox);
            includeCell.appendChild(checkboxWrapper);
            
            // Prompt input cell
            const promptCell = document.createElement('td');
            
            // Create a container for the edit button (no input field)
            const promptContainer = document.createElement('div');
            promptContainer.className = 'd-flex justify-content-end';
            
            // Create hidden input for storing the prompt value
            const promptInput = document.createElement('input');
            promptInput.type = 'hidden';
            promptInput.id = `prompt-${contentType.id}`;
            promptInput.name = `prompt-${contentType.id}`;
            promptInput.value = contentType.default_prompt || '';
            
            // Create edit button (icon only)
            const editButton = document.createElement('button');
            editButton.className = 'btn btn-sm btn-outline-secondary';
            editButton.type = 'button';
            editButton.innerHTML = '<i class="fa fa-pencil"></i>';
            editButton.title = 'Edit custom prompt template';
            editButton.setAttribute('data-toggle', 'tooltip');
            editButton.setAttribute('data-placement', 'top');
            
            // Special handling for Key Charts content type
            if (contentType.id === 'key_charts') {
                editButton.innerHTML = '<i class="fa fa-bar-chart"></i>';
                editButton.title = 'Select charts to include';
                editButton.className = 'btn btn-sm btn-outline-primary';
                
                // Add click handler for the chart selection instead of prompt editing
                editButton.addEventListener('click', function() {
                    openChartSelectionModal();
                });
                
                // Make this more visible by changing label
                nameCell.innerHTML = '<strong>Data Visualizations</strong>';
                if (contentType.description) {
                    const description = document.createElement('small');
                    description.className = 'text-muted d-block';
                    description.textContent = 'Charts and visual data analysis';
                    nameCell.appendChild(description);
                }
            } 
            // Special handling for Latest Podcast content type
            else if (contentType.id === 'latest_podcast') {
                editButton.innerHTML = '<i class="fa fa-podcast"></i>';
                editButton.title = 'Select podcast';
                editButton.className = 'btn btn-sm btn-outline-primary';
                editButton.setAttribute('data-podcast-button', 'true');
                
                // Add click handler for podcast selection
                editButton.addEventListener('click', function() {
                    openPodcastSelectionModal();
                });
                
                // Make this more visible by changing label
                nameCell.innerHTML = '<strong>Latest Podcast</strong>';
                
                // Add selected podcast indicator
                const podcastNameSpan = document.createElement('small');
                podcastNameSpan.id = 'selectedPodcastName';
                podcastNameSpan.className = 'text-muted d-block';
                podcastNameSpan.textContent = 'No podcast selected';
                nameCell.appendChild(podcastNameSpan);
                
                // Add hidden input for podcast ID
                const podcastIdInput = document.createElement('input');
                podcastIdInput.type = 'hidden';
                podcastIdInput.id = 'includePodcast';
                podcastIdInput.value = 'false';
                nameCell.appendChild(podcastIdInput);
            } else {
                // Regular prompt editing for other content types
                editButton.addEventListener('click', function() {
                    // Get the content type ID from the prompt input ID
                    const contentTypeId = contentType.id;
                    
                    // Load the prompt from the database first
                    fetch(`/api/newsletter/prompts/${contentTypeId}`)
                        .then(response => {
                            if (!response.ok) {
                                if (response.status === 404) {
                                    // If not found, just use the current value
                                    return { 
                                        prompt_template: promptInput.value,
                                        description: contentType.description || ''
                                    };
                                }
                                throw new Error(`API returned status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Populate and show the prompt editor modal
                            const modal = document.getElementById('promptEditorModal');
                            const modalTitle = document.getElementById('promptEditorModalTitle');
                            const modalPromptTextarea = document.getElementById('promptEditorText');
                            const contentTypeIdInput = document.getElementById('promptEditorContentTypeId');
                            
                            if (modal && modalTitle && modalPromptTextarea && contentTypeIdInput) {
                                // Set modal title
                                modalTitle.textContent = `Edit Prompt: ${contentType.name || contentTypeId}`;
                                
                                // Set prompt text
                                modalPromptTextarea.value = data.prompt_template || promptInput.value;
                                
                                // Store original prompt for restoration
                                modalPromptTextarea.dataset.originalPrompt = data.prompt_template || promptInput.value;
                                modalPromptTextarea.dataset.defaultPrompt = data.default_prompt || '';
                                
                                // Set content type ID (hidden field)
                                contentTypeIdInput.value = contentTypeId;
                                
                                // Show modal using native JavaScript (not jQuery)
                                modal.classList.add('show');
                                modal.style.display = 'block';
                                modal.setAttribute('aria-hidden', 'false');
                                document.body.classList.add('modal-open');
                            } else {
                                console.error('Prompt editor modal elements not found');
                                alert('Error: Could not open prompt editor. Please try again.');
                            }
                        })
                        .catch(error => {
                            console.error('Error loading prompt:', error);
                            alert(`Error loading prompt: ${error.message}`);
                        });
                });
            }
            
            // Add elements to container
            promptContainer.appendChild(promptInput);
            promptContainer.appendChild(editButton);
            
            // Add the container to the cell
            promptCell.appendChild(promptContainer);
            
            // Add cells to row
            row.appendChild(nameCell);
            row.appendChild(includeCell);
            row.appendChild(promptCell);
            
            // Add row to table
            tbody.appendChild(row);
        });
        
        console.log('Content types loaded successfully');
        
    } catch (error) {
        console.error('Error loading content types:', error);
        const contentTypesTable = document.getElementById('contentTypesTable');
        if (contentTypesTable) {
            contentTypesTable.innerHTML = `<tr><td colspan="3" class="text-danger">Error loading content types: ${error.message}</td></tr>`;
        }
    }
}

// Compile newsletter content
async function compileNewsletter() {
    try {
        console.log('Compiling newsletter...');
        
        // Show loading spinner
        const loadingSpinner = document.getElementById('loadingSpinner');
        if (loadingSpinner) {
            loadingSpinner.style.display = 'block';
        }
        
        // Get selected topics
        const topicsSelect = document.getElementById('topics');
        if (!topicsSelect) {
            throw new Error('Topics select element not found');
        }
        
        const selectedTopics = Array.from(topicsSelect.selectedOptions).map(option => option.value);
        if (selectedTopics.length === 0) {
            throw new Error('Please select at least one topic');
        }
        
        console.log('Selected topics:', selectedTopics);
        
        // Get selected content types and their prompts
        const contentTypeCheckboxes = document.querySelectorAll('.content-type-checkbox:checked');
        
        // Check if we have Additional Reading articles selected
        const hasAdditionalReading = document.getElementById('includeArticles').checked;
        const articleBtn = document.getElementById('selectArticlesButton');
        const hasSelectedArticles = articleBtn && articleBtn.dataset.selectedArticles && 
                                  JSON.parse(articleBtn.dataset.selectedArticles).length > 0;
        
        // Only require content types if no Additional Reading is selected
        if (contentTypeCheckboxes.length === 0 && !(hasAdditionalReading && hasSelectedArticles)) {
            throw new Error('Please select at least one content type or add articles to Additional Reading');
        }
        
        // The API expects a list of content type IDs (strings), not objects
        const selectedContentTypes = Array.from(contentTypeCheckboxes).map(checkbox => {
            return checkbox.value;
        });
        
        // Keep the original content types including key_articles - we want both AI-generated key articles
// AND selected articles as "Additional Reading" at the end
const contentTypesFiltered = [...selectedContentTypes];

console.log('Selected content types:', contentTypesFiltered);
        
        // Check for selected podcast
        const includePodcast = document.getElementById('includePodcast');
        let includePodcastValue = false;
        
        if (includePodcast) {
            // Handle both checkbox and hidden input types
            if (includePodcast.type === 'checkbox') {
                includePodcastValue = includePodcast.checked;
            } else {
                includePodcastValue = includePodcast.value === 'true';
            }
        }
        
        // Also check if latest_podcast is in selected content types
        const hasPodcastContentType = contentTypesFiltered.includes('latest_podcast');
        
        if (includePodcastValue || hasPodcastContentType) {
            const podcastNameSpan = document.getElementById('selectedPodcastName');
            const podcastId = podcastNameSpan?.dataset?.podcastId;
            
            if (podcastId) {
                console.log('Including podcast with ID:', podcastId);
                
                // Make sure latest_podcast is in the content types
                if (!contentTypesFiltered.includes('latest_podcast')) {
                    contentTypesFiltered.push('latest_podcast');
                }
            }
        }
        
        // Check for selected articles
        const includeArticles = document.getElementById('includeArticles').checked;
        let selectedArticlesDetails = [];
        let appendAdditionalReading = false;
        
        if (includeArticles) {
            const articleBtn = document.getElementById('selectArticlesButton');
            if (articleBtn && articleBtn.dataset.selectedArticles) {
                try {
                    const selectedArticles = JSON.parse(articleBtn.dataset.selectedArticles);
                    if (selectedArticles.length > 0) {
                        console.log('Including selected articles as Additional Reading:', selectedArticles.length);
                        appendAdditionalReading = true;
                        
                        // Also get detailed article data if available
                        if (articleBtn.dataset.selectedArticlesData) {
                            try {
                                selectedArticlesDetails = JSON.parse(articleBtn.dataset.selectedArticlesData);
                                console.log('Retrieved detailed articles data:', selectedArticlesDetails.length);
                            } catch (e) {
                                console.warn('Error parsing detailed article data:', e);
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error parsing selected articles:', e);
                }
            }
        }
        
        // Get date range
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        // Get frequency (required by API)
        const frequency = document.getElementById('frequency');
        let frequencyValue = 'weekly'; // Default to weekly if frequency element doesn't exist
        
        if (frequency) {
            frequencyValue = frequency.value || 'weekly';
        } else {
            console.warn('Frequency input not found, using default value "weekly"');
        }
        
        // Get AI model selection
        const aiModelSelect = document.getElementById('ai_model');
        let aiModel = 'gpt-4o'; // Default model
        
        if (aiModelSelect) {
            aiModel = aiModelSelect.value;
        } else {
            console.warn('AI model select not found, using default model "gpt-4o"');
        }
        
        // Prepare request payload
        const payload = {
            frequency: frequencyValue,
            topics: selectedTopics,
            content_types: contentTypesFiltered, // Use filtered content types that exclude key_articles
            start_date: startDate || null,
            end_date: endDate || null,
            ai_model: aiModel
        };
        
        // Add selected podcast if available
        if (includePodcast) {
            const podcastNameSpan = document.getElementById('selectedPodcastName');
            const podcastId = podcastNameSpan?.dataset?.podcastId;
            if (podcastId) {
                payload.podcast_id = podcastId;
            }
            
            // Add podcast template if available
            const podcastTemplate = document.getElementById('selectedPodcastName').dataset.podcastTemplate;
            if (podcastTemplate) {
                try {
                    payload.podcast_template = JSON.parse(podcastTemplate);
                } catch (e) {
                    console.error('Error parsing podcast template:', e);
                }
            }
        }
        
        console.log('Sending compilation request with payload:', payload);
        
        // Send compilation request
        const response = await fetch('/api/newsletter/compile', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API returned status ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Compilation result:', data);
        
        // Log the entire response for debugging
        console.log('Full API response:', data);
        
        // Check if compilation has started and we have an ID for progress tracking
        if (data.message && data.message.includes('Newsletter compilation started with ID:')) {
            // Extract compilation ID
            const compilationId = data.message.split('ID: ')[1].trim();
            console.log('Compilation ID:', compilationId);
            
            // Update the compilation ID in the UI
            const compilationIdElement = document.getElementById('compilationID');
            if (compilationIdElement) {
                compilationIdElement.textContent = `Compilation ID: ${compilationId}`;
            }
            
            // Make sure loading spinner is visible with proper initial state
            showLoadingSpinner(compilationId);
            
            // Connect to WebSocket for progress updates and store article data for appending later
connectToProgressWebsocket(compilationId);

// Store selected articles data for appending after completion
window.selectedArticlesForAppending = {
    shouldAppend: appendAdditionalReading,
    articlesData: selectedArticlesDetails
};
            
            // Start polling for updates
            pollCompilationProgress(compilationId, appendAdditionalReading, selectedArticlesDetails);
            
            // Don't modify editor content, use the progress display
            // Just return, the editor content will be updated when compilation is complete
            return;
        }
        
        // Update editor with compiled content when available
        if (data.compiled_markdown) {
            // If we have selected articles, append them as "Additional Reading"
            let compiledContent = data.compiled_markdown;
            
            if (appendAdditionalReading && selectedArticlesDetails.length > 0) {
                compiledContent = appendAdditionalReadingSection(compiledContent, selectedArticlesDetails);
            }
            
            setMarkdownContent(compiledContent);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleString();
            }
            
            // Hide the spinner
            hideLoadingSpinner();
        } else if (data.result) {
            // Some API endpoints might return 'result' instead
            let finalResult = data.result;
            
            // Append Additional Reading section if selected articles are available
            if (appendAdditionalReading && selectedArticlesDetails.length > 0) {
                finalResult = appendAdditionalReadingSection(finalResult, selectedArticlesDetails);
            }
            
            setMarkdownContent(finalResult);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleString();
            }
            
            // Hide the spinner
            hideLoadingSpinner();
        } else {
            // Show the API message in the editor if no content
            if (data.message) {
                setMarkdownContent(`# Newsletter Compilation Status\n\n${data.message}\n\nPlease check the server logs for more details.`);
                console.warn('API returned a message but no content:', data.message);
            } else {
                throw new Error('No content returned from API');
            }
        }
        
    } catch (error) {
        console.error('Error compiling newsletter:', error);
        // Hide loading spinner on error
        hideLoadingSpinner();
        alert(`Error compiling newsletter: ${error.message}`);
    }
}

// Function to append selected articles as "Additional Reading" section
function appendAdditionalReadingSection(content, articlesData) {
    if (!articlesData || articlesData.length === 0) {
        return content;
    }
    
    console.log(`Appending Additional Reading section with ${articlesData.length} articles`);
    
    // Get the template format
    const templateFormat = document.getElementById('articleTemplate')?.value || 'detailed';
    
    // Create Additional Reading section
    let additionalReadingSection = "\n\n## Additional Reading\n\n";
    
    // Format each article based on the selected template
    articlesData.forEach(article => {
        const title = article.title || 'Untitled';
        const url = article.url || article.uri || '#';
        const source = article.source || article.news_source || 'Unknown Source';
        
        switch (templateFormat) {
            case 'simple':
                additionalReadingSection += `- **[${title}](${url})**  \n`;
                additionalReadingSection += `  *${source}*\n\n`;
                break;
                
            case 'detailed':
                additionalReadingSection += `### [${title}](${url})\n\n`;
                additionalReadingSection += `**Source:** ${source}\n\n`;
                if (article.summary) {
                    additionalReadingSection += `${article.summary}\n\n`;
                }
                break;
                
            case 'minimal':
                additionalReadingSection += `- [${title}](${url})\n`;
                break;
                
            case 'detailed_metadata':
                additionalReadingSection += `### ${title}\n`;
                additionalReadingSection += `**Source:** ${source} | [Link](${url})\n\n`;
                if (article.summary) {
                    additionalReadingSection += `${article.summary}\n\n`;
                }
                if (article.sentiment) {
                    additionalReadingSection += `**Sentiment:** ${article.sentiment} | `;
                }
                additionalReadingSection += `**Time to Impact:** ${article.time_to_impact || 'Not specified'} | `;
                additionalReadingSection += `**Future Signal:** ${article.future_signal || 'Not specified'}\n\n`;
                break;
                
            default:
                additionalReadingSection += `- **[${title}](${url})** - ${source}\n\n`;
        }
    });
    
    return content + additionalReadingSection;
}

// Function to poll for compilation progress with support for Additional Reading
function pollCompilationProgress(compilationId, appendAdditionalReading = false, selectedArticlesDetails = []) {
    let pollingInterval = null;
    
    // Start polling
    pollingInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/newsletter/progress/${compilationId}`);
            
            if (!response.ok) {
                console.error(`Progress polling error: ${response.status}`);
                return;
            }
            
            const data = await response.json();
            console.log('Progress polling result:', data);
            
            // Update the UI
            updateProgressUI(data);
            
            // If we have the final result, update the editor and stop polling
            if ((data.status === 'completed' || data.progress >= 100) && data.result) {
                clearInterval(pollingInterval);
                hideLoadingSpinner();
                
                // If we have selected articles to append as Additional Reading, do so now
                let finalResult = data.result;
                
                // Check the window-scoped data for appending additional reading
                if (window.selectedArticlesForAppending && 
                    window.selectedArticlesForAppending.shouldAppend && 
                    window.selectedArticlesForAppending.articlesData && 
                    window.selectedArticlesForAppending.articlesData.length > 0) {
                    
                    console.log("Appending Additional Reading section with", 
                        window.selectedArticlesForAppending.articlesData.length, "articles");
                    
                    finalResult = appendAdditionalReadingSection(
                        finalResult, 
                        window.selectedArticlesForAppending.articlesData
                    );
                } 
                
                setMarkdownContent(finalResult);
                
                // Update last updated time
                const lastUpdatedElement = document.getElementById('lastUpdated');
                if (lastUpdatedElement) {
                    const now = new Date();
                    lastUpdatedElement.textContent = now.toLocaleString();
                }
            }
        } catch (error) {
            console.error('Error polling for compilation progress:', error);
        }
    }, 2000); // Poll every 2 seconds
    
    // Store interval ID for cleanup
    window.newsletterPollingInterval = pollingInterval;
    
    // Auto-cleanup after 5 minutes (300000 ms) to prevent infinite polling
    setTimeout(() => {
        if (window.newsletterPollingInterval) {
            clearInterval(window.newsletterPollingInterval);
            window.newsletterPollingInterval = null;
        }
    }, 300000);
}

// Update the articles selection UI to clarify its usage
document.addEventListener('DOMContentLoaded', function() {
    // Add explanation text under the Select Articles button
    const articlesSection = document.querySelector('#includeArticles').closest('.mb-3');
    if (articlesSection) {
        const explanationText = document.createElement('div');
        explanationText.className = 'small text-muted mt-1';
        explanationText.innerHTML = '<b>Manual selection:</b> These articles will appear in an "Additional Reading" section at the end, separate from the AI-generated "Key Articles" section.';
        
        // Insert after the small text containing selectedArticlesCount
        const smallText = articlesSection.querySelector('#selectedArticlesCount');
        if (smallText && smallText.parentNode) {
            smallText.parentNode.appendChild(explanationText);
        }
    }
});

    // Function to connect to the WebSocket for real-time progress updates
function connectToProgressWebsocket(compilationId) {
    try {
        // Get the current protocol (http or https)
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Construct WebSocket URL using the current host
        const wsUrl = `${protocol}//${window.location.host}/ws/newsletter/progress/${compilationId}`;
        console.log(`Connecting to WebSocket: ${wsUrl}`);
        
        const socket = new WebSocket(wsUrl);
        
        socket.onopen = () => {
            console.log('WebSocket connection established');
        };
        
        socket.onmessage = (event) => {
            console.log('WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                updateProgressUI(data);
                
                // If compilation is complete, get the final result
                if (data.status === 'completed' && data.progress >= 100) {
                    fetchCompilationResult(compilationId);
                }
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };
        
        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        socket.onclose = () => {
            console.log('WebSocket connection closed');
        };
        
        // Store socket reference for cleanup
        window.newsletterWebSocket = socket;
    } catch (error) {
        console.error('Error connecting to WebSocket:', error);
    }
}

// Function to poll for compilation progress
function pollCompilationProgress(compilationId) {
    let pollingInterval = null;
    
    // Start polling
    pollingInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/newsletter/progress/${compilationId}`);
            
            if (!response.ok) {
                console.error(`Progress polling error: ${response.status}`);
                return;
            }
            
            const data = await response.json();
            console.log('Progress polling result:', data);
            
            // Update the UI
            updateProgressUI(data);
            
            // If we have the final result, update the editor and stop polling
            if ((data.status === 'completed' || data.progress >= 100) && data.result) {
                clearInterval(pollingInterval);
                hideLoadingSpinner();
                
                // Process the final result - add Additional Reading if configured
                let finalResult = data.result;
                
                // Check if we need to add selected articles as Additional Reading
                const selectArticlesButton = document.getElementById('selectArticlesButton');
                const includeArticles = document.getElementById('includeArticles');
                
                if (includeArticles && includeArticles.checked && 
                    selectArticlesButton && selectArticlesButton.dataset.selectedArticlesData) {
                    try {
                        const articlesData = JSON.parse(selectArticlesButton.dataset.selectedArticlesData);
                        if (articlesData && articlesData.length > 0) {
                            console.log(`Adding ${articlesData.length} selected articles to Additional Reading section`);
                            finalResult = appendAdditionalReadingSection(finalResult, articlesData);
                        }
                    } catch (err) {
                        console.error('Error appending Additional Reading section:', err);
                    }
                }
                
                setMarkdownContent(finalResult);
                
                // Update last updated time
                const lastUpdatedElement = document.getElementById('lastUpdated');
                if (lastUpdatedElement) {
                    const now = new Date();
                    lastUpdatedElement.textContent = now.toLocaleString();
                }
            }
        } catch (error) {
            console.error('Error polling for compilation progress:', error);
        }
    }, 2000); // Poll every 2 seconds
    
    // Store interval ID for cleanup
    window.newsletterPollingInterval = pollingInterval;
    
    // Auto-cleanup after 5 minutes (300000 ms) to prevent infinite polling
    setTimeout(() => {
        if (window.newsletterPollingInterval) {
            clearInterval(window.newsletterPollingInterval);
            window.newsletterPollingInterval = null;
        }
    }, 300000);
}

// Function to fetch the final compilation result
async function fetchCompilationResult(compilationId) {
    try {
        const response = await fetch(`/api/newsletter/progress/${compilationId}`);
        
        if (!response.ok) {
            throw new Error(`Failed to fetch compilation result: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Fetched final compilation result:', data);
        
        if (data.result) {
            hideLoadingSpinner();
            
            // Process the final result - add Additional Reading if configured
            let finalResult = data.result;
            
            // Check if we need to add selected articles as Additional Reading
            const selectArticlesButton = document.getElementById('selectArticlesButton');
            const includeArticles = document.getElementById('includeArticles');
            
            if (includeArticles && includeArticles.checked && 
                selectArticlesButton && selectArticlesButton.dataset.selectedArticlesData) {
                try {
                    const articlesData = JSON.parse(selectArticlesButton.dataset.selectedArticlesData);
                    if (articlesData && articlesData.length > 0) {
                        console.log(`Adding ${articlesData.length} selected articles to Additional Reading section`);
                        finalResult = appendAdditionalReadingSection(finalResult, articlesData);
                    }
                } catch (err) {
                    console.error('Error appending Additional Reading section:', err);
                }
            }
            
            setMarkdownContent(finalResult);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleString();
            }
            
            // Clean up WebSocket and polling
            cleanupProgressMonitoring();
        }
    } catch (error) {
        console.error('Error fetching compilation result:', error);
    }
}

// Function to update the progress UI
function updateProgressUI(data) {
    // Update progress bar
    const progressBar = document.getElementById('compilationProgress');
    if (progressBar) {
        const progress = Math.min(Math.max(data.progress || 0, 0), 100);
        progressBar.style.width = `${progress}%`;
        progressBar.setAttribute('aria-valuenow', progress);
        progressBar.textContent = `${Math.round(progress)}%`;
    }
    
    // Update status text
    const statusElement = document.getElementById('compilationStatus');
    if (statusElement) {
        statusElement.textContent = data.status === 'in_progress' ? 
            'Compilation in progress...' : 
            (data.status === 'completed' ? 'Compilation completed!' : data.status);
    }
    
    // Update step description
    const stepElement = document.getElementById('compilationStep');
    if (stepElement && data.current_step) {
        stepElement.textContent = data.current_step;
        if (data.message) {
            stepElement.textContent += `: ${data.message}`;
        }
    }
}

// Function to clean up progress monitoring
function cleanupProgressMonitoring() {
    // Close WebSocket if open
    if (window.newsletterWebSocket) {
        window.newsletterWebSocket.close();
        window.newsletterWebSocket = null;
    }
    
    // Clear polling interval if active
    if (window.newsletterPollingInterval) {
        clearInterval(window.newsletterPollingInterval);
        window.newsletterPollingInterval = null;
    }
}

// Helper function to hide the loading spinner
function hideLoadingSpinner() {
    const loadingSpinner = document.getElementById('loadingSpinner');
    if (loadingSpinner) {
        loadingSpinner.style.display = 'none';
    }
}

// Helper function to show and initialize the loading spinner
function showLoadingSpinner(compilationId) {
    const loadingSpinner = document.getElementById('loadingSpinner');
    if (!loadingSpinner) return;
    
    // Show the spinner
    loadingSpinner.style.display = 'block';
    
    // Initialize progress UI elements
    const progressBar = document.getElementById('compilationProgress');
    const statusElement = document.getElementById('compilationStatus');
    const stepElement = document.getElementById('compilationStep');
    
    if (progressBar) {
        progressBar.style.width = '0%';
        progressBar.setAttribute('aria-valuenow', 0);
        progressBar.textContent = '0%';
    }
    
    if (statusElement) {
        statusElement.textContent = 'Compilation in progress...';
    }
    
    if (stepElement) {
        stepElement.textContent = 'Starting compilation... This may take a few minutes.';
    }
    
    // Set compilation ID if available
    const compilationIdElement = document.getElementById('compilationID');
    if (compilationIdElement && compilationId) {
        compilationIdElement.textContent = `Compilation ID: ${compilationId}`;
    }
}

    // Function to save the prompt template
async function savePromptTemplate() {
    try {
        const contentTypeId = document.getElementById('promptEditorContentTypeId').value;
        const promptTemplate = document.getElementById('promptEditorText').value;
        
        if (!contentTypeId) {
            throw new Error('Content type ID is missing');
        }
        
        if (!promptTemplate || !promptTemplate.trim()) {
            throw new Error('Prompt template cannot be empty');
        }
        
        console.log(`Saving prompt for content type ${contentTypeId}`);
        
        // Prepare the request
        const payload = {
            prompt_template: promptTemplate
        };
        
        // Send update request
        const response = await fetch(`/api/newsletter/prompts/${contentTypeId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API returned status ${response.status}: ${errorText}`);
        }
        
        // Update the input field with the new value
        const promptInput = document.getElementById(`prompt-${contentTypeId}`);
        if (promptInput) {
            promptInput.value = promptTemplate;
        }
        
        // Hide the modal using native JavaScript
        const modal = document.getElementById('promptEditorModal');
        if (modal) {
            modal.classList.remove('show');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }
        
        // Show success message
        console.log('Prompt saved successfully');
        alert('Prompt saved successfully!');
        
    } catch (error) {
        console.error('Error saving prompt:', error);
        alert(`Error saving prompt: ${error.message}`);
    }
}

// Function to restore default prompt
function restoreDefaultPrompt() {
    try {
        const modalPromptTextarea = document.getElementById('promptEditorText');
        if (!modalPromptTextarea) {
            throw new Error('Prompt textarea not found');
        }
        
        // First try to restore the default prompt, fall back to original if not available
        if (modalPromptTextarea.dataset.defaultPrompt) {
            modalPromptTextarea.value = modalPromptTextarea.dataset.defaultPrompt;
        } else if (modalPromptTextarea.dataset.originalPrompt) {
            modalPromptTextarea.value = modalPromptTextarea.dataset.originalPrompt;
        } else {
            throw new Error('No default or original prompt available to restore');
        }
        
        console.log('Prompt restored to default');
    } catch (error) {
        console.error('Error restoring default prompt:', error);
        alert(`Error restoring default prompt: ${error.message}`);
    }
}

// Function to restore articles from backup (disabled to prevent persistence between sessions)
function restoreArticlesFromBackup() {
    console.log('Article restoration from localStorage is disabled to prevent persistence between sessions');
    localStorage.removeItem('selected_articles_backup'); // Clean up any existing backup
    return false;
}

// Chart Selection Modal Functions
function openChartSelectionModal() {
    try {
        // Load previously selected charts
        const chartCheckboxes = document.querySelectorAll('#chartSelectionForm input[type="checkbox"]');
        chartCheckboxes.forEach(checkbox => {
            checkbox.checked = selectedCharts.includes(checkbox.value);
        });
        
        // Show modal
        const modal = document.getElementById('chartSelectionModal');
        if (modal) {
            // First clear any existing backdrop
            const existingBackdrop = document.querySelector('.modal-backdrop');
            if (existingBackdrop) existingBackdrop.remove();
            
            // Add modal classes and attributes
            modal.classList.add('show');
            modal.style.display = 'block';
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            
            // Create backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop fade show';
            document.body.appendChild(backdrop);
        }
    } catch (error) {
        console.error('Error opening chart selection modal:', error);
    }
}

function saveChartSelection() {
    try {
        // Get selected charts
        const chartCheckboxes = document.querySelectorAll('#chartSelectionForm input[type="checkbox"]:checked');
        selectedCharts = Array.from(chartCheckboxes).map(checkbox => checkbox.value);
        
        console.log('Selected charts:', selectedCharts);
        
        // Update UI to show charts are selected
        const chartBtn = document.getElementById('selectChartButton');
        if (chartBtn) {
            // Update button style to show active state
            chartBtn.classList.remove('btn-outline-secondary');
            chartBtn.classList.add('btn-success');
            
            // Update button text to show count
            const chartCount = selectedCharts.length;
            if (chartCount > 0) {
                chartBtn.innerHTML = `<i class="fa fa-chart-bar"></i> ${chartCount} Chart${chartCount !== 1 ? 's' : ''} Selected`;
            } else {
                chartBtn.innerHTML = `<i class="fa fa-chart-bar"></i> Select Charts`;
                chartBtn.classList.remove('btn-success');
                chartBtn.classList.add('btn-outline-secondary');
            }
        }
        
        // Close modal
        closeChartSelectionModal();
    } catch (error) {
        console.error('Error saving chart selection:', error);
    }
}

function closeChartSelectionModal() {
    const modal = document.getElementById('chartSelectionModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
        
        // Also remove the backdrop if it exists
        const backdrop = document.querySelector('.modal-backdrop');
        if (backdrop) {
            backdrop.remove();
        }
    }
}

// Save Newsletter Functions
function openSaveNewsletterModal() {
    // Generate a default filename
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    const frequency = document.getElementById('frequency').value;
    const topicsSelect = document.getElementById('topics');
    const topics = Array.from(topicsSelect.selectedOptions).map(option => option.textContent).join('_').toLowerCase();
    
    const defaultFilename = `${frequency}_${topics || 'newsletter'}_${dateStr}`;
    
    // Set default filename
    document.getElementById('newsletterFilename').value = defaultFilename;
    
    // Show modal
    const modal = document.getElementById('saveNewsletterModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');
    }
}

function closeSaveNewsletterModal() {
    const modal = document.getElementById('saveNewsletterModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
    }
}

async function saveNewsletterToServer() {
    try {
        const filename = document.getElementById('newsletterFilename').value.trim();
        if (!filename) {
            alert('Please enter a filename');
            return;
        }
        
        const markdownContent = getMarkdownContent();
        if (!markdownContent.trim()) {
            alert('No content to save');
            return;
        }
        
        // Close modal
        closeSaveNewsletterModal();
        
        // Show loading indicator
        const saveBtn = document.getElementById('saveNewsletterButton');
        const originalBtnText = saveBtn.innerHTML;
        saveBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Saving...';
        saveBtn.disabled = true;
        
        // Send save request
        const response = await fetch('/api/newsletter/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: markdownContent,
                filename: filename
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to save newsletter: ${errorText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            alert('Newsletter saved successfully!');
            // Refresh saved newsletters list
            loadSavedNewsletters();
        } else {
            throw new Error(result.error || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Error saving newsletter:', error);
        alert(`Error saving newsletter: ${error.message}`);
    } finally {
        // Restore button
        const saveBtn = document.getElementById('saveNewsletterButton');
        if (saveBtn) {
            saveBtn.innerHTML = '<i class="fa fa-save"></i> Save';
            saveBtn.disabled = false;
        }
    }
}

// Function to load saved newsletters
async function loadSavedNewsletters() {
    try {
        const container = document.getElementById('savedNewslettersContainer');
        if (!container) {
            console.error('savedNewslettersContainer element not found');
            return;
        }
        
        // Show loading
        container.innerHTML = '<div class="text-center text-muted py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Loading saved newsletters...</div>';
        
        console.log('Fetching saved newsletters from API...');
        const response = await fetch('/api/newsletter/saved');
        console.log('API response status:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Server returned error: ${errorText}`);
            throw new Error(`Failed to load saved newsletters: ${response.status} - ${errorText}`);
        }
        
        let newsletters;
        try {
            newsletters = await response.json();
            console.log(`Loaded ${newsletters.length} newsletters:`, newsletters);
        } catch (parseError) {
            console.error('Error parsing API response:', parseError);
            throw new Error(`Failed to parse API response: ${parseError.message}`);
        }
        
        // Clear container
        container.innerHTML = '';
        
        if (!Array.isArray(newsletters)) {
            console.error('API returned non-array response:', newsletters);
            container.innerHTML = '<div class="text-center text-danger py-3">Error: Invalid response format</div>';
            return;
        }
        
        if (newsletters.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No saved newsletters found</div>';
            return;
        }
        
        // Sort newsletters by date (most recent first)
        newsletters.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));
        
        console.log(`Creating UI elements for ${newsletters.length} newsletters`);
        
        // Create list items
        newsletters.forEach((newsletter, index) => {
            try {
                console.log(`Processing newsletter ${index + 1}/${newsletters.length}, ID: ${newsletter.id}`);
                
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                item.dataset.newsletterId = newsletter.id;
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    loadNewsletter(newsletter.id);
                });
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'd-flex flex-column';
                
                const title = document.createElement('strong');
                title.textContent = newsletter.filename || 'Unnamed Newsletter';
                contentDiv.appendChild(title);
                
                if (newsletter.date) {
                    const date = document.createElement('small');
                    date.className = 'text-muted';
                    date.textContent = new Date(newsletter.date).toLocaleString();
                    contentDiv.appendChild(date);
                }
                
                item.appendChild(contentDiv);
                
                const btnGroup = document.createElement('div');
                btnGroup.className = 'btn-group btn-group-sm';
                
                const editBtn = document.createElement('button');
                editBtn.type = 'button';
                editBtn.className = 'btn btn-outline-primary';
                editBtn.innerHTML = '<i class="fa fa-pencil"></i>';
                editBtn.title = 'Edit this newsletter';
                editBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    loadNewsletter(newsletter.id);
                });
                btnGroup.appendChild(editBtn);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'btn btn-outline-danger';
                deleteBtn.innerHTML = '<i class="fa fa-trash"></i>';
                deleteBtn.title = 'Delete this newsletter';
                deleteBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // The confirmation is now handled in the deleteNewsletter function
                    deleteNewsletter(newsletter.id);
                });
                btnGroup.appendChild(deleteBtn);
                
                item.appendChild(btnGroup);
                container.appendChild(item);
            } catch (itemError) {
                console.error(`Error creating newsletter item ${index}:`, itemError, newsletter);
            }
        });
        
        console.log('Newsletters loaded successfully');
        
    } catch (error) {
        console.error('Error loading saved newsletters:', error);
        const container = document.getElementById('savedNewslettersContainer');
        if (container) {
            container.innerHTML = `<div class="text-center text-danger py-3">Error loading newsletters: ${error.message}</div>`;
        }
    }
}

// Function to load a saved newsletter
async function loadNewsletter(id) {
    try {
        console.log(`Loading newsletter with ID: ${id}`);
        
        const response = await fetch(`/api/newsletter/saved/${id}`);
        console.log(`Newsletter API response status: ${response.status}`);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Server returned error: ${errorText}`);
            throw new Error(`Failed to load newsletter: ${response.status} - ${errorText}`);
        }
        
        const newsletter = await response.json();
        console.log('Loaded newsletter data:', newsletter);
        
        // Update editor with newsletter content
        if (newsletter.content) {
            console.log(`Setting editor content (length: ${newsletter.content.length})`);
            
            // Wait for editor to be fully initialized
            if (!editor) {
                console.error('Editor not initialized!');
                alert('Editor not ready. Please try again in a moment.');
                return;
            }
            
            let contentToSet = newsletter.content;
            
            // Check if content appears to be HTML and not Markdown
            if (contentToSet.startsWith('<') && (contentToSet.includes('<html') || contentToSet.includes('<body') || contentToSet.includes('<div') || contentToSet.includes('<img'))) {
                console.log('Content appears to be HTML, converting to Markdown...');
                
                // For simple HTML content, use regex replacements
                contentToSet = contentToSet
                    // Fix image tags to markdown format
                    .replace(/<img\s+src="([^"]*)"(?:\s+alt="([^"]*)")?\s*\/?>/gi, function(match, src, alt) {
                        return `![${alt || 'Image'}](${src})`;
                    })
                    // Fix heading tags
                    .replace(/<h1(?:\s+[^>]*)?>(.*?)<\/h1>/gi, '# $1\n\n')
                    .replace(/<h2(?:\s+[^>]*)?>(.*?)<\/h2>/gi, '## $1\n\n')
                    .replace(/<h3(?:\s+[^>]*)?>(.*?)<\/h3>/gi, '### $1\n\n')
                    .replace(/<h4(?:\s+[^>]*)?>(.*?)<\/h4>/gi, '#### $1\n\n')
                    // Fix paragraph tags
                    .replace(/<p(?:\s+[^>]*)?>(.*?)<\/p>/gi, '$1\n\n')
                    // Fix links
                    .replace(/<a\s+href="([^"]*)"(?:\s+[^>]*)?>(.*?)<\/a>/gi, '[$2]($1)')
                    // Fix bold and italic
                    .replace(/<strong(?:\s+[^>]*)?>(.*?)<\/strong>/gi, '**$1**')
                    .replace(/<b(?:\s+[^>]*)?>(.*?)<\/b>/gi, '**$1**')
                    .replace(/<em(?:\s+[^>]*)?>(.*?)<\/em>/gi, '*$1*')
                    .replace(/<i(?:\s+[^>]*)?>(.*?)<\/i>/gi, '*$1*')
                    // Fix lists
                    .replace(/<ul(?:\s+[^>]*)?>(.*?)<\/ul>/gis, function(match, content) {
                        return content.replace(/<li(?:\s+[^>]*)?>(.*?)<\/li>/gi, '* $1\n');
                    })
                    .replace(/<ol(?:\s+[^>]*)?>(.*?)<\/ol>/gis, function(match, content) {
                        let counter = 1;
                        return content.replace(/<li(?:\s+[^>]*)?>(.*?)<\/li>/gi, function(match, item) {
                            return `${counter++}. ${item}\n`;
                        });
                    })
                    // Remove common HTML tags
                    .replace(/<\/?(?:div|span|table|tr|td|th|thead|tbody|br)[^>]*>/gi, '\n')
                    .replace(/<\/?[a-z][^>]*>/gi, '') // Remove any remaining HTML tags
                    .replace(/&nbsp;/gi, ' ')
                    .replace(/&lt;/gi, '<')
                    .replace(/&gt;/gi, '>')
                    .replace(/&amp;/gi, '&')
                    .replace(/&quot;/gi, '"')
                    .replace(/&#39;/gi, "'")
                    // Clean up extra whitespace and newlines
                    .replace(/\n\s*\n\s*\n/g, '\n\n')
                    .trim();
                
                console.log('Converted to Markdown format');
            }
            
            // Set content in editor
            setMarkdownContent(contentToSet);
            
            // Force an update of the preview
            setTimeout(() => {
                updatePreview();
                console.log('Preview updated');
            }, 100);
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const dateStr = newsletter.date ? 
                    new Date(newsletter.date).toLocaleString() : 
                    'Just loaded';
                lastUpdatedElement.textContent = dateStr;
                console.log(`Updated last updated time: ${dateStr}`);
            }
        } else {
            console.error('Newsletter has no content:', newsletter);
            throw new Error('No content found in the newsletter');
        }
        
    } catch (error) {
        console.error('Error loading newsletter:', error);
        alert(`Error loading newsletter: ${error.message}`);
    }
}

// Function to delete a saved newsletter
async function deleteNewsletter(id) {
    try {
        console.log(`Attempting to delete newsletter with ID: ${id}`);
        
        // First check if the newsletter exists
        const checkResponse = await fetch(`/api/newsletter/saved/${id}`);
        if (checkResponse.status === 404) {
            console.error(`Newsletter with ID ${id} not found`);
            alert(`Newsletter not found. It may have been deleted already.`);
            // Refresh the list anyway to ensure UI is in sync
            loadSavedNewsletters();
            return;
        }
        
        // Confirm with the user again to prevent accidental deletions
        const confirmDelete = confirm(`Are you sure you want to delete this newsletter? This action cannot be undone.`);
        if (!confirmDelete) {
            console.log('Deletion cancelled by user');
            return;
        }
        
        // Proceed with deletion
        const response = await fetch(`/api/newsletter/saved/${id}`, {
            method: 'DELETE'
        });
        
        console.log(`Delete API response status: ${response.status}`);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Server returned error: ${errorText}`);
            throw new Error(`Failed to delete newsletter: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        console.log('Delete operation result:', result);
        
        // Show success message
        alert(`Newsletter deleted successfully.`);
        
        // Refresh saved newsletters list
        loadSavedNewsletters();
        
    } catch (error) {
        console.error('Error deleting newsletter:', error);
        alert(`Error deleting newsletter: ${error.message}`);
    }
}

// PDF Export Function
async function downloadPDF() {
    try {
        const markdownContent = getMarkdownContent();
        
        if (!markdownContent.trim()) {
            alert('No content to convert to PDF');
            return;
        }
        
        // Show loading indicator
        const pdfBtn = document.getElementById('downloadPdfButton');
        const originalBtnText = pdfBtn.innerHTML;
        pdfBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Generating PDF...';
        pdfBtn.disabled = true;
        
        // Convert markdown to PDF
        const response = await fetch('/api/newsletter/export_pdf', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                markdown_content: markdownContent
            })
        });
        
        if (!response.ok) {
            throw new Error(`Failed to generate PDF: ${response.status}`);
        }
        
        // Get the PDF file as blob
        const blob = await response.blob();
        
        // Create filename with date
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        const frequency = document.getElementById('frequency').value;
        const topicsSelect = document.getElementById('topics');
        const topics = Array.from(topicsSelect.selectedOptions).map(option => option.value).join('-');
        
        const filename = `${frequency}_${topics || 'newsletter'}_${dateStr}.pdf`;
        
        // Create download link
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
    } catch (error) {
        console.error('Error generating PDF:', error);
        alert(`Error generating PDF: ${error.message}`);
    } finally {
        // Restore button
        const pdfBtn = document.getElementById('downloadPdfButton');
        if (pdfBtn) {
            pdfBtn.innerHTML = '<i class="fa fa-file-pdf-o"></i> Download PDF';
            pdfBtn.disabled = false;
        }
    }
}

// Send Email Function
async function sendEmailNewsletter() {
    try {
        // Get email recipients from user
        const recipients = prompt('Enter email addresses (comma-separated):');
        if (!recipients) return;
        
        const markdownContent = getMarkdownContent();
        if (!markdownContent.trim()) {
            alert('No content to send');
            return;
        }
        
        // Show loading indicator
        const emailBtn = document.getElementById('sendEmailButton');
        const originalBtnText = emailBtn.innerHTML;
        emailBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Sending...';
        emailBtn.disabled = true;
        
        // Create subject
        const frequency = document.getElementById('frequency').value;
        const topicsSelect = document.getElementById('topics');
        const topics = Array.from(topicsSelect.selectedOptions).map(option => option.textContent).join(', ');
        const today = new Date();
        const dateStr = today.toLocaleDateString();
        
        const subject = `${frequency.charAt(0).toUpperCase() + frequency.slice(1)} Newsletter: ${topics} - ${dateStr}`;
        
        // Send email request
        const response = await fetch('/api/newsletter/send_email', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                recipients: recipients.split(',').map(email => email.trim()),
                subject: subject,
                markdown_content: markdownContent
            })
        });
        
        if (!response.ok) {
            throw new Error(`Failed to send email: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            alert('Newsletter sent successfully!');
        } else {
            throw new Error(result.error || 'Unknown error');
        }
        
    } catch (error) {
        console.error('Error sending email:', error);
        alert(`Error sending email: ${error.message}`);
    } finally {
        // Restore button
        const emailBtn = document.getElementById('sendEmailButton');
        if (emailBtn) {
            emailBtn.innerHTML = '<i class="fa fa-envelope"></i> Send Email';
            emailBtn.disabled = false;
        }
    }
}

// Function to save the current newsletter state to localStorage
function saveNewsletterState() {
    try {
        // Save editor content
        if (editor) {
            const content = getMarkdownContent();
            
            // Check if content is too large for localStorage (5MB limit in most browsers)
            if (content && content.length > 0) {
                const contentSize = new Blob([content]).size;
                const maxSize = 4 * 1024 * 1024; // 4MB max to be safe
                
                if (contentSize > maxSize) {
                    console.warn(`Content too large for localStorage (${Math.round(contentSize/1024/1024)}MB). Saving metadata only.`);
                    // Save a trimmed version without base64 images
                    const trimmedContent = replaceBase64WithPlaceholders(content);
                    localStorage.setItem('newsletter_content', trimmedContent);
                    localStorage.setItem('newsletter_content_trimmed', 'true');
                } else {
                    localStorage.setItem('newsletter_content', content);
                    localStorage.setItem('newsletter_content_trimmed', 'false');
                }
            }
        }
        
        // Save configuration
        const topicsSelect = document.getElementById('topics');
        const frequencySelect = document.getElementById('frequency');
        const aiModelSelect = document.getElementById('ai_model');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        
        const config = {
            topics: topicsSelect ? Array.from(topicsSelect.selectedOptions).map(opt => opt.value) : [],
            frequency: frequencySelect ? frequencySelect.value : 'weekly',
            aiModel: aiModelSelect ? aiModelSelect.value : 'gpt-4o',
            startDate: startDateInput ? startDateInput.value : '',
            endDate: endDateInput ? endDateInput.value : ''
        };
        
        localStorage.setItem('newsletter_config', JSON.stringify(config));
        console.log('Newsletter state saved to localStorage');
    } catch (e) {
        console.error('Error saving newsletter state:', e);
    }
}

// Function to check for and load any saved local state
function checkSavedState() {
    try {
        // Look for saved content in localStorage
        const savedContent = localStorage.getItem('newsletter_content');
        if (savedContent) {
            console.log('Found saved content in localStorage');
            // Check if content was trimmed due to size
            const wasTrimmed = localStorage.getItem('newsletter_content_trimmed') === 'true';
            
            if (wasTrimmed) {
                console.log('Content was trimmed when saved - base64 images may be missing');
            }
            
            // Set the editor content if we have the editor initialized
            if (editor) {
                editor.value(savedContent);
                updatePreview();
                
                // Show notification if content was trimmed
                if (wasTrimmed) {
                    setTimeout(() => {
                        alert('Note: The loaded newsletter had base64 images removed due to size limits. Some images may not display properly.');
                    }, 1000);
                }
            }
        }
        
        // Load saved configuration from localStorage if available
        const savedConfig = localStorage.getItem('newsletter_config');
        if (savedConfig) {
            try {
                const config = JSON.parse(savedConfig);
                console.log('Found saved configuration', config);
                
                // Restore topic selections
                if (config.topics && Array.isArray(config.topics)) {
                    const topicSelect = document.getElementById('topics');
                    if (topicSelect) {
                        // Wait until topics are loaded
                        const checkTopicsInterval = setInterval(() => {
                            if (topicSelect.options.length > 0) {
                                clearInterval(checkTopicsInterval);
                                
                                // Select topics
                                for (let i = 0; i < topicSelect.options.length; i++) {
                                    topicSelect.options[i].selected = config.topics.includes(topicSelect.options[i].value);
                                }
                            }
                        }, 100);
                    }
                }
                
                // Restore frequency
                if (config.frequency) {
                    const frequencySelect = document.getElementById('frequency');
                    if (frequencySelect) {
                        frequencySelect.value = config.frequency;
                    }
                }
                
                // Restore AI model
                if (config.aiModel) {
                    const aiModelSelect = document.getElementById('ai_model');
                    if (aiModelSelect) {
                        aiModelSelect.value = config.aiModel;
                    }
                }
                
                // Restore date range
                if (config.startDate) {
                    document.getElementById('startDate').value = config.startDate;
                }
                if (config.endDate) {
                    document.getElementById('endDate').value = config.endDate;
                }
            } catch (e) {
                console.error('Error parsing saved configuration:', e);
                localStorage.removeItem('newsletter_config');
            }
        }
    } catch (e) {
        console.error('Error checking saved state:', e);
        // If there's an error, clear the saved state to prevent future errors
        localStorage.removeItem('newsletter_content');
        localStorage.removeItem('newsletter_config');
    }
}

// Initialize everything when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Load newsletter saved state if available
    checkSavedState();
    
    // Load saved newsletters
    loadSavedNewsletters();
    
    // Load available topics
    loadTopics();
    
    // Load content types
    loadContentTypes();
    
    // No longer restoring selected articles from backup to prevent persistence between sessions
    console.log('Articles do NOT persist between sessions');
    
    // Set up chart selection modal buttons
    const closeChartModalBtn = document.getElementById('closeChartSelectionModal');
    const cancelChartModalBtn = document.getElementById('cancelChartSelectionModal');
    const saveChartSelectionBtn = document.getElementById('saveChartSelectionButton');
    
    if (closeChartModalBtn) closeChartModalBtn.addEventListener('click', closeChartSelectionModal);
    if (cancelChartModalBtn) cancelChartModalBtn.addEventListener('click', closeChartSelectionModal);
    if (saveChartSelectionBtn) saveChartSelectionBtn.addEventListener('click', saveChartSelection);
    
    // Add event listeners to save state when changes are made
    const topicsSelect = document.getElementById('topics');
    const frequencySelect = document.getElementById('frequency');
    const aiModelSelect = document.getElementById('ai_model');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    // Add event listeners for date range buttons
    const dayRangeBtn = document.getElementById('dayRangeBtn');
    const weekRangeBtn = document.getElementById('weekRangeBtn');
    const monthRangeBtn = document.getElementById('monthRangeBtn');
    
    if (dayRangeBtn) dayRangeBtn.addEventListener('click', setDayRange);
    if (weekRangeBtn) weekRangeBtn.addEventListener('click', setWeekRange);
    if (monthRangeBtn) monthRangeBtn.addEventListener('click', setMonthRange);
    
    // Save state when form elements change
    if (topicsSelect) topicsSelect.addEventListener('change', saveNewsletterState);
    if (frequencySelect) frequencySelect.addEventListener('change', saveNewsletterState);
    if (aiModelSelect) aiModelSelect.addEventListener('change', saveNewsletterState);
    if (startDateInput) {
        startDateInput.addEventListener('change', function() {
            saveNewsletterState();
            resetDateRangeButtonStyles();
        });
    }
    if (endDateInput) {
        endDateInput.addEventListener('change', function() {
            saveNewsletterState();
            resetDateRangeButtonStyles();
        });
    }
    
    // Frequency selector is now a standard dropdown
    
    // Add clear saved state button handler
    const clearSavedStateBtn = document.getElementById('clearSavedStateButton');
    if (clearSavedStateBtn) {
        clearSavedStateBtn.addEventListener('click', clearSavedState);
    }
    
    // Add refresh saved newsletters button handler
    const refreshSavedNewslettersBtn = document.getElementById('refreshSavedNewslettersBtn');
    if (refreshSavedNewslettersBtn) {
        refreshSavedNewslettersBtn.addEventListener('click', function() {
            console.log('Refreshing saved newsletters...');
            loadSavedNewsletters();
        });
    }
    
    // Add event listener to save editor content when it changes
if (editor) {
    // Track content length to avoid saving unnecessarily for large documents
    let lastSavedContentLength = 0;
    let lastSaveTime = Date.now();
    
    editor.codemirror.on("change", function() {
        // Get current content length - more efficient than getting full content
        const currentLength = editor.codemirror.getValue().length;
        const now = Date.now();
        
        // Only save if:
        // 1. Content length changed significantly (>100 chars) OR
        // 2. At least 10 seconds passed since last save
        const contentChangedSignificantly = Math.abs(currentLength - lastSavedContentLength) > 100;
        const timePassedSinceLastSave = now - lastSaveTime > 10000; // 10 seconds
        
        if (contentChangedSignificantly || timePassedSinceLastSave) {
            // Delay saving to avoid too many saves during typing
            clearTimeout(window.editorSaveTimeout);
            window.editorSaveTimeout = setTimeout(() => {
                saveNewsletterState();
                lastSavedContentLength = currentLength;
                lastSaveTime = Date.now();
            }, 2000); // Increased to 2 seconds
        }
    });
}
    
    // Set up action buttons
    const compileButton = document.getElementById('compileButton');
    const downloadMarkdownButton = document.getElementById('downloadMarkdownButton');
    const downloadPdfButton = document.getElementById('downloadPdfButton');
    const saveToServerButton = document.getElementById('saveToServerButton');
    const sendEmailButton = document.getElementById('sendEmailButton');
    const sendSlackButton = document.getElementById('sendSlackButton');
    
    if (compileButton) compileButton.addEventListener('click', compileNewsletter);
    if (downloadMarkdownButton) downloadMarkdownButton.addEventListener('click', downloadMarkdown);
    if (downloadPdfButton) downloadPdfButton.addEventListener('click', downloadPDF);
    if (saveToServerButton) saveToServerButton.addEventListener('click', openSaveNewsletterModal);
    if (sendEmailButton) sendEmailButton.addEventListener('click', sendEmailNewsletter);
    if (sendSlackButton) sendSlackButton.addEventListener('click', function() {
        alert('Slack integration not implemented yet.');
    });
    
    // Set up save newsletter modal buttons
    const closeSaveNewsletterModalBtn = document.getElementById('closeSaveNewsletterModal');
    const cancelSaveNewsletterModalBtn = document.getElementById('cancelSaveNewsletterModal');
    const saveNewsletterBtn = document.getElementById('saveNewsletterButton');
    
    if (closeSaveNewsletterModalBtn) closeSaveNewsletterModalBtn.addEventListener('click', closeSaveNewsletterModal);
    if (cancelSaveNewsletterModalBtn) cancelSaveNewsletterModalBtn.addEventListener('click', closeSaveNewsletterModal);
    if (saveNewsletterBtn) saveNewsletterBtn.addEventListener('click', saveNewsletterToServer);
    
    // Set up prompt editor modal buttons
    const closePromptEditorModalBtn = document.getElementById('closePromptEditorModal');
    const cancelPromptEditorModalBtn = document.getElementById('cancelPromptEditorModal');
    const savePromptBtn = document.getElementById('savePromptButton');
    const restorePromptBtn = document.getElementById('restorePromptButton');
    
    if (closePromptEditorModalBtn) closePromptEditorModalBtn.addEventListener('click', function() {
        const modal = document.getElementById('promptEditorModal');
        if (modal) {
            modal.classList.remove('show');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }
    });
    
    if (cancelPromptEditorModalBtn) cancelPromptEditorModalBtn.addEventListener('click', function() {
        const modal = document.getElementById('promptEditorModal');
        if (modal) {
            modal.classList.remove('show');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }
    });
    
    if (savePromptBtn) savePromptBtn.addEventListener('click', savePromptTemplate);
    if (restorePromptBtn) restorePromptBtn.addEventListener('click', restoreDefaultPrompt);
    
    // Set up select all content types button
    const selectAllContentTypesBtn = document.getElementById('selectAllContentTypes');
    if (selectAllContentTypesBtn) {
        selectAllContentTypesBtn.addEventListener('click', toggleSelectAllContentTypes);
    }
    
    // Set up events for modals
    const closePodcastSelectionModalBtn = document.getElementById('closePodcastSelectionModal');
    const cancelPodcastSelectionModalBtn = document.getElementById('cancelPodcastSelectionModal');
    const savePodcastSelectionBtn = document.getElementById('savePodcastSelectionButton');
    
    if (closePodcastSelectionModalBtn) {
        closePodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (cancelPodcastSelectionModalBtn) {
        cancelPodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (savePodcastSelectionBtn) {
        savePodcastSelectionBtn.addEventListener('click', savePodcastSelection);
    }
    
    // Setup article search modal
    const closeArticleSelectionModalBtn = document.getElementById('closeArticleSelectionModal');
    const cancelArticleSelectionModalBtn = document.getElementById('cancelArticleSelectionModal');
    const saveArticleSelectionBtn = document.getElementById('saveArticleSelectionButton');
    const articleSearchBtn = document.getElementById('articleSearchButton');
    
    if (closeArticleSelectionModalBtn) {
        closeArticleSelectionModalBtn.addEventListener('click', closeArticleSelectionModal);
    }
    
    if (cancelArticleSelectionModalBtn) {
        cancelArticleSelectionModalBtn.addEventListener('click', closeArticleSelectionModal);
    }
    
    if (saveArticleSelectionBtn) {
        saveArticleSelectionBtn.addEventListener('click', saveArticleSelection);
    }
    
    if (articleSearchBtn) {
        articleSearchBtn.addEventListener('click', searchArticles);
    }
    
    // Load topics for the article search dropdown
    loadTopicsForArticleSearch();
});

// Podcast Selection Modal Functions
let selectedPodcast = null;

function openPodcastSelectionModal() {
    // Load podcasts from API
    loadPodcasts();
    
    // Show modal
    const modal = document.getElementById('podcastSelectionModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        modal.setAttribute('aria-hidden', 'false');
        document.body.classList.add('modal-open');
    }
}

async function loadPodcasts() {
    try {
        const container = document.getElementById('podcastListContainer');
        if (!container) return;
        
        // Show loading
        container.innerHTML = '<div class="text-center py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Loading podcasts...</div>';
        
        // Fetch podcasts from API
        const response = await fetch('/api/newsletter/podcasts');
        
        if (!response.ok) {
            throw new Error(`Failed to load podcasts: ${response.status}`);
        }
        
        const podcasts = await response.json();
        
        // Clear container
        container.innerHTML = '';
        
        if (podcasts.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No podcasts found</div>';
            return;
        }
        
        // Create list items for each podcast
        podcasts.forEach(podcast => {
            const item = document.createElement('a');
            item.href = '#';
            item.className = 'list-group-item list-group-item-action';
            item.dataset.podcastId = podcast.id;
            
            // Create podcast item content
            const title = document.createElement('h5');
            title.className = 'mb-1';
            title.textContent = podcast.title || 'Untitled Podcast';
            
            const details = document.createElement('div');
            details.className = 'small text-muted';
            
            // Format created date if available
            let dateText = '';
            if (podcast.created_at) {
                dateText = new Date(podcast.created_at).toLocaleDateString();
            }
            
            // Add topic if available
            let topicText = '';
            if (podcast.topic) {
                topicText = `Topic: ${podcast.topic}`;
            }
            
            details.textContent = [dateText, topicText].filter(Boolean).join(' | ');
            
            item.appendChild(title);
            item.appendChild(details);
            
            // Add click handler to select this podcast
            item.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Deselect any previously selected podcast
                document.querySelectorAll('#podcastListContainer .list-group-item.active').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Select this podcast
                item.classList.add('active');
                selectedPodcast = podcast;
            });
            
            container.appendChild(item);
        });
        
    } catch (error) {
        console.error('Error loading podcasts:', error);
        const container = document.getElementById('podcastListContainer');
        if (container) {
            container.innerHTML = `<div class="text-center text-danger py-3">Error loading podcasts: ${error.message}</div>`;
        }
    }
}

function savePodcastSelection() {
    if (!selectedPodcast) {
        alert('Please select a podcast first');
        return;
    }
    
    // Use the new handler function to update the UI
    handlePodcastSelection(selectedPodcast);
    
    // Store the podcast content template for later use when generating
    const podcastTemplate = {
        title: selectedPodcast.title || 'Podcast',
        date: selectedPodcast.created_at ? new Date(selectedPodcast.created_at).toLocaleDateString() : null,
        audio_url: selectedPodcast.audio_url || null,
        topic: selectedPodcast.topic || null
    };
    
    // Store the template for use when compiling
    document.getElementById('selectedPodcastName').dataset.podcastTemplate = JSON.stringify(podcastTemplate);
    
    // Close modal
    closePodcastSelectionModal();
}

function closePodcastSelectionModal() {
    const modal = document.getElementById('podcastSelectionModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('modal-open');
    }
}

// Add new modal event handlers in the DOMContentLoaded event
document.addEventListener('DOMContentLoaded', function() {
    // Set up podcast selection modal buttons
    const closePodcastSelectionModalBtn = document.getElementById('closePodcastSelectionModal');
    const cancelPodcastSelectionModalBtn = document.getElementById('cancelPodcastSelectionModal');
    const savePodcastSelectionBtn = document.getElementById('savePodcastSelectionButton');
    
    if (closePodcastSelectionModalBtn) {
        closePodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (cancelPodcastSelectionModalBtn) {
        cancelPodcastSelectionModalBtn.addEventListener('click', closePodcastSelectionModal);
    }
    
    if (savePodcastSelectionBtn) {
        savePodcastSelectionBtn.addEventListener('click', savePodcastSelection);
    }
});

// Function to show toast notifications
function showToast(message, type = 'info') {
    // Check if toast container exists, if not create one
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
        toastContainer.style.zIndex = '1070';
        document.body.appendChild(toastContainer);
    }
    
    // Create a new toast
    const toastId = 'toast-' + Date.now();
    const toast = document.createElement('div');
    toast.id = toastId;
    toast.className = `toast bg-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'info'} text-white`;
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'assertive');
    toast.setAttribute('aria-atomic', 'true');
    
    // Toast content
    toast.innerHTML = `
        <div class="toast-header bg-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'info'} text-white">
            <strong class="me-auto">${type === 'success' ? 'Success' : type === 'error' ? 'Error' : 'Information'}</strong>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
            ${message}
        </div>
    `;
    
    // Add to container
    toastContainer.appendChild(toast);
    
    // Initialize the toast
    const closeButton = toast.querySelector('.btn-close');
    closeButton.addEventListener('click', () => {
        toast.remove();
    });
    
    // Show the toast
    toast.classList.add('show');
    
    // Auto-close after 5 seconds
    setTimeout(() => {
        toast.remove();
    }, 5000);
    
    return toast;
}

// Article Selection Modal Functions
function openArticleSelectionModal() {
    console.log("Opening article selection modal");
    try {
        // First check if we need to restore the selected list from previous articles
        const selectedList = document.getElementById('selectedArticlesList');
        
        if (selectedList) {
            // Clear the current list
            selectedList.innerHTML = '<div class="text-center py-3 text-muted" id="noSelectedArticlesMsg">No articles selected</div>';
            
            // Try to restore previously selected articles from the button dataset
            const selectArticlesButton = document.getElementById('selectArticlesButton');
            if (selectArticlesButton && selectArticlesButton.dataset.selectedArticlesData) {
                try {
                    const articlesData = JSON.parse(selectArticlesButton.dataset.selectedArticlesData);
                    console.log(`Restoring ${articlesData.length} previously selected articles`);
                    
                    if (articlesData.length > 0) {
                        // Clear the "no articles" message
                        selectedList.innerHTML = '';
                        
                        // Manually add each article to the selection
                        articlesData.forEach(article => {
                            addArticleToSelection(article);
                        });
                    }
                } catch (e) {
                    console.error('Error restoring selected articles:', e);
                }
            } else {
                console.log('No previously selected articles found');
            }
        }
        
        // Show the article selection modal
        const modal = document.getElementById('articleSelectionModal');
        if (modal) {
            modal.classList.add('show');
            modal.style.display = 'block';
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            
            // Create backdrop if not already present
            if (!document.querySelector('.modal-backdrop')) {
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                document.body.appendChild(backdrop);
            }
            
            // Initialize filter dropdowns
            initializeArticleFilterDropdowns();
            
            // Set default date range (last 30 days)
            const currentDate = new Date();
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(currentDate.getDate() - 30);
            
            const startDateField = document.getElementById('articleSearchStartDate');
            const endDateField = document.getElementById('articleSearchEndDate');
            
            if (startDateField) {
                // Always set a valid date that's not in the future, regardless of previous value
                startDateField.value = thirtyDaysAgo.toISOString().split('T')[0];
            }
            if (endDateField) {
                // Always set to current date
                endDateField.value = currentDate.toISOString().split('T')[0];
            }
            
            // Also set the date range dropdown to 30 days to match
            const dateRangeSelect = document.getElementById('dateRange');
            if (dateRangeSelect) {
                dateRangeSelect.value = '30';
                
                // Make sure the custom date range is hidden
                const customDateRange = document.getElementById('customDateRange');
                if (customDateRange) {
                    customDateRange.style.display = 'none';
                }
            }
        }
    } catch (error) {
        console.error('Error opening article selection modal:', error);
        alert(`Error opening article selection: ${error.message}`);
    }
}

// Function to initialize article filter dropdowns
function initializeArticleFilterDropdowns() {
    console.log('Initializing article filter dropdowns');
    
    // Initialize topics dropdown if it's empty
    const topicSelect = document.getElementById('articleSearchTopic');
    if (topicSelect && topicSelect.options.length <= 1) {
        fetch('/api/topics')
            .then(response => {
                if (!response.ok) throw new Error('Failed to fetch topics');
                return response.json();
            })
            .then(topics => {
                console.log('Fetched topics:', topics);
                // Clear existing options except the first one
                while (topicSelect.options.length > 1) {
                    topicSelect.remove(1);
                }
                
                // Add new options
                topics.forEach(topic => {
                    const option = document.createElement('option');
                    // Handle both string and object formats
                    if (typeof topic === 'string') {
                        option.value = topic;
                        option.textContent = topic;
                    } else {
                        option.value = topic.name || topic.id || '';
                        option.textContent = topic.name || '';
                    }
                    topicSelect.appendChild(option);
                });
            })
            .catch(error => console.error('Error loading topics:', error));
    }
    
    // Initialize category dropdown
    initializeFilterDropdown('category', '/api/categories');
    
    // Initialize future signal dropdown
    initializeFilterDropdown('futureSignal', '/api/future_signals', 'future_signal');
    
    // Initialize sentiment dropdown
    initializeFilterDropdown('sentiment', '/api/sentiments');
}

// Helper function to initialize a filter dropdown
function initializeFilterDropdown(elementId, apiUrl, apiParam) {
    const select = document.getElementById(elementId);
    if (!select) {
        console.warn(`Element #${elementId} not found`);
        return;
    }
    
    // Skip if already has options
    if (select.options.length > 1) return;
    
    console.log(`Fetching options for ${elementId} from ${apiUrl}`);
    
    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`Failed to fetch ${elementId} data`);
            return response.json();
        })
        .then(data => {
            console.log(`Received ${data.length} options for ${elementId}`);
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add placeholder option
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = `Select ${apiParam || elementId}`;
            select.appendChild(placeholder);
            
            // Add options from API
            data.forEach(option => {
                const optElement = document.createElement('option');
                optElement.value = option;
                optElement.textContent = option;
                select.appendChild(optElement);
            });
            
            // Initialize Select2 if available
            if (window.jQuery && window.jQuery.fn.select2) {
                try {
                    $(select).select2({
                        placeholder: `Select ${apiParam || elementId}`,
                        allowClear: true,
                        width: '100%'
                    });
                } catch (error) {
                    console.warn(`Select2 initialization failed for ${elementId}:`, error);
                }
            }
        })
        .catch(error => console.error(`Error fetching ${elementId} options:`, error));
}

function closeArticleSelectionModal() {
    // Hide the article selection modal
    const modal = document.getElementById('articleSelectionModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
    }
    // Always remove modal-open class from body
    document.body.classList.remove('modal-open');
    // Always remove any modal-backdrop
    const backdrops = document.querySelectorAll('.modal-backdrop');
    backdrops.forEach(backdrop => backdrop.remove());
}

function saveArticleSelection() {
    // Don't close modal yet - we want to verify the data first
    
    console.log('Starting article selection save process...');
    
    // Show a loading overlay to indicate processing
    const loadingOverlay = document.createElement('div');
    loadingOverlay.className = 'position-fixed w-100 h-100 d-flex justify-content-center align-items-center';
    loadingOverlay.style = 'top: 0; left: 0; background: rgba(0,0,0,0.3); z-index: 9999;';
    loadingOverlay.innerHTML = `
        <div class="bg-white p-4 rounded shadow">
            <div class="text-center mb-3">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
            <div class="text-center">Processing articles...</div>
            <div class="text-center mt-2"><small id="processingInfo">Preparing data...</small></div>
        </div>
    `;
    document.body.appendChild(loadingOverlay);
    
    // Debug the selected articles list container
    const articlesList = document.getElementById('selectedArticlesList');
    console.log('Selected articles container found:', !!articlesList);
    if (articlesList) {
        console.log('Container HTML:', articlesList.innerHTML);
        console.log('Container children count:', articlesList.children.length);
    }
    
    // Much more flexible selection - use any items in the container that aren't the empty message
    const selectedArticles = Array.from(document.querySelectorAll('#selectedArticlesList > *')).filter(el => 
        !el.id || el.id !== 'noSelectedArticlesMsg');
    
    console.log('Processing articles, found:', selectedArticles.length);
    
    // Check if we have any articles to process
    if (selectedArticles.length === 0) {
        console.log('No articles found to process');
        document.body.removeChild(loadingOverlay);
        alert('Please select at least one article');
        return;
    }
    
    // Process articles in a non-blocking way
    setTimeout(() => {
        try {
            console.log('Beginning article data extraction...');
            const articlesData = [];
            const articleUris = [];
            
            // Improved data extraction - much more robust
            selectedArticles.forEach((articleEl, index) => {
                console.log(`Processing article element ${index+1}:`, articleEl.tagName, articleEl.className);
                
                // Debug the element contents
                console.log(`- HTML content: ${articleEl.innerHTML.substring(0, 100)}...`);
                
                // First look for data attributes which are most reliable
                let uri = '';
                let url = '';
                let title = '';
                let source = '';
                
                // Method 1: Check data attributes
                if (articleEl.dataset) {
                    console.log('- Checking data attributes:', Object.keys(articleEl.dataset).join(', '));
                    uri = articleEl.dataset.uri || '';
                    url = articleEl.dataset.url || uri || '';
                    title = articleEl.dataset.title || '';
                    source = articleEl.dataset.source || '';
                }
                
                // Method 2: Find elements by class
                if (!title || !source) {
                    console.log('- Looking for elements by class...');
                    // Try to find title by common classes or element types
                    const possibleTitleEl = 
                        articleEl.querySelector('.article-title, h6, h5, h4, h3, strong, b') ||
                        articleEl.querySelector('[class*="title"]');
                    
                    if (possibleTitleEl) {
                        title = possibleTitleEl.textContent.trim();
                        console.log(`- Found title by element: ${title}`);
                    }
                    
                    // Try to find source by common classes
                    const possibleSourceEl = 
                        articleEl.querySelector('.article-source, small, .text-muted, [class*="source"]');
                    
                    if (possibleSourceEl) {
                        source = possibleSourceEl.textContent.trim();
                        console.log(`- Found source by element: ${source}`);
                    }
                }
                
                // Method 3: Look for link elements for the URI
                if (!uri) {
                    const linkEl = articleEl.querySelector('a[href]');
                    if (linkEl) {
                        uri = linkEl.getAttribute('href');
                        url = uri;
                        console.log(`- Found URI from link: ${uri}`);
                    }
                }
                
                // Method 4: Try to parse from the raw text content as a last resort
                if (!title || !source || !uri) {
                    console.log('- Attempting to parse from text content...');
                    const lines = articleEl.textContent
                        .split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0);
                    
                    console.log(`- Found ${lines.length} text lines`);
                    
                    if (lines.length > 0 && !title) {
                        title = lines[0];
                        console.log(`- Extracted title from text: ${title}`);
                    }
                    
                    if (lines.length > 1 && !source) {
                        source = lines[1];
                        console.log(`- Extracted source from text: ${source}`);
                    }
                    
                    // Look for URL pattern in any line
                    if (!uri) {
                        for (const line of lines) {
                            if (line.includes('http') || line.includes('www.')) {
                                uri = line.trim();
                                url = uri;
                                console.log(`- Found URL in text: ${uri}`);
                                break;
                            }
                        }
                    }
                }
                
                // Clean up source if it contains "Source:" prefix
                if (source.startsWith('Source:')) {
                    source = source.substring('Source:'.length).trim();
                }
                
                // Clean up source if it contains date or other info
                if (source.includes('|')) {
                    source = source.split('|')[0].trim();
                }
                
                // Use fallbacks if we couldn't extract essential info
                if (!title) {
                    title = 'Untitled Article';
                    console.log('- Using fallback title');
                }
                
                if (!source) {
                    source = 'Unknown Source';
                    console.log('- Using fallback source');
                }
                
                // Generate URI if missing completely (this is crucial for API)
                if (!uri) {
                    console.log('- URI missing, generating fallback');
                    // Use a made-up unique URI based on the title and index
                    uri = `article-${index+1}-${Date.now()}`;
                }
                
                // Add this article to our data
                console.log(`- Adding article: "${title}" from ${source}`);
                articlesData.push({
                    title: title,
                    source: source,
                    uri: uri,
                    url: url || uri
                });
                articleUris.push(uri);
            });
            
            console.log(`Extracted ${articlesData.length} articles with data`);
            
            // Handle the case where no articles could be successfully extracted
            if (articlesData.length === 0) {
                console.error('No articles could be extracted despite seeing elements');
                document.body.removeChild(loadingOverlay);
                alert('Could not extract article data. Please try selecting articles again.');
                return;
            }
            
            // Update the count in the main view
            const countDisplay = document.getElementById('selectedArticlesCount');
            if (countDisplay) {
                countDisplay.textContent = `${articlesData.length} article${articlesData.length !== 1 ? 's' : ''} selected`;
                console.log('Updated count display');
            } else {
                console.warn('Selected articles count element not found');
            }
            
            // Enable checkbox for including articles
            const includeCheckbox = document.getElementById('includeArticles');
            if (includeCheckbox) {
                includeCheckbox.checked = true;
                console.log('Enabled include articles checkbox');
            } else {
                console.warn('Include articles checkbox not found');
            }
            
            // Store selected articles for later use in the GENERATE process - only store URIs
            const selectArticlesButton = document.getElementById('selectArticlesButton');
            if (selectArticlesButton) {
                // Store both URIs and full data for the API
                selectArticlesButton.dataset.selectedArticles = JSON.stringify(articleUris);
                selectArticlesButton.dataset.selectedArticlesData = JSON.stringify(articlesData);
                console.log('Stored article data in button data attributes:', articleUris.length);
            } else {
                console.warn('Select articles button not found');
            }
            
            // Create a backup in localStorage in case the dataset gets lost
            try {
                localStorage.setItem('selected_articles_backup', JSON.stringify({
                    uris: articleUris,
                    data: articlesData
                }));
                console.log('Saved article backup to localStorage');
            } catch (e) {
                console.warn('Failed to backup articles to localStorage:', e);
            }
            
            // Remove the loading overlay
            document.body.removeChild(loadingOverlay);
            
            // Now close the modal
            closeArticleSelectionModal();
            
            // Show confirmation message instead of immediately adding to newsletter
            if (articlesData.length > 0) {
                const message = ` ${articlesData.length} article${articlesData.length !== 1 ? 's' : ''} selected for the newsletter. Use the GENERATE button to include them.`;
                // Show a non-intrusive toast/alert
                showToast(message, 'success');
                console.log('Showed success toast');
            }
            
        } catch (error) {
            console.error('Error processing articles:', error);
            document.body.removeChild(loadingOverlay);
            alert('An error occurred while processing articles. Please try again.');
        }
    }, 10); // Very short delay to allow UI update
}

// Note: Article selection event handlers are now setup in the main DOMContentLoaded listener

// Function to load topics for article search dropdown
async function loadTopicsForArticleSearch() {
    try {
        const topicSelect = document.getElementById('articleSearchTopic');
        if (!topicSelect) return;
        
        // Clear existing options except the first one (All Topics)
        const firstOption = topicSelect.options[0];
        topicSelect.innerHTML = '';
        topicSelect.appendChild(firstOption);
        
        // Fetch topics from API
        const response = await fetch('/api/newsletter/topics');
        
        if (!response.ok) {
            throw new Error(`Failed to load topics: ${response.status}`);
        }
        
        const topics = await response.json();
        
        // Add topic options
        topics.forEach(topic => {
            const option = document.createElement('option');
            option.value = topic;
            option.textContent = topic;
            topicSelect.appendChild(option);
        });
        
    } catch (error) {
        console.error('Error loading topics for article search:', error);
    }
}

// Function to search for articles
async function searchArticles() {
    try {
        const container = document.getElementById('articleListContainer');
        if (!container) return;
        
        // Show initial loading state
        container.innerHTML = '<div class="text-center py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Searching articles...</div>';
        
        // Get form data from the search form
        const formData = new FormData(document.getElementById('articleSearchForm'));
        const searchParams = new URLSearchParams(formData);
        
        // Get search parameters for display
        const query = document.getElementById('articleSearchQuery').value;
        const topic = document.getElementById('articleSearchTopic').value;
        
        // Handle date range parameters
        const dateRangeSelect = document.getElementById('dateRange');
        let startDate, endDate;
        
        // Get current date for calculations
        const currentDate = new Date();
        endDate = currentDate.toISOString().split('T')[0];
        
        if (dateRangeSelect && dateRangeSelect.value === 'custom') {
            // Use custom date range if selected
            startDate = document.getElementById('articleSearchStartDate').value;
            endDate = document.getElementById('articleSearchEndDate').value;
            
            // Validate the dates to ensure they're not in the future
            const startDateObj = new Date(startDate);
            const endDateObj = new Date(endDate);
            const todayObj = new Date(currentDate.toISOString().split('T')[0]); // Just the date part
            
            if (startDateObj > todayObj) {
                console.warn('Start date is in the future, using today instead');
                startDate = currentDate.toISOString().split('T')[0];
            }
            if (endDateObj > todayObj) {
                console.warn('End date is in the future, using today instead');
                endDate = currentDate.toISOString().split('T')[0]; 
            }
        } else if (dateRangeSelect) {
            // Otherwise calculate based on selected range
            if (dateRangeSelect.value === '7') {
                const date = new Date(currentDate);
                date.setDate(date.getDate() - 7);
                startDate = date.toISOString().split('T')[0];
            } else if (dateRangeSelect.value === '30') {
                const date = new Date(currentDate);
                date.setDate(date.getDate() - 30);
                startDate = date.toISOString().split('T')[0];
            } else if (dateRangeSelect.value === '90') {
                const date = new Date(currentDate);
                date.setDate(date.getDate() - 90);
                startDate = date.toISOString().split('T')[0];
            } else if (dateRangeSelect.value === '365') {
                const date = new Date(currentDate);
                date.setFullYear(date.getFullYear() - 1);
                startDate = date.toISOString().split('T')[0];
            } else {
                // For "all time" option or default - use a generous past date
                const date = new Date(currentDate);
                date.setFullYear(date.getFullYear() - 10);
                startDate = date.toISOString().split('T')[0];
            }
        }
        
        // Update the search params with date range
        if (startDate) searchParams.set('start_date', startDate);
        if (endDate) searchParams.set('end_date', endDate);
        
        // Remove date_range from params as API doesn't use it
        searchParams.delete('dateRange');
        
        // Set date type to publication by default
        searchParams.append('date_type', 'publication');
        
        // Handle topic parameter - the API uses keyword parameter
        if (topic && !searchParams.has('keyword')) {
            searchParams.set('keyword', query || '');
            if (topic) searchParams.set('topic', topic);
        }
        
        // Add pagination and result limits
        searchParams.set('page', '1');
        searchParams.set('per_page', '20');
        
        // Request necessary fields
        searchParams.set('include_fields', 'title,summary,url,uri,publication_date,category,sentiment,news_source,future_signal');
        
        // Validate date parameters - fix future dates
        const now = new Date();
        const todayStr = now.toISOString().split('T')[0];
        
        // Log date validation
        console.log(`Validating dates: startDate=${startDate}, endDate=${endDate}, today=${todayStr}`);
        
        // Check if dates are in the future and fix them
        try {
            if (startDate && new Date(startDate) > now) {
                console.warn(`Start date ${startDate} is in the future, adjusting to 30 days before today`);
                const thirtyDaysAgo = new Date(now);
                thirtyDaysAgo.setDate(now.getDate() - 30);
                startDate = thirtyDaysAgo.toISOString().split('T')[0];
                searchParams.set('start_date', startDate);
            }
            
            if (endDate && new Date(endDate) > now) {
                console.warn(`End date ${endDate} is in the future, adjusting to today`);
                endDate = todayStr;
                searchParams.set('end_date', endDate);
            }
        } catch (dateError) {
            console.error('Date validation error:', dateError);
            // Use safe defaults
            const thirtyDaysAgo = new Date(now);
            thirtyDaysAgo.setDate(now.getDate() - 30);
            startDate = thirtyDaysAgo.toISOString().split('T')[0];
            endDate = todayStr;
            searchParams.set('start_date', startDate);
            searchParams.set('end_date', endDate);
        }
        
        // Show search parameters to the user
        container.innerHTML = `<div class="text-center py-3"><i class="fa fa-spinner fa-spin mr-2"></i> Searching articles...</div>
                              <div class="small text-muted text-center">Query: "${query || 'Any'}", Topic: "${topic || 'Any'}", Date range: ${startDate} to ${endDate}</div>`;
        
        console.log(`Searching articles with params: ${searchParams.toString()}`);
        
        // Use the same endpoint as report.html
        const response = await fetch(`/api/search_articles?${searchParams.toString()}`);
        
                if (!response.ok) {
            const errorText = await response.text();
            console.error(`Search error (${response.status}): ${errorText}`);
            throw new Error(`Failed to search articles: ${response.status} - ${errorText || 'Unknown error'}`);
        }

        const data = await response.json();
        console.log('Received search results:', data);
        
        // Clear container
        container.innerHTML = '';
        
        // Check if we have the expected data format
        const articles = data.articles || data;
        const totalCount = data.total_count || (Array.isArray(articles) ? articles.length : 0);
        
        // Update article count display
        const countElement = document.getElementById('selectedArticlesCount');
        if (countElement) {
            countElement.textContent = `${totalCount} articles found`;
        }
        
        if (!articles || articles.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No articles found matching your criteria</div>';
            return;
        }
        
        // Preprocess articles to ensure all required fields
        const processedArticles = articles.map(article => {
            return {
                ...article,
                // Ensure important fields exist
                title: article.title || 'Untitled',
                summary: article.summary || 'No summary available',
                news_source: article.news_source || 'Unknown Source',
                url: article.url || article.uri || '#',
                uri: article.uri || article.url || '#',
                // Ensure dates are properly formatted
                publication_date: article.publication_date || 'Unknown date',
                sentiment: article.sentiment || 'Neutral',
                future_signal: article.future_signal || null
            };
        });
        
        // Create list items for each article
        processedArticles.forEach(article => {
            const item = document.createElement('div');
            item.className = 'article-item';
            item.dataset.uri = article.uri || '';
            item.dataset.articleId = article.id;
            
            // Create article content
            const title = document.createElement('h5');
            title.className = 'article-title mb-1';
            title.textContent = article.title;
            
            const details = document.createElement('div');
            details.className = 'article-source small text-muted mb-2';
            
            // Format publication date
            let pubDate = article.publication_date;
            if (pubDate && pubDate !== 'Unknown date' && !pubDate.startsWith('Unknown')) {
                try {
                    // Try to format date if it's an ISO string
                    if (typeof pubDate === 'string' && pubDate.includes('T')) {
                        // This is likely an ISO date string
                        pubDate = new Date(pubDate).toLocaleDateString();
                    } else if (typeof pubDate === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(pubDate)) {
                        // This is a YYYY-MM-DD date string
                        pubDate = new Date(pubDate).toLocaleDateString();
                    }
                } catch (e) {
                    console.log('Date parsing error:', e);
                    // Keep as is if not parseable
                }
            } else {
                // If we have no valid date, use current date 
                pubDate = new Date().toLocaleDateString() + ' (estimated)';
            }
            
            // Add source and date
            details.textContent = `Source: ${article.news_source} | Published: ${pubDate}`;
            
            // Create container for article metadata/tags
            const metadataContainer = document.createElement('div');
            metadataContainer.className = 'd-flex flex-wrap gap-2 mb-2';
            
            // Add category if available
            if (article.category) {
                const categoryBadge = document.createElement('span');
                categoryBadge.className = 'badge bg-info me-1';
                categoryBadge.innerHTML = `<i class="fa fa-folder"></i> ${article.category}`;
                metadataContainer.appendChild(categoryBadge);
            }
            
            // Add sentiment if available
            if (article.sentiment) {
                const sentimentClass = getSentimentClass(article.sentiment);
                const sentimentBadge = document.createElement('span');
                sentimentBadge.className = `badge ${sentimentClass} me-1`;
                sentimentBadge.innerHTML = `<i class="fa fa-heart"></i> ${article.sentiment}`;
                metadataContainer.appendChild(sentimentBadge);
            }
            
            // Add future signal if available
            if (article.future_signal) {
                const signalBadge = document.createElement('span');
                signalBadge.className = 'badge bg-warning me-1';
                signalBadge.innerHTML = `<i class="fa fa-compass"></i> ${article.future_signal}`;
                metadataContainer.appendChild(signalBadge);
            }
            
            // Add bias if available
            if (article.bias) {
                const biasBadge = document.createElement('span');
                biasBadge.className = 'badge bg-secondary me-1';
                biasBadge.innerHTML = `<i class="fa fa-balance-scale"></i> ${article.bias}`;
                metadataContainer.appendChild(biasBadge);
            }
            
            // Add factual reporting if available
            if (article.factual_reporting) {
                const factualBadge = document.createElement('span');
                factualBadge.className = 'badge bg-dark me-1';
                factualBadge.innerHTML = `<i class="fa fa-check-circle"></i> ${article.factual_reporting}`;
                metadataContainer.appendChild(factualBadge);
            }
            
            // Add summary if available
            const summary = document.createElement('p');
            summary.className = 'article-summary mb-2';
            summary.textContent = article.summary;
            
            // Create button container for actions
            const btnContainer = document.createElement('div');
            btnContainer.className = 'd-flex justify-content-between mt-2';
            
            // Add URI if available
            const uri = document.createElement('a');
            uri.href = article.url || article.uri || '#';
            uri.className = 'btn btn-sm btn-outline-secondary';
            uri.innerHTML = '<i class="fa fa-external-link"></i> View Source';
            uri.target = '_blank';
            
                            // Add button to select this article
                const selectBtn = document.createElement('button');
                selectBtn.type = 'button';
                selectBtn.className = 'btn btn-sm btn-primary add-article-btn';
                selectBtn.innerHTML = '<i class="fa fa-plus"></i> Add to Selection';
                
                // Add click event to capture all article data directly from the source
                selectBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Capture all article data to ensure nothing is lost
                    addArticleToSelection({
                        title: article.title,
                        uri: article.uri,
                        url: article.url || article.uri,
                        news_source: article.news_source,
                        publication_date: pubDate, // Use the formatted date
                        summary: article.summary
                    });
                });
                
                // Add buttons to container
                btnContainer.appendChild(uri);
                btnContainer.appendChild(selectBtn);
                
                // Assemble the item
                item.appendChild(title);
                item.appendChild(details);
                item.appendChild(metadataContainer);
                item.appendChild(summary);
                item.appendChild(btnContainer);
            
            container.appendChild(item);
        });
        
        // Add pagination controls
        if (totalCount > processedArticles.length) {
            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'pagination-container text-center mt-3';
            
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.className = 'btn btn-outline-primary';
            loadMoreBtn.innerHTML = '<i class="fa fa-refresh"></i> Load More Results';
            loadMoreBtn.addEventListener('click', () => {
                // Load next page of results
                loadMoreArticles(searchParams, 2); // Start with page 2
            });
            
            paginationContainer.appendChild(loadMoreBtn);
            container.appendChild(paginationContainer);
            
            // Store the search params for pagination
            container.dataset.searchParams = searchParams.toString();
            container.dataset.currentPage = '1';
            container.dataset.totalCount = totalCount;
        }
        
    } catch (error) {
        console.error('Error searching articles:', error);
        const container = document.getElementById('articleListContainer');
        if (container) {
            container.innerHTML = `<div class="text-center text-danger py-3">Error searching articles: ${error.message}</div>`;
        }
    }
}

// Function to add an article to the selection
function addArticleToSelection(article) {
    const container = document.getElementById('selectedArticlesList');
    if (!container) return;
    
    console.log('Adding article to selection:', article);
    
    // Extract publication date with smarter handling
    let pubDate = article.publication_date || 'Unknown date';
    if (pubDate && pubDate !== 'Unknown date' && !pubDate.startsWith('Unknown')) {
        try {
            // Try to format date if it's an ISO string
            if (typeof pubDate === 'string' && pubDate.includes('T')) {
                pubDate = new Date(pubDate).toLocaleDateString();
            } else if (typeof pubDate === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(pubDate)) {
                pubDate = new Date(pubDate).toLocaleDateString();
            }
        } catch (e) {
            console.log('Article date parsing error:', e);
            pubDate = new Date().toLocaleDateString() + ' (estimated)';
        }
    } else {
        pubDate = new Date().toLocaleDateString() + ' (estimated)';
    }
    
    // Normalize article data to ensure all required fields
    const articleData = {
        uri: article.uri || article.url || '#',
        url: article.url || article.uri || '#',
        title: article.title || 'Untitled Article',
        news_source: article.news_source || 'Unknown Source',
        id: article.id || article.uri || Date.now().toString(),
        publication_date: pubDate,
        summary: article.summary || 'No summary available'
    };
    
    // Check if article is already in the selection
    const existingItem = container.querySelector(`div[data-uri="${articleData.uri}"]`);
    if (existingItem) {
        // Highlight briefly to show it's already selected
        existingItem.classList.add('bg-warning');
        setTimeout(() => existingItem.classList.remove('bg-warning'), 1000);
        return;
    }
    
    // Remove placeholder message if it exists
    const noSelectedMsg = document.getElementById('noSelectedArticlesMsg');
    if (noSelectedMsg) noSelectedMsg.remove();
    
    // Create a list item for the selected article
    const item = document.createElement('div');
    item.className = 'list-group-item d-flex justify-content-between align-items-center';
    item.dataset.uri = articleData.uri;
    item.dataset.articleId = articleData.id;
    
    // Store all article data as data attributes to prevent information loss
    item.dataset.title = articleData.title;
    item.dataset.source = articleData.news_source;
    item.dataset.date = articleData.publication_date;
    item.dataset.url = articleData.url;
    
    // Create article details with improved formatting
    const details = document.createElement('div');
    details.className = 'article-details'; // Add class for styling
    
    // Add title (strong element)
    const title = document.createElement('strong');
    title.className = 'article-title';
    title.textContent = articleData.title;
    
    // Show publication date separately from source to make it stand out better
    const meta = document.createElement('div');
    meta.className = 'd-block text-muted';
    
    // First line: Source 
    const source = document.createElement('small');
    source.className = 'd-block';
    source.textContent = `Source: ${articleData.news_source}`;
    meta.appendChild(source);
    
    // Second line: Date
    const date = document.createElement('small');
    date.className = 'd-block';
    date.textContent = `Date: ${articleData.publication_date}`;
    meta.appendChild(date);
    
    // Add URL (anchor element)
    const link = document.createElement('a');
    link.href = articleData.url;
    link.className = 'd-block small text-truncate';
    link.textContent = articleData.url;
    link.title = articleData.url; // Add title attribute for hover tooltip
    link.target = '_blank';
    
    // Build proper DOM structure
    details.appendChild(title);
    details.appendChild(meta); // meta contains both source and date
    details.appendChild(link);
    
    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-sm btn-outline-danger';
    removeBtn.innerHTML = '<i class="fa fa-times"></i>';
    removeBtn.addEventListener('click', () => {
        item.remove();
        updateSelectedArticlesCount();
    });
    
    item.appendChild(details);
    item.appendChild(removeBtn);
    
    container.appendChild(item);
    
    // Update the count
    updateSelectedArticlesCount();
}

// Function to update the selected articles count
function updateSelectedArticlesCount() {
    const container = document.getElementById('selectedArticlesList');
    const countEl = document.getElementById('selectedArticlesCount');
    
    if (container && countEl) {
        const count = container.querySelectorAll('.list-group-item').length;
        countEl.textContent = count;
    }
}

// Function to update the template preview
function updateTemplatePreview(templateType) {
    const previewElement = document.getElementById('templatePreview');
    if (!previewElement) return;
    
    // Show template description with preview example
    switch (templateType) {
        case 'simple':
            previewElement.innerHTML = `
                <strong>Simple List</strong>: Lists articles with title, source and link<br>
                <span class="small text-muted">Example:</span><br>
                <strong>Article Title</strong><br>
                <span class="text-muted">Source | Date</span>
            `;
            break;
        case 'detailed':
            previewElement.innerHTML = `
                <strong>Detailed with Summary</strong>: Includes article summary and additional metadata<br>
                <span class="small text-muted">Example:</span><br>
                <strong>Article Title</strong><br>
                <span>Source: Example News</span><br>
                <span>URL: https://example.com/article</span><br>
                <span class="text-muted">Summary text will appear here...</span>
            `;
            break;
        case 'minimal':
            previewElement.innerHTML = `
                <strong>Title Only</strong>: Just article titles with links<br>
                <span class="small text-muted">Example:</span><br>
                <ul class="mb-0 ps-3">
                    <li>Article Title One</li>
                    <li>Article Title Two</li>
                </ul>
            `;
            break;
        case 'detailed_metadata':
            previewElement.innerHTML = `
                <strong>Detailed with Metadata</strong>: Includes article summary, metadata, and additional details<br>
                <span class="small text-muted">Example:</span><br>
                <strong>Article Title</strong><br>
                <span>Source: Example News</span><br>
                <span>URL: https://example.com/article</span><br>
                <span class="text-muted">Summary text will appear here...</span>
            `;
            break;
        default:
            previewElement.innerHTML = 'Select a template format';
    }
}

// Function to show the template output preview based on selected articles
function previewArticleTemplate() {
    const outputPreview = document.getElementById('templateOutputPreview');
    if (!outputPreview) return;
    
    // Get all possible selected article elements - check both class names
    const selectedArticles = document.querySelectorAll('#selectedArticlesList .list-group-item, #selectedArticlesList .article-item, #selectedArticlesList div[data-uri]');
    console.log('Selected articles found:', selectedArticles.length);
    
    if (selectedArticles.length === 0) {
        outputPreview.innerHTML = '<p class="text-warning">Please select at least one article to preview.</p>';
        return;
    }
    
    // Get the template type
    const templateType = document.getElementById('articleTemplate').value;
    
    // Generate the preview based on the template type
    let previewContent = '';
    
    // Add a sample heading
    previewContent += '<div class="mb-3"><strong class="text-primary">PREVIEW:</strong></div>';
    
    // Collect valid articles with all required elements - use direct dataset properties if elements are missing
    const validArticles = [];
    selectedArticles.forEach(articleEl => {
        let title, source, link;
        
        // Method 1: Try to extract from HTML elements
        const titleEl = articleEl.querySelector('strong');
        const sourceEl = articleEl.querySelector('small');
        const linkEl = articleEl.querySelector('a');
        
        // Method 2: Try to extract from textContent if elements not found
        if (!titleEl || !sourceEl) {
            console.log('Preview - trying alternative extraction for:', articleEl);
            
            // Get the full text content and try to parse it
            const fullText = articleEl.textContent.trim();
            const lines = fullText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            if (lines.length > 0) {
                // First non-empty line is title
                title = lines[0];
                
                // Second line often contains source and date info
                if (lines.length > 1) {
                    source = lines[1];
                    
                    // Try to extract source from the line
                    if (source.includes('|')) {
                        source = source.split('|')[0].trim();
                    }
                }
            }
            
            // Get link from dataset or any available anchor
            if (articleEl.dataset.uri) {
                link = articleEl.dataset.uri;
            } else if (linkEl) {
                link = linkEl.getAttribute('href');
            } else {
                link = '#';
            }
        } else {
            // Use the found elements
            title = titleEl.textContent;
            source = sourceEl.textContent;
            link = linkEl ? linkEl.getAttribute('href') : (articleEl.dataset.uri || '#');
        }
        
        // Only add if we have a title
        if (title) {
            validArticles.push({
                element: articleEl,
                title: title,
                source: source || 'Source not available',
                link: link || '#'
            });
            console.log('Preview - added article:', title);
        } else {
            console.warn('Preview - skipping article with no extractable title:', articleEl);
        }
    });
    
    if (validArticles.length === 0) {
        outputPreview.innerHTML = '<p class="text-warning">No valid articles found in your selection. Each article must have a title and source.</p>';
        return;
    }
    
    // Generate content based on the selected template
    switch (templateType) {
        case 'simple':
            previewContent += '<h4>Key Articles</h4>';
            validArticles.forEach(article => {
                previewContent += `<p><strong>${article.title}</strong><br>`;
                previewContent += `<span class="text-muted">${article.source}</span></p>`;
            });
            break;
            
        case 'detailed':
            previewContent += '<h4>Key Articles</h4>';
            validArticles.forEach(article => {
                previewContent += `<div class="mb-3">`;
                previewContent += `<h5>${article.title}</h5>`;
                previewContent += `<p><strong>Source:</strong> ${article.source}</p>`;
                previewContent += `<p><a href="${article.link}" target="_blank">${article.link}</a></p>`;
                previewContent += `<p>This article discusses important developments in the field...</p>`;
                previewContent += `</div>`;
            });
            break;
            
        case 'minimal':
            previewContent += '<h4>Referenced Articles</h4>';
            previewContent += '<ul>';
            validArticles.forEach(article => {
                previewContent += `<li>${article.title}</li>`;
            });
            previewContent += '</ul>';
            break;
            
        case 'detailed_metadata':
            previewContent += '<h4>Key Articles</h4>';
            validArticles.forEach(article => {
                previewContent += `<div class="mb-3">`;
                previewContent += `<h5>${article.title}</h5>`;
                previewContent += `<p><strong>Source:</strong> ${article.source}</p>`;
                previewContent += `<p><a href="${article.link}" target="_blank">${article.link}</a></p>`;
                previewContent += `<p>This article discusses important developments in the field...</p>`;
                previewContent += `<p><strong>Sentiment:</strong> ${getSentimentClass(article.sentiment)}</p>`;
                previewContent += `<p><strong>Time to Impact:</strong> [Time to Impact]</p>`;
                previewContent += `<p><strong>Future Signal:</strong> ${article.future_signal}</p>`;
                previewContent += `</div>`;
            });
            break;
            
        default:
            previewContent = '<p>Unknown template format selected.</p>';
    }
    
    // Update the preview element
    outputPreview.innerHTML = previewContent;
}

// Initialize the preview button event listener
document.addEventListener('DOMContentLoaded', function() {
    const previewBtn = document.getElementById('previewTemplateBtn');
    if (previewBtn) {
        previewBtn.addEventListener('click', previewArticleTemplate);
    }
    
    // Also update preview when template changes
    const templateSelect = document.getElementById('articleTemplate');
    if (templateSelect) {
        templateSelect.addEventListener('change', function() {
            updateTemplatePreview(this.value);
        });
    }
});

// Helper function to get values from multi-select dropdowns
function getMultiSelectValues(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return [];
    
    // Handle both regular <select multiple> and Select2 cases
    if (window.jQuery && $(element).data('select2')) {
        return $(element).val() || [];
    } else {
        return Array.from(element.selectedOptions).map(option => option.value);
    }
}

// Helper function to get the appropriate badge class for sentiment
function getSentimentClass(sentiment) {
    if (!sentiment) return 'bg-secondary';
    
    sentiment = sentiment.toLowerCase();
    
    if (sentiment.includes('positive')) {
        return 'bg-success';
    } else if (sentiment.includes('negative')) {
        return 'bg-danger';
    } else if (sentiment.includes('neutral')) {
        return 'bg-info';
    } else if (sentiment.includes('mixed')) {
        return 'bg-warning';
    }
    
    return 'bg-secondary';
}

// Function to add the selected articles to the editor
function saveArticleSelection() {
    // Don't close modal yet - we want to verify the data first
    
    console.log('Starting article selection save process...');
    
    // Show a loading overlay to indicate processing
    const loadingOverlay = document.createElement('div');
    loadingOverlay.className = 'position-fixed w-100 h-100 d-flex justify-content-center align-items-center';
    loadingOverlay.style = 'top: 0; left: 0; background: rgba(0,0,0,0.3); z-index: 9999;';
    loadingOverlay.innerHTML = `
        <div class="bg-white p-4 rounded shadow">
            <div class="text-center mb-3">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
            <div class="text-center">Processing articles...</div>
            <div class="text-center mt-2"><small id="processingInfo">Preparing data...</small></div>
        </div>
    `;
    document.body.appendChild(loadingOverlay);
    
    // Debug the selected articles list container
    const articlesList = document.getElementById('selectedArticlesList');
    console.log('Selected articles container found:', !!articlesList);
    if (articlesList) {
        console.log('Container HTML:', articlesList.innerHTML);
        console.log('Container children count:', articlesList.children.length);
    }
    
    // Much more flexible selection - use any items in the container that aren't the empty message
    const selectedArticles = Array.from(document.querySelectorAll('#selectedArticlesList > *')).filter(el => 
        !el.id || el.id !== 'noSelectedArticlesMsg');
    
    console.log('Processing articles, found:', selectedArticles.length);
    
    // Check if we have any articles to process
    if (selectedArticles.length === 0) {
        console.log('No articles found to process');
        document.body.removeChild(loadingOverlay);
        alert('Please select at least one article');
        return;
    }
    
    // Process articles in a non-blocking way
    setTimeout(() => {
        try {
            console.log('Beginning article data extraction...');
            const articlesData = [];
            const articleUris = [];
            
            // Improved data extraction - much more robust
            selectedArticles.forEach((articleEl, index) => {
                console.log(`Processing article element ${index+1}:`, articleEl.tagName, articleEl.className);
                
                // Debug the element contents
                console.log(`- HTML content: ${articleEl.innerHTML.substring(0, 100)}...`);
                
                // First look for data attributes which are most reliable
                let uri = '';
                let url = '';
                let title = '';
                let source = '';
                
                // Method 1: Check data attributes
                if (articleEl.dataset) {
                    console.log('- Checking data attributes:', Object.keys(articleEl.dataset).join(', '));
                    uri = articleEl.dataset.uri || '';
                    url = articleEl.dataset.url || uri || '';
                    title = articleEl.dataset.title || '';
                    source = articleEl.dataset.source || '';
                }
                
                // Method 2: Find elements by class
                if (!title || !source) {
                    console.log('- Looking for elements by class...');
                    // Try to find title by common classes or element types
                    const possibleTitleEl = 
                        articleEl.querySelector('.article-title, h6, h5, h4, h3, strong, b') ||
                        articleEl.querySelector('[class*="title"]');
                    
                    if (possibleTitleEl) {
                        title = possibleTitleEl.textContent.trim();
                        console.log(`- Found title by element: ${title}`);
                    }
                    
                    // Try to find source by common classes
                    const possibleSourceEl = 
                        articleEl.querySelector('.article-source, small, .text-muted, [class*="source"]');
                    
                    if (possibleSourceEl) {
                        source = possibleSourceEl.textContent.trim();
                        console.log(`- Found source by element: ${source}`);
                    }
                }
                
                // Method 3: Look for link elements for the URI
                if (!uri) {
                    const linkEl = articleEl.querySelector('a[href]');
                    if (linkEl) {
                        uri = linkEl.getAttribute('href');
                        url = uri;
                        console.log(`- Found URI from link: ${uri}`);
                    }
                }
                
                // Method 4: Try to parse from the raw text content as a last resort
                if (!title || !source || !uri) {
                    console.log('- Attempting to parse from text content...');
                    const lines = articleEl.textContent
                        .split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0);
                    
                    console.log(`- Found ${lines.length} text lines`);
                    
                    if (lines.length > 0 && !title) {
                        title = lines[0];
                        console.log(`- Extracted title from text: ${title}`);
                    }
                    
                    if (lines.length > 1 && !source) {
                        source = lines[1];
                        console.log(`- Extracted source from text: ${source}`);
                    }
                    
                    // Look for URL pattern in any line
                    if (!uri) {
                        for (const line of lines) {
                            if (line.includes('http') || line.includes('www.')) {
                                uri = line.trim();
                                url = uri;
                                console.log(`- Found URL in text: ${uri}`);
                                break;
                            }
                        }
                    }
                }
                
                // Clean up source if it contains "Source:" prefix
                if (source.startsWith('Source:')) {
                    source = source.substring('Source:'.length).trim();
                }
                
                // Clean up source if it contains date or other info
                if (source.includes('|')) {
                    source = source.split('|')[0].trim();
                }
                
                // Use fallbacks if we couldn't extract essential info
                if (!title) {
                    title = 'Untitled Article';
                    console.log('- Using fallback title');
                }
                
                if (!source) {
                    source = 'Unknown Source';
                    console.log('- Using fallback source');
                }
                
                // Generate URI if missing completely (this is crucial for API)
                if (!uri) {
                    console.log('- URI missing, generating fallback');
                    // Use a made-up unique URI based on the title and index
                    uri = `article-${index+1}-${Date.now()}`;
                }
                
                // Add this article to our data
                console.log(`- Adding article: "${title}" from ${source}`);
                articlesData.push({
                    title: title,
                    source: source,
                    uri: uri,
                    url: url || uri
                });
                articleUris.push(uri);
            });
            
            console.log(`Extracted ${articlesData.length} articles with data`);
            
            // Handle the case where no articles could be successfully extracted
            if (articlesData.length === 0) {
                console.error('No articles could be extracted despite seeing elements');
                document.body.removeChild(loadingOverlay);
                alert('Could not extract article data. Please try selecting articles again.');
                return;
            }
            
            // Update the count in the main view
            const countDisplay = document.getElementById('selectedArticlesCount');
            if (countDisplay) {
                countDisplay.textContent = `${articlesData.length} article${articlesData.length !== 1 ? 's' : ''} selected`;
                console.log('Updated count display');
            } else {
                console.warn('Selected articles count element not found');
            }
            
            // Enable checkbox for including articles
            const includeCheckbox = document.getElementById('includeArticles');
            if (includeCheckbox) {
                includeCheckbox.checked = true;
                console.log('Enabled include articles checkbox');
            } else {
                console.warn('Include articles checkbox not found');
            }
            
            // Store selected articles for later use in the GENERATE process - only store URIs
            const selectArticlesButton = document.getElementById('selectArticlesButton');
            if (selectArticlesButton) {
                // Store both URIs and full data for the API
                selectArticlesButton.dataset.selectedArticles = JSON.stringify(articleUris);
                selectArticlesButton.dataset.selectedArticlesData = JSON.stringify(articlesData);
                console.log('Stored article data in button data attributes:', articleUris.length);
            } else {
                console.warn('Select articles button not found');
            }
            
            // Create a backup in localStorage in case the dataset gets lost
            try {
                localStorage.setItem('selected_articles_backup', JSON.stringify({
                    uris: articleUris,
                    data: articlesData
                }));
                console.log('Saved article backup to localStorage');
            } catch (e) {
                console.warn('Failed to backup articles to localStorage:', e);
            }
            
            // Remove the loading overlay
            document.body.removeChild(loadingOverlay);
            
            // Now close the modal
            closeArticleSelectionModal();
            
            // Show confirmation message instead of immediately adding to newsletter
            if (articlesData.length > 0) {
                const message = ` ${articlesData.length} article${articlesData.length !== 1 ? 's' : ''} selected for the newsletter. Use the GENERATE button to include them.`;
                // Show a non-intrusive toast/alert
                showToast(message, 'success');
                console.log('Showed success toast');
            }
            
        } catch (error) {
            console.error('Error processing articles:', error);
            document.body.removeChild(loadingOverlay);
            alert('An error occurred while processing articles. Please try again.');
        }
    }, 10); // Very short delay to allow UI update
}

// Helper function to show a toast notification
function showToast(message, type = 'info') {
    // Create toast container if it doesn't exist
    let toastContainer = document.getElementById('toast-container');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        toastContainer.style.position = 'fixed';
        toastContainer.style.top = '1rem';
        toastContainer.style.right = '1rem';
        toastContainer.style.zIndex = '1050';
        toastContainer.style.width = '350px';
        document.body.appendChild(toastContainer);
    }
    
    // Create the toast element
    const toast = document.createElement('div');
    toast.className = `alert alert-${type} alert-dismissible fade show`;
    toast.role = 'alert';
    toast.style.marginBottom = '0.5rem';
    toast.style.boxShadow = '0 0.25rem 0.75rem rgba(0, 0, 0, 0.1)';
    toast.innerHTML = `
        <div>${message}</div>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    
    // Add to container
    toastContainer.appendChild(toast);
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 150);
    }, 5000);
    
    // Add click handler for close button
    toast.querySelector('.btn-close').addEventListener('click', () => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 150);
    });
}

// This function is no longer used - replaced with a simpler implementation
// in the saveArticleSelection function that doesn't require async/await
function processArticlesAsync() {
    console.log('This function is deprecated. Using optimized implementation instead.');
    return Promise.resolve(true);
}

// Helper function to format dates for input fields (YYYY-MM-DD)
function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Function to set date range to the last 24 hours
function setDayRange() {
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    if (startDateInput && endDateInput) {
        startDateInput.value = formatDateForInput(yesterday);
        endDateInput.value = formatDateForInput(today);
        
        // Update button styles
        setActiveDateRangeButton('dayRangeBtn');
        
        // Trigger save state
        saveNewsletterState();
    }
}

// Function to set date range to the last 7 days
function setWeekRange() {
    const today = new Date();
    const lastWeek = new Date(today);
    lastWeek.setDate(lastWeek.getDate() - 7);
    
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    if (startDateInput && endDateInput) {
        startDateInput.value = formatDateForInput(lastWeek);
        endDateInput.value = formatDateForInput(today);
        
        // Update button styles
        setActiveDateRangeButton('weekRangeBtn');
        
        // Trigger save state
        saveNewsletterState();
    }
}

// Function to set date range to the last 30 days
function setMonthRange() {
    const today = new Date();
    const lastMonth = new Date(today);
    lastMonth.setDate(lastMonth.getDate() - 30);
    
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    
    if (startDateInput && endDateInput) {
        startDateInput.value = formatDateForInput(lastMonth);
        endDateInput.value = formatDateForInput(today);
        
        // Update button styles
        setActiveDateRangeButton('monthRangeBtn');
        
        // Trigger save state
        saveNewsletterState();
    }
}

// Helper function to reset all date range button styles to default
function resetDateRangeButtonStyles() {
    const rangeButtons = ['dayRangeBtn', 'weekRangeBtn', 'monthRangeBtn'];
    
    rangeButtons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.classList.remove('active');
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-outline-secondary');
        }
    });
}

// Helper function to set active date range button
function setActiveDateRangeButton(activeButtonId) {
    // Get all date range buttons
    const rangeButtons = ['dayRangeBtn', 'weekRangeBtn', 'monthRangeBtn'];
    
    // Remove active class from all buttons
    rangeButtons.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.classList.remove('active');
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-outline-secondary');
        }
    });
    
    // Add active class to selected button
    const activeBtn = document.getElementById(activeButtonId);
    if (activeBtn) {
        activeBtn.classList.remove('btn-outline-secondary');
        activeBtn.classList.add('btn-secondary');
        activeBtn.classList.add('active');
    }
}

// Function to clear saved newsletter state and editor content
function clearSavedState() {
    try {
        // Clear localStorage items
        localStorage.removeItem('newsletter_content');
        localStorage.removeItem('newsletter_config');
        console.log('Newsletter saved state cleared');
        
        // Clear the editor content
        if (editor) {
            // Reset to empty content
            originalMarkdownContent = '';
            editor.value('# Newsletter Content\n\nContent has been cleared. Click the Generate button to create new content.');
            updatePreview();
        }
        
        // Reset the form elements
        const topicsSelect = document.getElementById('topics');
        if (topicsSelect) {
            Array.from(topicsSelect.options).forEach(option => option.selected = false);
        }
        
        // Reset the last updated text
        const lastUpdatedElement = document.getElementById('lastUpdated');
        if (lastUpdatedElement) {
            lastUpdatedElement.textContent = 'Never';
        }
        
        // Clear any selected articles
        document.getElementById('selectedArticlesCount').textContent = 'No articles selected';
        if (document.getElementById('selectArticlesButton')) {
            document.getElementById('selectArticlesButton').dataset.selectedArticles = JSON.stringify([]);
        }
        document.getElementById('includeArticles').checked = false;
        
        // Show confirmation message
        alert('Editor content and saved state have been cleared.');
    } catch (e) {
        console.error('Error clearing saved state:', e);
        alert('Error clearing saved state: ' + e.message);
    }
}

// Function to toggle all content type checkboxes
function toggleSelectAllContentTypes() {
    const checkboxes = document.querySelectorAll('.content-type-checkbox');
    
    // First determine if all checkboxes are already checked
    const allChecked = Array.from(checkboxes).every(checkbox => checkbox.checked);
    
    // Toggle all checkboxes based on current state
    checkboxes.forEach(checkbox => {
        checkbox.checked = !allChecked;
    });
    
    // Update the button text
    const selectAllBtn = document.getElementById('selectAllContentTypes');
    if (selectAllBtn) {
        selectAllBtn.textContent = allChecked ? 'Select All' : 'Deselect All';
    }
    
    // Save the updated state
    saveNewsletterState();
}

// Add new functions for article and podcast handling
// This is a legacy function to maintain backward compatibility 
function updateSelectedArticlesCounter() {
    // Just call the new function
    updateSelectedArticlesCount();
}

// Handle article selection from search results
function addArticleToSelection(article) {
    const selectedList = document.getElementById('selectedArticlesList');
    if (!selectedList) {
        console.error('Selected articles list container not found!');
        return;
    }
    
    console.log('Adding article to selection:', article);
    
    // Check if article is already selected
    if (document.querySelector(`#selectedArticlesList div[data-uri="${article.uri}"]`)) {
        console.log('Article already selected, skipping');
        return; // Already selected
    }
    
    try {
        // Create article item with proper DOM structure for more reliable selection
        const articleItem = document.createElement('div');
        articleItem.className = 'list-group-item article-item'; // Use both classes for compatibility
        articleItem.dataset.uri = article.uri || '';
        articleItem.dataset.url = article.url || article.uri || '';
        
        // Store all data as attributes to prevent data loss
        articleItem.dataset.title = article.title || 'Untitled';
        articleItem.dataset.source = article.news_source || 'Unknown source';
        articleItem.dataset.date = article.publication_date || 'Unknown date';
        
        // Clean article data to ensure all fields exist
        const safeArticle = {
            title: article.title || 'Untitled',
            summary: article.summary || 'No summary available',
            source: article.news_source || 'Unknown source',
            uri: article.uri || '#',
            url: article.url || article.uri || '#',
            publication_date: article.publication_date || 'Unknown date'
        };
        
        // Create article content
        articleItem.innerHTML = `
            <div class="d-flex justify-content-between align-items-start">
                <div class="flex-grow-1">
                    <strong class="article-title d-block">${safeArticle.title}</strong>
                    <small class="text-muted d-block">Source: ${safeArticle.source} | ${safeArticle.publication_date}</small>
                    <a href="${safeArticle.url}" class="d-block small text-truncate" target="_blank">${safeArticle.url}</a>
                </div>
                <button type="button" class="btn btn-sm btn-outline-danger remove-article-btn ms-2">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        `;
        
        // Add event listener to remove button
        const removeBtn = articleItem.querySelector('.remove-article-btn');
        if (removeBtn) {
            removeBtn.addEventListener('click', () => {
                articleItem.remove();
                updateSelectedArticlesCount(); // Use this instead of updateSelectedArticlesCounter
                
                // If this was the last article, add back the "no articles" message
                if (selectedList.querySelectorAll('.article-item, .list-group-item').length === 0) {
                    selectedList.innerHTML = '<div class="text-center py-3 text-muted" id="noSelectedArticlesMsg">No articles selected</div>';
                }
            });
        }
        
        // Remove "no articles" message if it exists
        const noMsg = document.getElementById('noSelectedArticlesMsg');
        if (noMsg) noMsg.remove();
        
        // Add to selected list
        selectedList.appendChild(articleItem);
        console.log('Article added to selection successfully');
        
        // Update the count - use updateSelectedArticlesCount for more consistent naming
        updateSelectedArticlesCount();
    } catch (error) {
        console.error('Error adding article to selection:', error);
    }
}

// Function to update the selected articles count (unified naming)
function updateSelectedArticlesCount() {
    // First try to find any article-like items
    const articleElements = document.querySelectorAll('#selectedArticlesList .article-item, #selectedArticlesList .list-group-item');
    const count = articleElements.length;
    
    console.log(`Updating article count: found ${count} articles`);
    
    // Update both counter elements for compatibility
    const counter = document.getElementById('selectedArticlesCounter');
    const countDisplay = document.getElementById('selectedArticlesCount');
    
    if (counter) counter.textContent = count;
    if (countDisplay) {
        countDisplay.textContent = count > 0 ? 
            `${count} article${count !== 1 ? 's' : ''} selected` : 
            'No articles selected';
    }
    
    // Show/hide no articles message if it exists
    const noMsg = document.getElementById('noSelectedArticlesMsg');
    if (noMsg) noMsg.style.display = count > 0 ? 'none' : 'block';
}

// When a podcast is selected
function handlePodcastSelection(podcast) {
    if (!podcast) return;
    
    // Update the hidden input that indicates podcast is included
    const includePodcast = document.getElementById('includePodcast');
    if (includePodcast) {
        includePodcast.value = 'true';
        // If it's a checkbox, check it
        if (includePodcast.type === 'checkbox') {
            includePodcast.checked = true;
        }
    }
    
    // Update the podcast name display
    const podcastNameSpan = document.getElementById('selectedPodcastName');
    if (podcastNameSpan) {
        podcastNameSpan.textContent = podcast.title || 'Selected podcast';
        // Store podcast ID for later use when generating content
        podcastNameSpan.dataset.podcastId = podcast.id;
    }
    
    // Check for a row with latest_podcast content type and update its checkbox
    const latestPodcastCheckbox = document.querySelector('.content-type-checkbox[value="latest_podcast"]');
    if (latestPodcastCheckbox) {
        latestPodcastCheckbox.checked = true;
    }
    
    // Update UI to show podcast is selected on any related buttons
    document.querySelectorAll('[data-podcast-button]').forEach(btn => {
        btn.classList.remove('btn-outline-secondary', 'btn-outline-primary');
        btn.classList.add('btn-success');
    });
}

// Initialize these functions when the article search modal opens
document.addEventListener('DOMContentLoaded', () => {
    // Set up article search result handling
    const articleListContainer = document.getElementById('articleListContainer');
    if (articleListContainer) {
        articleListContainer.addEventListener('click', (e) => {
            const addBtn = e.target.closest('.add-article-btn');
            if (addBtn) {
                const articleItem = addBtn.closest('.article-item');
                const uri = articleItem.dataset.uri;
                
                // Get complete article data from the DOM
                const title = articleItem.querySelector('.article-title').textContent;
                
                // Extract source and date from details text
                const detailsText = articleItem.querySelector('.article-source').textContent || '';
                let source = 'Unknown Source';
                if (detailsText.includes('Source:')) {
                    source = detailsText.split('Source:')[1].split('|')[0].trim();
                }
                
                // Get summary
                const summary = articleItem.querySelector('.article-summary')?.textContent || '';
                
                // Collect category, sentiment and other metadata
                const categoryBadge = articleItem.querySelector('.badge.bg-info');
                const category = categoryBadge ? categoryBadge.textContent.trim() : '';
                
                const sentimentBadge = articleItem.querySelector(`.badge[class*="bg-"]:not(.bg-info):not(.bg-warning):not(.bg-secondary):not(.bg-dark)`);
                const sentiment = sentimentBadge ? sentimentBadge.textContent.trim() : '';
                
                const signalBadge = articleItem.querySelector('.badge.bg-warning');
                const future_signal = signalBadge ? signalBadge.textContent.trim() : '';
                
                addArticleToSelection({
                    uri,
                    title,
                    news_source: source,
                    summary,
                    url: uri,
                    category,
                    sentiment,
                    future_signal
                });
            }
        });
    }
    
    // Set up template preview functionality
    const templateSelect = document.getElementById('articleTemplate');
    const templatePreview = document.getElementById('templatePreview');
    
    if (templateSelect && templatePreview) {
        // Set initial preview
        updateTemplatePreview(templateSelect.value);
        
        // Update preview when selection changes
        templateSelect.addEventListener('change', () => {
            updateTemplatePreview(templateSelect.value);
        });
    }
    
    // Set up date range handling
    const dateRangeSelect = document.getElementById('dateRange');
    const customDateRange = document.getElementById('customDateRange');
    
    if (dateRangeSelect && customDateRange) {
        // Set initial state
        if (dateRangeSelect.value === 'custom') {
            customDateRange.style.display = 'block';
        } else {
            customDateRange.style.display = 'none';
        }
        
        // Toggle custom date range when selection changes
        dateRangeSelect.addEventListener('change', () => {
            customDateRange.style.display = dateRangeSelect.value === 'custom' ? 'block' : 'none';
            
            // Set default dates based on selection
            const startDateField = document.getElementById('articleSearchStartDate');
            const endDateField = document.getElementById('articleSearchEndDate');
            
            if (startDateField && endDateField && dateRangeSelect.value !== 'custom') {
                const today = new Date();
                const endDate = today.toISOString().split('T')[0];
                
                let startDate;
                if (dateRangeSelect.value === '7') {
                    const date = new Date(today);
                    date.setDate(date.getDate() - 7);
                    startDate = date.toISOString().split('T')[0];
                } else if (dateRangeSelect.value === '30') {
                    const date = new Date(today);
                    date.setDate(date.getDate() - 30);
                    startDate = date.toISOString().split('T')[0];
                } else if (dateRangeSelect.value === '90') {
                    const date = new Date(today);
                    date.setDate(date.getDate() - 90);
                    startDate = date.toISOString().split('T')[0];
                }
                
                if (startDate) {
                    startDateField.value = startDate;
                    endDateField.value = endDate;
                }
            }
        });
    }
    
    // Connect article search button
    const articleSearchButton = document.getElementById('articleSearchButton');
    if (articleSearchButton) {
        articleSearchButton.addEventListener('click', searchArticles);
    }
    
    // Connect clear selected articles button
    const clearSelectedBtn = document.getElementById('clearSelectedArticles');
    if (clearSelectedBtn) {
        clearSelectedBtn.addEventListener('click', () => {
            const selectedList = document.getElementById('selectedArticlesList');
            if (selectedList) {
                // Clear all but keep the "No articles" message
                selectedList.innerHTML = '<div class="text-center py-3 text-muted" id="noSelectedArticlesMsg">No articles selected</div>';
                // Update counter
                updateSelectedArticlesCount();
            }
        });
    }
    
    // Initialize the save article selection button
    const saveArticleSelectionBtn = document.getElementById('saveArticleSelectionButton');
    if (saveArticleSelectionBtn) {
        saveArticleSelectionBtn.addEventListener('click', saveArticleSelection);
    }
});

// Function to load more articles for pagination
async function loadMoreArticles(searchParams, nextPage) {
    try {
        const container = document.getElementById('articleListContainer');
        if (!container) return;
        
        // Get the current page from the container or use the provided page
        let currentPage = parseInt(container.dataset.currentPage || '1');
        const nextPageToLoad = nextPage || currentPage + 1;
        
        // Create a copy of the search params
        let params;
        if (typeof searchParams === 'string') {
            params = new URLSearchParams(searchParams);
        } else {
            params = new URLSearchParams(searchParams.toString());
        }
        
        // Update the page parameter
        params.set('page', nextPageToLoad.toString());
        
        // Replace the load more button with a loading indicator
        const paginationContainer = container.querySelector('.pagination-container');
        if (paginationContainer) {
            paginationContainer.innerHTML = '<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>';
        }
        
        console.log(`Loading more articles, page ${nextPageToLoad}. Params: ${params.toString()}`);
        
        // Fetch more articles
        const response = await fetch(`/api/search_articles?${params.toString()}`);
        
        if (!response.ok) {
            throw new Error(`Failed to load more articles: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Received additional search results:', data);
        
        // Get the articles from the response
        const articles = data.articles || data;
        const totalCount = data.total_count || parseInt(container.dataset.totalCount || '0');
        
        // Process the articles
        const processedArticles = articles.map(article => {
            return {
                ...article,
                title: article.title || 'Untitled',
                summary: article.summary || 'No summary available',
                news_source: article.news_source || 'Unknown Source',
                url: article.url || article.uri || '#',
                uri: article.uri || article.url || '#',
                publication_date: article.publication_date || 'Unknown date',
                sentiment: article.sentiment || 'Neutral',
                future_signal: article.future_signal || null
            };
        });
        
        // Remove the pagination container
        if (paginationContainer) {
            paginationContainer.remove();
        }
        
        // Append the new articles to the container
        processedArticles.forEach(article => {
            const item = document.createElement('div');
            item.className = 'article-item';
            item.dataset.uri = article.uri || '';
            item.dataset.articleId = article.id;
            
            // Create article content
            const title = document.createElement('h5');
            title.className = 'article-title mb-1';
            title.textContent = article.title;
            
            const details = document.createElement('div');
            details.className = 'article-source small text-muted mb-2';
            
            // Format publication date
            let pubDate = article.publication_date;
            if (pubDate && pubDate !== 'Unknown date' && !pubDate.startsWith('Unknown')) {
                try {
                    pubDate = new Date(pubDate).toLocaleDateString();
                } catch (e) {
                    // Keep as is if not parseable
                }
            }
            
            details.textContent = `Source: ${article.news_source} | Published: ${pubDate}`;
            
            // Create container for article metadata/tags
            const metadataContainer = document.createElement('div');
            metadataContainer.className = 'd-flex flex-wrap gap-2 mb-2';
            
            // Add category if available
            if (article.category) {
                const categoryBadge = document.createElement('span');
                categoryBadge.className = 'badge bg-info me-1';
                categoryBadge.innerHTML = `<i class="fa fa-folder"></i> ${article.category}`;
                metadataContainer.appendChild(categoryBadge);
            }
            
            // Add sentiment if available
            if (article.sentiment) {
                const sentimentClass = getSentimentClass(article.sentiment);
                const sentimentBadge = document.createElement('span');
                sentimentBadge.className = `badge ${sentimentClass} me-1`;
                sentimentBadge.innerHTML = `<i class="fa fa-heart"></i> ${article.sentiment}`;
                metadataContainer.appendChild(sentimentBadge);
            }
            
            // Add future signal if available
            if (article.future_signal) {
                const signalBadge = document.createElement('span');
                signalBadge.className = 'badge bg-warning me-1';
                signalBadge.innerHTML = `<i class="fa fa-compass"></i> ${article.future_signal}`;
                metadataContainer.appendChild(signalBadge);
            }
            
            // Create summary
            const summary = document.createElement('p');
            summary.className = 'article-summary mb-2';
            summary.textContent = article.summary;
            
            // Create button container
            const btnContainer = document.createElement('div');
            btnContainer.className = 'd-flex justify-content-between mt-2';
            
            // Create view source link
            const uri = document.createElement('a');
            uri.href = article.url || article.uri || '#';
            uri.className = 'btn btn-sm btn-outline-secondary';
            uri.innerHTML = '<i class="fa fa-external-link"></i> View Source';
            uri.target = '_blank';
            
            // Create add button
            const selectBtn = document.createElement('button');
            selectBtn.type = 'button';
            selectBtn.className = 'btn btn-sm btn-primary add-article-btn';
            selectBtn.innerHTML = '<i class="fa fa-plus"></i> Add to Selection';
            
            // Add buttons to container
            btnContainer.appendChild(uri);
            btnContainer.appendChild(selectBtn);
            
            // Assemble the item
            item.appendChild(title);
            item.appendChild(details);
            item.appendChild(metadataContainer);
            item.appendChild(summary);
            item.appendChild(btnContainer);
            
            container.appendChild(item);
        });
        
        // Update the current page
        container.dataset.currentPage = nextPageToLoad.toString();
        
        // Add a new pagination container if there are more results
        const totalArticles = parseInt(container.dataset.totalCount || '0');
        const currentlyShowing = container.querySelectorAll('.article-item').length;
        
        if (currentlyShowing < totalArticles) {
            const newPaginationContainer = document.createElement('div');
            newPaginationContainer.className = 'pagination-container text-center mt-3';
            
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.className = 'btn btn-outline-primary';
            loadMoreBtn.innerHTML = `<i class="fa fa-refresh"></i> Load More Results (${currentlyShowing}/${totalArticles})`;
            loadMoreBtn.addEventListener('click', () => {
                loadMoreArticles(params, nextPageToLoad + 1);
            });
            
            newPaginationContainer.appendChild(loadMoreBtn);
            container.appendChild(newPaginationContainer);
        } else {
            // Show a message that all results have been loaded
            const noMoreContainer = document.createElement('div');
            noMoreContainer.className = 'text-center text-muted mt-3';
            noMoreContainer.textContent = `All ${totalArticles} results loaded`;
            container.appendChild(noMoreContainer);
        }
        
    } catch (error) {
        console.error('Error loading more articles:', error);
        const container = document.getElementById('articleListContainer');
        if (container) {
            const paginationContainer = container.querySelector('.pagination-container');
            if (paginationContainer) {
                paginationContainer.innerHTML = `<div class="text-danger">Error loading more articles: ${error.message}</div>`;
            }
        }
    }
}
</script>
{% endblock %} 