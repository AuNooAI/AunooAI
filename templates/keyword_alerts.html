{% extends "base.html" %}

{% block title %}AuNoo AI - Trend Dashboard{% endblock %}

{% block extra_css %}
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!-- Media bias component code directly included -->
<script>
// Helper functions for bias and factual class mapping
function getBiasClass(bias) {
    if (!bias) return '';
    
    bias = bias.toLowerCase();
    console.log('getBiasClass called with:', bias);
    
    if (bias.includes('left') && !bias.includes('center')) {
        return 'bias-left';
    } else if (bias.includes('left-center')) {
        return 'bias-left-center';
    } else if (bias.includes('least biased') || bias.includes('center')) {
        return 'bias-least-biased';
    } else if (bias.includes('right-center')) {
        return 'bias-right-center';
    } else if (bias.includes('right') && !bias.includes('center')) {
        return 'bias-right';
    } else if (bias.includes('pro-science')) {
        return 'bias-pro-science';
    } else if (bias.includes('conspiracy') || bias.includes('pseudo')) {
        return 'bias-conspiracy-pseudoscience';
    } else if (bias.includes('questionable')) {
        return 'bias-questionable';
    } else if (bias.includes('satire')) {
        return 'bias-satire';
    }
    
    return '';
}

function getFactualClass(factual) {
    if (!factual) return '';
    
    factual = factual.toLowerCase();
    
    if (factual.includes('very high')) {
        return 'factual-very-high';
    } else if (factual.includes('high') && !factual.includes('very')) {
        return 'factual-high';
    } else if (factual.includes('mostly')) {
        return 'factual-mostly-factual';
    } else if (factual.includes('mixed')) {
        return 'factual-mixed';
    } else if (factual.includes('low') && !factual.includes('very')) {
        return 'factual-low';
    } else if (factual.includes('very low')) {
        return 'factual-very-low';
    }
    
    return '';
}

// Function to create media bias display for an article
function createMediaBiasDisplay(article) {
    console.log('createMediaBiasDisplay called with article:', article);
    if (!article) {
        console.log('No article provided, returning empty string');
        return '';
    }
    
    // Check if article has bias data fields
    const hasBiasData = article.bias || article.factual_reporting;
    
    if (!hasBiasData) {
        console.log('No bias data found in article, returning empty string');
        return '';
    }
    
    let biasClass = getBiasClass(article.bias);
    let factualClass = getFactualClass(article.factual_reporting);
    console.log('Bias class:', biasClass, 'Factual class:', factualClass);
    
    let html = `<div class="source-metadata">
        <div class="d-flex align-items-center flex-wrap gap-2">`;
    
    if (article.bias) {
        html += `<span class="bias-badge ${biasClass}">
            <i class="fas fa-balance-scale-right me-1"></i> ${article.bias}
        </span>`;
    }
    
    if (article.factual_reporting) {
        html += `<span class="bias-badge ${factualClass}">
            <i class="fas fa-check-circle me-1"></i> ${article.factual_reporting}
        </span>`;
    }
    
    // Create tooltip text for media bias info
    let tooltipText = 'Media Bias Info for ' + (article.source || 'Unknown Source');
    const details = [];
    
    if (article.bias) details.push(`Bias: ${article.bias}`);
    if (article.factual_reporting) details.push(`Factual: ${article.factual_reporting}`);
    if (article.mbfc_credibility_rating) details.push(`Rating: ${article.mbfc_credibility_rating}`);
    if (article.bias_country) details.push(`Country: ${article.bias_country}`);
    if (article.press_freedom) details.push(`Press Freedom: ${article.press_freedom}`);
    if (article.media_type) details.push(`Media Type: ${article.media_type}`);
    if (article.popularity) details.push(`Popularity: ${article.popularity}`);
    
    if (details.length > 0) {
        tooltipText += ' | ' + details.join(' | ');
    }
    
    html += `<span class="source-tooltip" title="${tooltipText}">
        <i class="fas fa-info-circle"></i>
    </span>
    </div>
    </div>`;
    
    console.log('Generated media bias HTML:', html);
    return html;
}

// Expose functions globally so they can be used in other templates
window.getBiasClass = getBiasClass;
window.getFactualClass = getFactualClass;
window.createMediaBiasDisplay = createMediaBiasDisplay;
</script>
<style>
    /* Ensure media bias styling is available on this page */
    .bias-badge {
        display: inline-block;
        padding: 0.2rem 0.5rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        margin-right: 3px;
    }

    /* Bias color coding */
    .bias-left {
        background-color: #3373CC;
        color: white;
    }

    .bias-left-center {
        background-color: #6699EE;
        color: white;
    }

    .bias-least-biased, 
    .bias-center {
        background-color: #88CC88;
        color: black;
    }

    .bias-right-center {
        background-color: #FF9966;
        color: black;
    }

    .bias-right {
        background-color: #CC3333;
        color: white;
    }

    .bias-pro-science {
        background-color: #9966CC;
        color: white;
    }

    .bias-conspiracy-pseudoscience {
        background-color: #666666;
        color: white;
    }

    .bias-questionable {
        background-color: #222222;
        color: white;
    }

    .bias-satire {
        background-color: #CCBB33;
        color: black;
    }

    /* Factual reporting color coding */
    .factual-very-high {
        background-color: #006600;
        color: white;
    }

    .factual-high, 
    .factual-mostly-factual {
        background-color: #339933;
        color: white;
    }

    .factual-mixed {
        background-color: #CCCC00;
        color: black;
    }

    .factual-low, 
    .factual-very-low {
        background-color: #CC0000;
        color: white;
    }

    :root {
        --primary-color: #FF69B4;  /* Hot Pink */
        --primary-dark: #FF1493;   /* Deep Pink */
        --secondary-color: #32CD32;  /* Lime Green */
        --secondary-dark: #228B22;   /* Forest Green */
        --text-color: #333;
        --light-gray: #f8f9fa;
        --medium-gray: #e9ecef;
        --dark-gray: #343a40;
        --border-color: #dee2e6;
        --box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    }

    h2, h5, h6 {
        color: var(--primary-color);
    }

/* Responsive layout improvements */
.container {
    max-width: 100%;
    padding-left: 15px;
    padding-right: 15px;
}

/* Header responsive improvements */
.header-controls {
    flex-wrap: wrap;
    gap: 0.5rem;
}

.header-controls .d-flex {
    flex-wrap: wrap;
    gap: 0.5rem;
}

/* Table responsive improvements */
.table-responsive {
    border: none;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    max-width: 100%;
}

.table {
    min-width: 980px; /* Increased minimum width to accommodate Update Now button */
    max-width: 100%;
    margin-bottom: 0;
    table-layout: fixed; /* Fixed layout for better control */
}

.table th,
.table td {
    vertical-align: middle;
    padding: 0.5rem;
    overflow: hidden;
}

.table th {
    white-space: nowrap;
    font-weight: 600;
    background-color: #f8f9fa;
    border-bottom: 2px solid #dee2e6;
    position: sticky;
    top: 0;
    z-index: 10; /* Higher z-index for sticky headers */
}

.table td {
    border-top: 1px solid #dee2e6;
    position: relative;
}

/* Ensure proper spacing between columns */
.table td:not(:last-child) {
    padding-right: 0.75rem;
}

/* Article content improvements */
.article-content {
    max-width: none;
    min-width: 300px;
}

.article-title {
    word-break: break-word;
    line-height: 1.3;
    max-width: 400px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-decoration: none;
    color: #0d6efd;
}

.article-title:hover {
    text-decoration: underline;
    color: #0a58ca;
}

.article-summary {
    word-break: break-word;
    line-height: 1.3;
    max-width: 400px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* Source column improvements */
.source-info {
    min-width: 120px;
    max-width: 150px;
}

.source-name {
    word-break: break-word;
    font-weight: 600;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* Action buttons improvements - Fixed z-index issue */
.action-buttons {
    min-width: 120px;
    max-width: 150px;
    position: relative;
    z-index: 5; /* Lower than sticky headers but higher than content */
}

.action-buttons .btn {
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    white-space: nowrap;
    margin: 0;
    border: 1px solid;
    background-clip: padding-box;
}

/* Tags column improvements with tooltips */
.tags-column {
    max-width: 120px;
    overflow: hidden;
    position: relative;
}

.tags-column .badge {
    font-size: 0.65rem;
    margin: 1px;
    display: inline-block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100px;
    cursor: help;
    position: relative;
}

/* Improved badge colors for better variety with white text */
.badge.bg-info:nth-child(1) { background-color: #0dcaf0 !important; color: white !important; }
.badge.bg-info:nth-child(2) { background-color: #6f42c1 !important; color: white !important; }
.badge.bg-info:nth-child(3) { background-color: #fd7e14 !important; color: white !important; }
.badge.bg-info:nth-child(4) { background-color: #20c997 !important; color: white !important; }
.badge.bg-info:nth-child(5) { background-color: #e83e8c !important; color: white !important; }
.badge.bg-info:nth-child(6) { background-color: #6610f2 !important; color: white !important; }

/* Ensure all badges have white text for better readability */
.badge {
    color: white !important;
}

/* Badge tooltip - Using JavaScript tooltips only */
.badge[title] {
    position: relative;
    cursor: help;
}

/* Checkbox styling */
.article-checkbox {
    width: 18px;
    height: 18px;
    margin-right: 8px;
    cursor: pointer;
}

.select-all-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

/* Bulk action buttons */
.bulk-actions {
    position: sticky;
    top: 0;
    background: white;
    z-index: 15;
    padding: 10px 0;
    border-bottom: 1px solid #dee2e6;
    margin-bottom: 10px;
}

/* Enhanced sparkline container */
.sparkline-container {
    position: relative;
    margin-right: 10px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    width: 140px;
    height: 50px;
    padding: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.sparkline-container canvas {
    position: absolute;
    top: 8px;
    left: 8px;
    width: calc(100% - 16px) !important;
    height: calc(100% - 16px) !important;
}

.sparkline-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 49%, rgba(255,105,180,0.1) 50%, transparent 51%);
    border-radius: 6px;
    pointer-events: none;
}

/* Trend link styling */
.trend-link {
    color: inherit;
    text-decoration: none;
    display: block;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}

.trend-link:hover {
    background-color: rgba(255, 105, 180, 0.1);
    color: var(--primary-color);
    text-decoration: none;
}

.keyword-labels {
    display: none;
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    background: white;
    padding: 4px;
    border-radius: 4px;
    box-shadow: var(--box-shadow);
    white-space: nowrap;
    z-index: 1000;
    min-width: max-content;
}

.article-reference:hover .keyword-labels {
    display: block;
}

.keyword-labels .badge {
    font-size: 0.75rem;
    margin: 0 2px;
    padding: 3px 6px;
    display: inline-block;
}

.keyword-labels:after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid white;
}

/* Alert message styling */
#alertMessage {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
    min-width: 300px;
    max-width: 500px;
    box-shadow: var(--box-shadow);
}

.source-metadata {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin: 8px 0;
    border-top: 1px solid var(--light-gray);
    padding-top: 8px;
}

.source-tooltip {
    position: relative;
    display: inline-block;
    margin-left: 5px;
    cursor: help;
}

.source-tooltip i {
    color: var(--primary-color);
    opacity: 0.8;
    transition: opacity 0.2s;
}

.source-tooltip:hover i {
    opacity: 1;
}

/* Mobile responsive adjustments */
@media (max-width: 767px) {
    .container {
        padding-left: 10px;
        padding-right: 10px;
    }
    
    /* Header adjustments */
    .d-flex.justify-content-between {
        flex-direction: column;
        gap: 1rem;
    }
    
    .header-controls .d-flex {
        flex-direction: column;
        align-items: flex-start !important;
    }
    
    /* Card header adjustments */
    .card-header .d-flex {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    /* Table adjustments */
    .table {
        min-width: 600px;
        font-size: 0.85rem;
    }
    
    .table th,
    .table td {
        padding: 0.25rem;
    }
    
    /* Hide less important columns on mobile */
    .table th:nth-child(4),
    .table td:nth-child(4) {
        display: none; /* Hide Detected column */
    }
    
    /* Article content mobile */
    .article-title {
        max-width: 250px;
        font-size: 0.9rem;
    }
    
    .article-summary {
        max-width: 250px;
        font-size: 0.8rem;
    }
    
    /* Action buttons mobile */
    .action-buttons {
        min-width: 90px;
        max-width: 110px;
    }
    
    .action-buttons .btn {
        padding: 0.2rem 0.3rem;
        font-size: 0.7rem;
    }
    
    /* Ensure no overlap on mobile */
    .table td {
        padding-right: 0.5rem !important;
    }
    
    /* Source info mobile */
    .source-info {
        min-width: 100px;
        max-width: 120px;
        font-size: 0.8rem;
    }
    
    /* Tags mobile */
    .tags-column {
        max-width: 80px;
    }
    
    .tags-column .badge {
        font-size: 0.6rem;
        padding: 0.1rem 0.3rem;
    }
    
    /* Tooltip adjustments - Disabled in favor of JavaScript tooltips */
    .source-tooltip .tooltip-content {
        display: none; /* Disabled to prevent conflicts with JS tooltips */
    }
    
    /* Pagination controls mobile */
    .pagination-controls {
        flex-direction: column !important;
        gap: 1rem;
        padding: 1rem !important;
    }
    
    .pagination-controls .pagination {
        font-size: 0.85rem;
    }
    
    .pagination-controls .page-link {
        padding: 0.25rem 0.5rem;
    }
    
    .page-size-selector {
        width: 100%;
        justify-content: center;
    }
    
    .pagination-info {
        text-align: center;
        width: 100%;
    }
}

/* Tablet responsive adjustments */
@media (max-width: 991px) and (min-width: 768px) {
    .table {
        min-width: 700px;
    }
    
    .article-title,
    .article-summary {
        max-width: 300px;
    }
    
    .action-buttons {
        min-width: 100px;
        max-width: 130px;
    }
}

/* Media bias badges inside tooltip */
.source-tooltip .bias-badge {
    display: inline-block;
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 500;
    margin: 3px 0;
}

/* Pagination controls styling */
.pagination-controls {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    margin-top: 1rem;
}

.pagination-controls .pagination {
    margin-bottom: 0;
}

.pagination-controls .page-link {
    color: var(--primary-color);
    border-color: #dee2e6;
}

.pagination-controls .page-link:hover {
    background-color: rgba(255, 105, 180, 0.1);
    border-color: var(--primary-color);
}

.pagination-controls .page-item.active .page-link {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
}

.pagination-controls .page-item.disabled .page-link {
    color: #6c757d;
    background-color: transparent;
}

.page-size-selector {
    display: flex;
    align-items: center;
}

.page-size-selector .form-select {
    min-width: 70px;
}

/* Media Bias Display Styles */
.article-bias-container {
    position: relative;
    display: inline-block;
    margin-left: 8px;
}

.article-bias, .article-factual {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-right: 4px;
}

/* Tooltip styling */
.bias-tooltip {
    visibility: hidden;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 0;
    width: 300px;
    background-color: #f9f9f9;
    color: #333;
    text-align: left;
    border-radius: 6px;
    padding: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    border: 1px solid #ddd;
}

.bias-details p {
    margin: 5px 0;
    font-size: 0.8rem;
}

.article-bias-container:hover .bias-tooltip {
    visibility: visible;
    opacity: 1;
}
</style>
{% endblock %}

{% block content %}
<!-- Import the media bias macros -->
{% from "components/media_bias_display.html" import media_bias_badge, media_bias_icon %}

<div class="container mt-4">
    <div class="d-flex justify-content-between align-items-start mb-4">
        <div class="flex-grow-1">
            <h2 class="mb-3">Trends Dashboard</h2>
            <div class="header-controls d-flex flex-column gap-2">
                <div class="d-flex align-items-center gap-3">
                    <span class="text-muted">
                        <i class="fas fa-clock"></i> Last search: {{ last_check_time|default('Never', true) }}
                    </span>
                    {% if last_error %}
                        <span class="text-danger">
                            <i class="fas fa-exclamation-circle"></i> {{ last_error }}
                        </span>
                    {% endif %}
                </div>
                <div class="d-flex align-items-center gap-3">
                    <span class="text-muted">
                        <i class="fas fa-sync"></i> Polling every {{ display_interval }}
                    </span>
                    <span class="text-muted">
                        <i class="fas fa-hourglass-half"></i> 
                        {% if not is_enabled %}
                            Polling disabled
                        {% elif next_check_time %}
                            {% set next_check = next_check_time|datetime %}
                            {% set current_time = now|datetime %}
                            {% if next_check <= current_time %}
                                Checking soon...
                            {% else %}
                                Next check: Coming up soon
                            {% endif %}
                        {% else %}
                            Checking soon...
                        {% endif %}
                    </span>
                    <span class="text-muted" id="resetTimer" style="font-size: 0.9rem;">
                        <i class="fas fa-refresh"></i> Loading reset time...
                    </span>
                    <span class="text-danger" id="rateLimitWarning" style="display: none; font-size: 0.9rem;">
                        <i class="fas fa-exclamation-triangle"></i> Rate limit reached
                    </span>
                </div>
                <div class="d-flex align-items-center gap-3 mt-1">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="pollingToggle" 
                               {% if is_enabled %}checked{% endif %}
                               onchange="togglePolling(this.checked)">
                        <label class="form-check-label" for="pollingToggle">
                            Auto-polling {{ 'enabled' if is_enabled else 'disabled' }}
                        </label>
                    </div>
                    <button class="btn btn-sm btn-outline-primary" onclick="checkKeywords()">
                        <i class="fas fa-sync"></i> Check Now
                    </button>
                </div>
            </div>
        </div>
        <div class="flex-shrink-0 ms-3">
            <a href="/keyword-monitor" class="btn btn-primary">
                <i class="fas fa-cog"></i> Manage Keywords
            </a>
        </div>
    </div>

    <!-- Enhanced trend chart section -->
    <div class="card mb-4">
        <div class="card-header">
            <div class="d-flex justify-content-between align-items-center">
                <h5 class="mb-0">EMERGING TRENDS OVERVIEW</h5>
                <div>
                    <button class="btn btn-outline-danger btn-sm me-2" id="bulkDeleteBtn" style="display: none;">
                        <i class="fas fa-trash"></i> Delete Selected (<span id="deleteCount">0</span>)
                    </button>
                    <button class="btn btn-outline-primary btn-sm me-2" id="bulkAnalyzeBtn" style="display: none;">
                        <i class="fas fa-microscope"></i> Analyze Selected (<span id="selectedCount">0</span>)
                    </button>
                    <button class="btn btn-outline-secondary btn-sm" onclick="exportAlerts()">
                        <i class="fas fa-file-export"></i> Export
                    </button>
                </div>
            </div>
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-hover align-middle">
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Emerging Trend</th>
                            <!-- References column removed -->
                            <th class="d-none">References</th>
                            <th style="width: 200px;">Growth</th>
                            <th>Size</th>
                            <th>Tags</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for group in groups %}
                        <tr data-topic="{{ group.topic }}" data-total-count="{{ group.total_count }}">
                            <td>
                                <span class="badge bg-{{ status_colors[group.growth_status] }}">
                                    {{ group.growth_status }}
                                </span>
                            </td>
                            <td>
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <strong>{{ group.name }}</strong>
                                        <p class="text-muted small mb-0">{{ group.topic }}</p>
                                    </div>
                                </div>
                            </td>
                            <!-- References column removed -->
                            <td class="d-none">
                                <div class="d-flex gap-1">
                                    {% if group.alerts %}
                                        {% for alert in group.alerts[:3] %}
                                        <span class="article-reference"
                                              data-url="{{ alert.article.url }}"
                                              data-title="{{ alert.article.title }}"
                                              data-summary="{{ alert.article.summary }}"
                                              data-topic="{{ group.topic }}"
                                              data-group-id="{{ group.id }}"
                                              onclick="toggleArticleSelection(this)"
                                              title="{{ alert.article.title }}">
                                            {{ loop.index }}
                                        </span>
                                        {% if alert.matched_keyword %}
                                            <span class="badge bg-info ms-1" title="{{ alert.matched_keyword }}">
                                                <i class="fas fa-tag me-1"></i>{{ alert.matched_keyword|truncate(8, True, '...') }}
                                            </span>
                                        {% endif %}
                                        {% if alert.matched_keywords %}
                                            {% for keyword in alert.matched_keywords %}
                                                {% if keyword and keyword != alert.matched_keyword %}
                                                <span class="badge bg-info ms-1" title="{{ keyword }}">
                                                    <i class="fas fa-tag me-1"></i>{{ keyword|truncate(8, True, '...') }}
                                                </span>
                                                {% endif %}
                                            {% endfor %}
                                        {% endif %}
                                        {% endfor %}
                                    {% else %}
                                        <span class="text-muted">No recent references</span>
                                    {% endif %}
                                </div>
                            </td>
                            <td>
                                <div class="d-flex align-items-center">
                                    <div class="sparkline-container" style="width: 140px; height: 50px;">
                                        <canvas id="sparkline-{{ group.id }}" 
                                                width="140" 
                                                height="50" 
                                                style="width: 140px; height: 50px;"></canvas>
                                    </div>
                                </div>
                            </td>
                            <td>
                                <span class="badge bg-primary">{{ group.unread_count }} alerts</span>
                            </td>
                            <td>
                                {% for keyword in group.keywords[:3] %}
                                <span class="badge bg-info" title="{{ keyword }}">
                                    <i class="fas fa-tag me-1"></i>{{ keyword|truncate(10, True, '...') }}
                                </span>
                                {% endfor %}
                            </td>
                            <td>
                                <a href="/keyword-monitor#group-{{ group.id }}" class="btn btn-sm btn-outline-primary trend-link" title="Manage this keyword group">
                                    <i class="fas fa-cog"></i> Manage
                                </a>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    {% if groups %}
        <div class="row">
            {% for group in groups %}
            <div class="col-12 mb-4">
                <div class="card" id="group-{{ group.id }}">
                    <div class="card-header bg-light">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-3">
                                <div>
                                    <h5 class="mb-0">{{ group.name }}</h5>
                                    <div class="text-muted small">
                                        Topic: <span class="badge bg-secondary">{{ group.topic }}</span>
                                        {% if group.keywords %}
                                            <span class="ms-2">Monitoring: 
                                                {% for keyword in group.keywords %}
                                                <span class="badge bg-info" title="{{ keyword }}">
                                                    <i class="fas fa-tag me-1"></i>{{ keyword|truncate(12, True, '...') }}
                                                </span>
                                                {% endfor %}
                                            </span>
                                        {% endif %}
                                    </div>
                                </div>
                                <div class="form-check form-switch">
                                    <input class="form-check-input show-read-toggle" 
                                           type="checkbox" 
                                           id="showReadToggle_{{ group.id }}"
                                           data-topic="{{ group.topic }}"
                                           data-group-id="{{ group.id }}">
                                    <label class="form-check-label" for="showReadToggle_{{ group.id }}">
                                        Show read articles (<span class="total-count">{{ group.total_count }}</span> total)
                                    </label>
                                </div>
                            </div>
                            <div class="d-flex gap-2 align-items-center" data-group-id="{{ group.id }}">
                                <button class="btn btn-outline-primary btn-sm bulk-analyze-btn" 
                                        data-topic="{{ group.topic }}"
                                        data-group-id="{{ group.id }}"
                                        onclick="analyzeBulkArticles('{{ group.topic }}', '{{ group.id }}')"
                                        style="display: none;">
                                    <i class="fas fa-microscope"></i> 
                                    Analyze Selected (<span class="selected-count">0</span>)
                                </button>
                                <button class="btn btn-outline-danger btn-sm bulk-delete-btn"
                                        data-topic="{{ group.topic }}"
                                        data-group-id="{{ group.id }}"
                                        onclick="bulkDeleteArticles('{{ group.topic }}', '{{ group.id }}')"
                                        style="display: none;">
                                    <i class="fas fa-trash"></i>
                                    Delete Selected (<span class="delete-count">0</span>)
                                </button>
                                <button class="btn btn-outline-success btn-sm" 
                                        onclick="updateGroupNow('{{ group.topic }}', '{{ group.id }}')"
                                        title="Check for new articles in this group">
                                    <i class="fas fa-sync"></i> Update Now!
                                </button>
                                <button class="btn btn-outline-info btn-sm" 
                                        onclick="exportGroupAlerts('{{ group.topic }}', '{{ group.id }}')"
                                        title="Export alerts for this group">
                                    <i class="fas fa-download"></i> Export
                                </button>
                                <span class="badge bg-primary">{{ group.unread_count }} alerts</span>
                                {% set enriched_count = group.alerts|selectattr('article.category')|list|length + group.alerts|selectattr('article.analysis_complete')|list|length %}
                                {% if enriched_count > 0 %}
                                <span class="badge bg-success ms-1" title="{{ enriched_count }} articles have been analyzed">
                                    <i class="fas fa-brain me-1"></i>{{ enriched_count }} enriched
                                </span>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                    
                    {% if group.alerts %}
                    <div class="table-responsive" style="max-height: 600px; overflow-y: auto;">
                        <!-- Bulk actions bar -->
                        <div class="bulk-actions" id="bulkActions_{{ group.id }}" style="display: none;">
                            <div class="d-flex align-items-center gap-3">
                                <label class="form-check-label">
                                    <input type="checkbox" class="select-all-checkbox me-2" 
                                           onchange="toggleSelectAll(this, '{{ group.id }}')">
                                    Select All
                                </label>
                                <button class="btn btn-sm btn-outline-primary" 
                                        onclick="analyzeSelectedArticles('{{ group.topic }}', '{{ group.id }}')">
                                    <i class="fas fa-microscope"></i> Analyze Selected
                                </button>
                                <button class="btn btn-sm btn-outline-success" 
                                        onclick="bulkMarkAsRead('{{ group.id }}')">
                                    <i class="fas fa-check"></i> Mark Selected as Read
                                </button>
                                <button class="btn btn-sm btn-outline-danger" 
                                        onclick="bulkDeleteSelected('{{ group.id }}')">
                                    <i class="fas fa-trash"></i> Delete Selected
                                </button>
                                <span class="text-muted" id="selectedInfo_{{ group.id }}">0 selected</span>
                            </div>
                        </div>
                        
                        <table class="table table-hover align-middle mb-0">
                            <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                <tr>
                                    <th style="width: 50px; min-width: 50px;">
                                        <input type="checkbox" class="select-all-checkbox" 
                                               onchange="toggleSelectAll(this, '{{ group.id }}')">
                                    </th>
                                    <th style="width: 80px; min-width: 60px;">Status</th>
                                    <th style="width: 30%; min-width: 280px;">Article</th>
                                    <th style="width: 15%; min-width: 120px;">Source</th>
                                    <th style="width: 12%; min-width: 100px;">Detected</th>
                                    <th style="width: 13%; min-width: 100px;">Tags</th>
                                    <th style="width: 25%; min-width: 200px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for alert in group.alerts %}
                                <tr data-alert-id="{{ alert.id }}" data-group-id="{{ group.id }}"
                                    data-article-category="{{ alert.article.category|default('', true) }}"
                                    data-article-sentiment="{{ alert.article.sentiment|default('', true) }}"
                                    data-article-driver-type="{{ alert.article.driver_type|default('', true) }}"
                                    data-article-time-to-impact="{{ alert.article.time_to_impact|default('', true) }}">
                                    <td>
                                        <input type="checkbox" class="article-checkbox" 
                                               data-alert-id="{{ alert.id }}"
                                               data-group-id="{{ group.id }}"
                                               onchange="updateBulkActions('{{ group.id }}')">
                                    </td>
                                    <td>
                                        <div class="d-flex align-items-center">
                                            {% set has_enrichment = (alert.article.category and alert.article.category|trim) or (alert.article.sentiment and alert.article.sentiment|trim) or (alert.article.driver_type and alert.article.driver_type|trim) or (alert.article.time_to_impact and alert.article.time_to_impact|trim) %}
                                            {% if has_enrichment %}
                                            <span class="badge bg-success">Added</span>
                                            {% else %}
                                            <span class="badge bg-primary">New</span>
                                            {% endif %}
                                            <!-- DEBUG: {{ alert.article.category }}|{{ alert.article.sentiment }}|{{ alert.article.driver_type }}|{{ alert.article.time_to_impact }} -->
                                        </div>
                                    </td>
                                    <td>
                                        <div class="article-content d-flex flex-column">
                                            <div class="mb-1">
                                                                                            <div class="d-flex gap-2 align-items-start">
                                                <a href="{{ alert.article.url }}" target="_blank" class="article-title">{{ alert.article.title }}</a>
                                                </div>
                                                <p class="text-muted mb-0 small article-summary">{{ alert.article.summary }}</p>

                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="source-info small">
                                            <div class="source-name">{{ alert.article.source }}</div>
                                            <div class="text-muted">
                                                {{ alert.article.publication_date|datetime }}
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="small">
                                            <div>{{ alert.detected_at|timeago }}</div>
                                            <div class="text-muted">
                                                {{ alert.detected_at|datetime }}
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="tags-column">
                                            {% if alert.matched_keyword %}
                                                <span class="badge bg-info" title="{{ alert.matched_keyword }}">
                                                    <i class="fas fa-tag me-1"></i>{{ alert.matched_keyword|truncate(10, True, '...') }}
                                                </span>
                                            {% endif %}
                                            {% if alert.matched_keywords %}
                                                {% for keyword in alert.matched_keywords %}
                                                    {% if keyword and keyword != alert.matched_keyword %}
                                                    <span class="badge bg-info" title="{{ keyword }}">
                                                        <i class="fas fa-tag me-1"></i>{{ keyword|truncate(10, True, '...') }}
                                                    </span>
                                                    {% endif %}
                                                {% endfor %}
                                            {% endif %}
                                        </div>
                                    </td>
                                    <td>
                                        <div class="action-buttons d-flex flex-column gap-1">
                                            <div class="d-flex gap-1">
                                                <button class="btn btn-sm btn-outline-success" 
                                                        onclick="markAsRead('{{ alert.id }}')"
                                                        data-topic="{{ group.topic }}"
                                                        data-group-id="{{ group.id }}"
                                                        title="Mark as read">
                                                    <i class="fas fa-check"></i>
                                                </button>
                                                <a href="/submit-article?url={{ alert.article.url|urlencode }}&topic={{ group.topic|urlencode }}" 
                                                   class="btn btn-sm btn-outline-primary"
                                                   title="Analyze article">
                                                    <i class="fas fa-microscope"></i>
                                                </a>
                                            </div>
                                            <div class="d-flex gap-1">
                                                <a href="https://12ft.io/{{ alert.article.url }}" 
                                                   class="btn btn-sm btn-outline-secondary"
                                                   title="Bypass Paywall" 
                                                   target="_blank">
                                                    <i class="fas fa-unlock"></i>
                                                </a>
                                                <a href="https://archive.is/{{ alert.article.url }}" 
                                                   class="btn btn-sm btn-outline-secondary"
                                                   title="Archive" 
                                                   target="_blank">
                                                    <i class="fas fa-archive"></i>
                                                </a>
                                            </div>
                                        </div>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                    {% else %}
                    <div class="card mb-4">
                        <div class="card-body">
                            <div class="alert alert-info mb-0">
                                <i class="fas fa-info-circle"></i> No new alerts for this group
                            </div>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>
    {% else %}
    <div class="alert alert-info">
        <i class="fas fa-info-circle"></i> No unread alerts found.
        <a href="/keyword-monitor" class="alert-link">Set up keyword monitoring</a> to get notified about relevant articles.
    </div>
    {% endif %}
</div>

<!-- Add this at the top of the page for error messages -->
<div id="alertMessage" class="alert alert-danger alert-dismissible fade" role="alert" style="display: none;">
    <span id="alertText"></span>
    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
</div>

<script>
// Debug initial page data
document.addEventListener('DOMContentLoaded', function() {
    console.log('Checking initial page data for enrichment fields...');
    
    // Check all articles in the initial page load
    const allArticleRows = document.querySelectorAll('tr[data-alert-id]');
    console.log(`Found ${allArticleRows.length} article rows on initial load`);
    
    allArticleRows.forEach((row, index) => {
        const title = row.querySelector('.article-title')?.textContent || 'Unknown';
        const statusBadge = row.querySelector('.badge')?.textContent || 'Unknown';
        
        // Check if this is a Jinja-rendered row that should show enrichment
        const hasEnrichmentBadge = row.querySelector('.badge.bg-success')?.textContent === 'Added';
        
        console.log(`Initial row ${index}:`, {
            title: title.substring(0, 50) + '...',
            statusBadge: statusBadge,
            hasEnrichmentBadge: hasEnrichmentBadge,
            alertId: row.dataset.alertId
        });
    });
});

// Enhanced sparkline drawing with better visuals
function drawSparkline(canvas, data) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const padding = 4;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Find min and max values
    const maxValue = Math.max(...data.counts, 1);
    const minValue = Math.min(...data.counts, 0);
    const range = maxValue - minValue || 1;
    
    // Calculate scales
    const xScale = (width - 2 * padding) / Math.max(data.counts.length - 1, 1);
    const yScale = (height - 2 * padding) / range;
    
    // Draw background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, 'rgba(255, 105, 180, 0.1)');
    gradient.addColorStop(1, 'rgba(255, 105, 180, 0.05)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(255, 105, 180, 0.2)';
    ctx.lineWidth = 0.5;
    
    // Horizontal grid lines
    for (let i = 1; i <= 2; i++) {
        const y = padding + (i * (height - 2 * padding) / 3);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
    }
    
    if (data.counts.length > 1) {
        // Draw area under the line
    ctx.beginPath();
        ctx.moveTo(padding, height - padding - ((data.counts[0] - minValue) * yScale));
        
        for (let i = 1; i < data.counts.length; i++) {
            ctx.lineTo(
                i * xScale + padding,
                height - padding - ((data.counts[i] - minValue) * yScale)
            );
        }
        
        ctx.lineTo(width - padding, height - padding);
        ctx.lineTo(padding, height - padding);
        ctx.closePath();
        
        const areaGradient = ctx.createLinearGradient(0, 0, 0, height);
        areaGradient.addColorStop(0, 'rgba(255, 105, 180, 0.3)');
        areaGradient.addColorStop(1, 'rgba(255, 105, 180, 0.05)');
        ctx.fillStyle = areaGradient;
        ctx.fill();
        
        // Draw the main line
        ctx.strokeStyle = '#FF69B4';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        
    ctx.moveTo(
        padding,
            height - padding - ((data.counts[0] - minValue) * yScale)
    );
    
    for (let i = 1; i < data.counts.length; i++) {
        ctx.lineTo(
            i * xScale + padding,
                height - padding - ((data.counts[i] - minValue) * yScale)
        );
    }
    ctx.stroke();
    
        // Draw points with glow effect
        ctx.shadowColor = '#FF69B4';
        ctx.shadowBlur = 4;
        ctx.fillStyle = '#FF69B4';
        
    data.counts.forEach((value, i) => {
            const x = i * xScale + padding;
            const y = height - padding - ((value - minValue) * yScale);
            
        ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
            
            // Add value labels for significant points
            if (value > 0 && (i === 0 || i === data.counts.length - 1 || value === maxValue)) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#333';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value.toString(), x, y - 8);
                ctx.fillStyle = '#FF69B4';
                ctx.shadowBlur = 4;
            }
        });
        
        ctx.shadowBlur = 0;
    } else {
        // Single data point
        ctx.fillStyle = '#FF69B4';
        ctx.beginPath();
        ctx.arc(width / 2, height / 2, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
        ctx.fillText(data.counts[0].toString(), width / 2, height / 2 - 10);
    }
}

// Checkbox and bulk action functionality
function toggleSelectAll(checkbox, groupId) {
    const checkboxes = document.querySelectorAll(`[data-group-id="${groupId}"] .article-checkbox`);
    checkboxes.forEach(cb => {
        cb.checked = checkbox.checked;
    });
    updateBulkActions(groupId);
}

function updateBulkActions(groupId) {
    const checkboxes = document.querySelectorAll(`[data-group-id="${groupId}"] .article-checkbox`);
    const checkedBoxes = document.querySelectorAll(`[data-group-id="${groupId}"] .article-checkbox:checked`);
    const bulkActions = document.getElementById(`bulkActions_${groupId}`);
    const selectedInfo = document.getElementById(`selectedInfo_${groupId}`);
    
    if (checkedBoxes.length > 0) {
        bulkActions.style.display = 'block';
        selectedInfo.textContent = `${checkedBoxes.length} selected`;
    } else {
        bulkActions.style.display = 'none';
    }
    
    // Update select all checkbox state
    const selectAllCheckboxes = document.querySelectorAll(`[data-group-id="${groupId}"] .select-all-checkbox`);
    selectAllCheckboxes.forEach(cb => {
        cb.indeterminate = checkedBoxes.length > 0 && checkedBoxes.length < checkboxes.length;
        cb.checked = checkedBoxes.length === checkboxes.length && checkboxes.length > 0;
    });
}

function bulkMarkAsRead(groupId) {
    const checkedBoxes = document.querySelectorAll(`[data-group-id="${groupId}"] .article-checkbox:checked`);
    const alertIds = Array.from(checkedBoxes).map(cb => cb.dataset.alertId);
    
    if (alertIds.length === 0) {
        showAlert('No articles selected', 'warning');
        return;
    }
    
    if (!confirm(`Mark ${alertIds.length} articles as read?`)) return;
    
    // Get the topic from the group container instead of the checkbox
    const groupContainer = document.querySelector(`[data-group-id="${groupId}"]`);
    let topic = groupContainer ? groupContainer.dataset.topic : null;
    
    if (!topic) {
        // Fallback: try to get topic from the card header
        const cardHeader = document.querySelector(`#group-${groupId}`);
        if (cardHeader) {
            const topicBadge = cardHeader.querySelector('.badge.bg-secondary');
            if (topicBadge) {
                topic = topicBadge.textContent.trim();
            }
        }
    }
    
    // Mark each alert as read
    Promise.all(alertIds.map(alertId => 
        fetch(`/api/keyword-monitor/alerts/${alertId}/read`, { 
            method: 'POST',
            credentials: 'same-origin'
        })
    )).then(() => {
        showAlert(`${alertIds.length} articles marked as read`, 'success');
        // Refresh the group
        const toggle = document.querySelector(`#showReadToggle_${groupId}`);
        if (topic && toggle) {
            refreshGroupArticles(topic, groupId, toggle.checked);
        } else {
            // If we can't get the topic, just reload the page
            setTimeout(() => window.location.reload(), 1000);
        }
    }).catch(error => {
        console.error('Error:', error);
        showAlert('Failed to mark articles as read', 'danger');
    });
}

function bulkDeleteSelected(groupId) {
    const checkedBoxes = document.querySelectorAll(`[data-group-id="${groupId}"] .article-checkbox:checked`);
    const alertIds = Array.from(checkedBoxes).map(cb => cb.dataset.alertId);
    
    if (alertIds.length === 0) {
        showAlert('No articles selected', 'warning');
        return;
    }
    
    if (!confirm(`Delete ${alertIds.length} selected articles? This action cannot be undone.`)) return;
    
    // Get the topic from the group container instead of the checkbox
    const groupContainer = document.querySelector(`[data-group-id="${groupId}"]`);
    let topic = groupContainer ? groupContainer.dataset.topic : null;
    
    if (!topic) {
        // Fallback: try to get topic from the card header
        const cardHeader = document.querySelector(`#group-${groupId}`);
        if (cardHeader) {
            const topicBadge = cardHeader.querySelector('.badge.bg-secondary');
            if (topicBadge) {
                topic = topicBadge.textContent.trim();
            }
        }
    }
    
    // Get article URLs for deletion
    const articleUrls = Array.from(checkedBoxes).map(cb => {
        const row = cb.closest('tr');
        const articleLink = row.querySelector('.article-title');
        return articleLink ? articleLink.href : null;
    }).filter(url => url);
    
    fetch('/api/bulk_delete_articles', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ uris: articleUrls })
    }).then(response => response.json())
    .then(result => {
        showAlert(`${result.deleted_count} articles deleted`, 'success');
        // Refresh the group
        const toggle = document.querySelector(`#showReadToggle_${groupId}`);
        if (topic && toggle) {
            refreshGroupArticles(topic, groupId, toggle.checked);
        } else {
            // If we can't get the topic, just reload the page
            setTimeout(() => window.location.reload(), 1000);
        }
    }).catch(error => {
        console.error('Error:', error);
        showAlert('Failed to delete articles', 'danger');
    });
}

// At the top of the script section, change the storage structure
const selectedArticles = {
    byTopic: {},  // Store by topic for bulk operations
    byGroup: {}   // Store by group for UI updates
};

// Add pagination state tracking
const paginationState = {};

function generateTopicId(topic) {
    return `bulkAnalyzeBtn_${topic.replace(/[^a-zA-Z0-9]/g, '_')}`;
}

let selectedArticlesByTopic = {};

async function loadTrendChart() {
    try {
        const response = await fetch('/api/keyword-monitor/trends', {
            credentials: 'same-origin'
        });
        if (!response.ok) throw new Error('Failed to fetch trend data');
        
        const data = await response.json();
        
        Object.entries(data).forEach(([groupId, groupData]) => {
            const canvas = document.getElementById(`sparkline-${groupId}`);
            if (!canvas) return;
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            drawSparkline(canvas, groupData);
        });
    } catch (error) {
        console.error('Error loading trend charts:', error);
    }
}

// Load charts when page loads and refresh every 5 minutes
document.addEventListener('DOMContentLoaded', () => {
    loadTrendChart();
    setInterval(loadTrendChart, 5 * 60 * 1000);
});

async function markAsRead(alertId) {
    try {
        const response = await fetch(`/api/keyword-monitor/alerts/${alertId}/read`, {
            method: 'POST',
            credentials: 'same-origin'
        });
        
        if (!response.ok) throw new Error('Failed to mark alert as read');
        
        const alertElement = document.querySelector(`[onclick*="${alertId}"]`);
        if (!alertElement) throw new Error('Alert element not found');
        
        const topic = alertElement.dataset.topic;
        const groupId = alertElement.dataset.groupId;
        
        if (!topic || !groupId) {
            console.error('Missing topic or groupId:', { topic, groupId });
            throw new Error('Missing required data attributes');
        }
        
        // Update the status badge count
        const groupCard = alertElement.closest('.card');
        const statusBadge = groupCard.querySelector('.badge.bg-primary');
        const currentCount = parseInt(statusBadge.textContent);
        if (!isNaN(currentCount)) {
            const newCount = Math.max(0, currentCount - 1);
            statusBadge.textContent = `${newCount} alerts`;
        }
        
        const toggle = document.querySelector(`#showReadToggle_${groupId}`);
        if (!toggle) throw new Error('Toggle element not found');
        
        // Refresh with current toggle state
        await refreshGroupArticles(topic, groupId, toggle.checked);
        
        showAlert('Alert marked as read', 'success');
    } catch (error) {
        console.error('Error:', error);
        showAlert('Failed to mark alert as read', 'danger');
    }
}

function showAlert(message, type = 'danger') {
    let alert = document.getElementById('alertMessage');
    if (!alert) {
        // Create alert element if it doesn't exist
        alert = document.createElement('div');
        alert.id = 'alertMessage';
        alert.className = 'alert alert-dismissible fade';
        alert.setAttribute('role', 'alert');
        alert.style.position = 'fixed';
        alert.style.top = '20px';
        alert.style.right = '20px';
        alert.style.zIndex = '1050';
        alert.style.minWidth = '300px';
        alert.style.maxWidth = '500px';
        alert.style.boxShadow = '0 0.5rem 1rem rgba(0, 0, 0, 0.15)';
        
        document.body.appendChild(alert);
    }

    // Update alert content
    alert.className = `alert alert-${type} alert-dismissible fade show`;
    alert.innerHTML = `
        <span id="alertText">${message}</span>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    alert.style.display = 'block';
    
    // Clear any existing timeout
    if (alert.timeoutId) {
        clearTimeout(alert.timeoutId);
    }
    
    // For rate limit warnings, show longer and update the status indicator
    const timeout = type === 'warning' && message.toLowerCase().includes('rate limit') ? 10000 : 5000;
    
    // Show rate limit warning indicator if this is a rate limit error
    if (type === 'warning' && message.toLowerCase().includes('rate limit')) {
        const rateLimitWarning = document.getElementById('rateLimitWarning');
        if (rateLimitWarning) {
            rateLimitWarning.style.display = 'inline';
        }
    }
    
    // Auto-dismiss after timeout
    alert.timeoutId = setTimeout(() => {
        alert.classList.remove('show');
        setTimeout(() => {
            alert.style.display = 'none';
        }, 150); // Match the fade transition time
    }, timeout);
    
    // Add click handler for manual dismissal
    const closeButton = alert.querySelector('.btn-close');
    if (closeButton) {
        closeButton.onclick = () => {
            alert.classList.remove('show');
            setTimeout(() => {
                alert.style.display = 'none';
            }, 150);
        };
    }
}

async function checkKeywords() {
    const button = event.target.closest('button');
    const originalHtml = button.innerHTML;
    
    try {
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
        
        console.log("Sending check-now request to API...");
        const response = await fetch('/api/keyword-monitor/check-now', {
            method: 'POST',
            credentials: 'same-origin'
        });
        
        console.log("API response received:", response.status);
        
        if (response.status === 429) {
            const errorData = await response.json().catch(() => ({}));
            const message = errorData.detail || 'API daily request limit reached. Please try again tomorrow.';
            showAlert(message, 'warning');
            return;
        }
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error("API error:", errorData);
            
            // Check if the error message contains rate limit information
            if (errorData.detail && errorData.detail.toLowerCase().includes('rate limit')) {
                showAlert('Rate limit exceeded. Please try again later or upgrade your API plan.', 'warning');
            } else {
            throw new Error(errorData.detail || 'Failed to check keywords');
            }
            return;
        }
        
        const result = await response.json();
        console.log("API check complete:", result);
        
        // Check if the result indicates rate limiting or no articles due to limits
        if (result.message && result.message.toLowerCase().includes('rate limit')) {
            showAlert('Rate limit reached during keyword check. Some keywords may not have been processed.', 'warning');
        } else if (result.error && result.error.toLowerCase().includes('rate limit')) {
            showAlert('Rate limit reached during keyword check. Some keywords may not have been processed.', 'warning');
        } else if (result.new_articles === 0 && result.warnings && result.warnings.some(w => w.toLowerCase().includes('rate limit'))) {
            showAlert('Rate limit reached. No new articles found due to API limitations.', 'warning');
        } else {
        // Show success message
            const articlesFound = result.new_articles || 0;
            showAlert(`Keyword check completed successfully. Found ${articlesFound} new articles. Refreshing page...`, 'success');
        }
        
        // Wait a moment to ensure database operations complete
        setTimeout(() => {
            console.log("Reloading page to show updated results");
            window.location.reload();
        }, 1500);
        
    } catch (error) {
        console.error('Error:', error);
        
        // Check if the error message contains rate limit information
        if (error.message && error.message.toLowerCase().includes('rate limit')) {
            showAlert('Rate limit exceeded. Please try again later or upgrade your API plan.', 'warning');
        } else {
        showAlert('Failed to check keywords: ' + error.message, 'danger');
        }
    } finally {
        button.disabled = false;
        button.innerHTML = originalHtml;
    }
}

// Update the DOMContentLoaded event listener to be simpler
document.addEventListener('DOMContentLoaded', function() {
    // Initialize toggles
    document.querySelectorAll('.show-read-toggle').forEach(toggle => {
        const topic = toggle.dataset.topic;
        const groupId = toggle.dataset.groupId;
        
        if (!topic || !groupId) {
            console.error('Toggle missing required data attributes');
            return;
        }
        
        const savedState = localStorage.getItem(`showReadArticles_${groupId}`);
        toggle.checked = savedState === 'true' || false;
        
        toggle.addEventListener('change', async function() {
            console.log(`Toggle changed for group ${groupId} (${topic}): ${this.checked}`);
            localStorage.setItem(`showReadArticles_${groupId}`, this.checked);
            await refreshGroupArticles(topic, groupId, this.checked);
        });
    });

    // Initialize reset timer
    updateResetTimer();
    setInterval(updateResetTimer, 60000);
    
    // Add media bias info to all articles
    console.log('Initializing media bias enhancement');
    
    // First call the enhanced media bias function for initial page load
    enhanceAllArticlesWithMediaBias();
    
    // Then set up a MutationObserver to detect when new articles are added
    const articleContainers = document.querySelectorAll('.card-body table tbody');
    if (articleContainers.length > 0) {
        console.log(`Setting up observers for ${articleContainers.length} article containers`);
        
        const observer = new MutationObserver(function(mutations) {
            console.log('Detected DOM changes, enhancing media bias');
            enhanceAllArticlesWithMediaBias();
        });
        
        // Observe each article container for child additions/removals
        articleContainers.forEach(container => {
            observer.observe(container, { childList: true });
        });
    }
});

// Helper function for normalizing domains (matches Python normalize_domain)
function normalizeDomain(url) {
    if (!url) return '';
    
    // Convert to lowercase
    let domain = url.toLowerCase();
    
    // Remove protocol if present
    if (domain.startsWith('http://')) {
        domain = domain.substring(7);
    } else if (domain.startsWith('https://')) {
        domain = domain.substring(8);
    }
    
    // Remove www. if present
    if (domain.startsWith('www.')) {
        domain = domain.substring(4);
    }
    
    // Remove paths, query parameters, etc.
    domain = domain.split('/')[0];
    
    // Remove trailing punctuation
    domain = domain.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');
    
    return domain.trim();
}

// Helper function to check if two domains match (like Python domains_match)
function domainsMatch(sourceDomain, targetDomain) {
    if (!sourceDomain || !targetDomain) return false;
    
    // Normalize both domains
    sourceDomain = normalizeDomain(sourceDomain);
    targetDomain = normalizeDomain(targetDomain);
    
    // Check for exact match
    if (sourceDomain === targetDomain) return true;
    
    // Check if one is a subdomain of the other
    if (sourceDomain.endsWith('.' + targetDomain)) return true;
    if (targetDomain.endsWith('.' + sourceDomain)) return true;
    
    // Extract root domains (e.g., example.com from sub.example.com)
    const sourceParts = sourceDomain.split('.');
    const targetParts = targetDomain.split('.');
    
    if (sourceParts.length >= 2 && targetParts.length >= 2) {
        const sourceRoot = sourceParts.slice(-2).join('.');
        const targetRoot = targetParts.slice(-2).join('.');
        if (sourceRoot === targetRoot) return true;
    }
    
    return false;
}

// Function for adding media bias badges to all articles
function enhanceAllArticlesWithMediaBias() {
    console.log('Enhancing all articles with media bias data');
    
    // Look for all table rows that might contain articles
    const allRows = document.querySelectorAll('tr');
    console.log(`Found ${allRows.length} table rows to check for media bias`);
    
    // Process each row
    allRows.forEach((row, index) => {
        // Look for source information
        const sourceCell = row.querySelector('td div.small .fw-bold');
        if (!sourceCell) return;
        
        const sourceName = sourceCell.textContent.trim();
        console.log(`Row ${index}: Found source: ${sourceName}`);
        
        // Check common sources that should have media bias data
        const knownSources = {
            'vanity fair': { bias: 'Left', factual: 'Mixed', country: 'USA' },
            'cnn': { bias: 'Left', factual: 'Mostly Factual', country: 'USA' },
            'forbes': { bias: 'Least Biased', factual: 'Mostly Factual', country: 'USA' },
            'yahoo': { bias: 'Left-Center', factual: 'Mostly Factual', country: 'USA' },
            'theverge': { bias: 'Left-Center', factual: 'Mostly Factual', country: 'USA' },
            'the verge': { bias: 'Left-Center', factual: 'Mostly Factual', country: 'USA' }
        };
        
        let matchedSource = null;
        const normalizedSource = normalizeDomain(sourceName);
        
        // Check for match with any known source
        for (const [source, data] of Object.entries(knownSources)) {
            if (domainsMatch(source, normalizedSource) || 
                sourceName.toLowerCase().includes(source.toLowerCase()) ||
                normalizedSource.includes(normalizeDomain(source))) {
                console.log(`Source ${sourceName} matches known source: ${source}`);
                matchedSource = { source: source, ...data };
                break;
            }
        }
        
        // If we have a match and media bias isn't already displayed, add it
        if (matchedSource) {
            const sourceContainer = sourceCell.closest('div.small');
            if (!sourceContainer) return;
            
            // Check if media bias is already displayed
            if (sourceContainer.querySelector('.source-metadata')) {
                console.log('Media bias already displayed for this source');
                return;
            }
            
            console.log(`Adding media bias display for ${sourceName} (matched: ${matchedSource.source})`);
            
            // Get bias and factual classes
            const biasClass = getBiasClass(matchedSource.bias);
            const factualClass = getFactualClass(matchedSource.factual);
            
            // Create article object for createMediaBiasDisplay
            const articleData = {
                source: sourceName,
                bias: matchedSource.bias,
                factual_reporting: matchedSource.factual,
                bias_country: matchedSource.country
            };
            
            // Generate HTML using our reusable function
            const biasHtml = createMediaBiasDisplay(articleData);
            
            // Add the HTML after the publication date
            const publicationDateDiv = sourceContainer.querySelector('.text-muted');
            if (publicationDateDiv) {
                console.log('Adding media bias HTML after publication date');
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = biasHtml;
                publicationDateDiv.insertAdjacentElement('afterend', tempDiv.firstElementChild);
            } else {
                console.log('No publication date div found, adding at the end of container');
                sourceContainer.insertAdjacentHTML('beforeend', biasHtml);
            }
        }
    });
}

// Backward compatibility: keep the old function name but use the new implementation
function debugMediaBias() {
    console.log('Using enhanced media bias function');
    enhanceAllArticlesWithMediaBias();
}

// Add custom date formatting
function formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
}

function timeAgo(dateStr) {
    const date = new Date(dateStr);
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);
    
    // Handle future dates
    if (seconds < 0) {
        const futureSeconds = Math.abs(seconds);
        
        let interval = Math.floor(futureSeconds / 31536000);
        if (interval > 1) return `in ${interval} years`;
        
        interval = Math.floor(futureSeconds / 2592000);
        if (interval > 1) return `in ${interval} months`;
        
        interval = Math.floor(futureSeconds / 86400);
        if (interval > 1) return `in ${interval} days`;
        
        interval = Math.floor(futureSeconds / 3600);
        if (interval > 1) return `in ${interval} hours`;
        
        interval = Math.floor(futureSeconds / 60);
        if (interval > 1) return `in ${interval} minutes`;
        
        return `in ${Math.floor(futureSeconds)} seconds`;
    }
    
    // Handle past dates (original logic)
    let interval = Math.floor(seconds / 31536000);
    if (interval > 1) return `${interval} years ago`;
    
    interval = Math.floor(seconds / 2592000);
    if (interval > 1) return `${interval} months ago`;
    
    interval = Math.floor(seconds / 86400);
    if (interval > 1) return `${interval} days ago`;
    
    interval = Math.floor(seconds / 3600);
    if (interval > 1) return `${interval} hours ago`;
    
    interval = Math.floor(seconds / 60);
    if (interval > 1) return `${interval} minutes ago`;
    
    return `${Math.floor(seconds)} seconds ago`;
}

// Add Jinja filters
document.addEventListener('DOMContentLoaded', function() {
    const dates = document.querySelectorAll('[data-date]');
    dates.forEach(el => {
        const dateStr = el.dataset.date;
        if (el.classList.contains('timeago')) {
            el.textContent = timeAgo(dateStr);
        } else {
            el.textContent = formatDate(dateStr);
        }
    });
});

async function togglePolling(enabled) {
    try {
        const response = await fetch('/api/keyword-monitor/toggle-polling', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ enabled }),
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error('Failed to toggle polling');
        }
        
        // Update the label text
        const label = document.querySelector('label[for="pollingToggle"]');
        if (label) {
            label.textContent = `Auto-polling ${enabled ? 'enabled' : 'disabled'}`;
        }
        
        // Update the next check time display
        const nextCheckSpan = document.querySelector('span.text-muted i.fa-hourglass-half')?.parentElement;
        if (nextCheckSpan) {
            if (enabled) {
                // Refresh the status to get accurate next check time
                fetchMonitorStatus();
            } else {
                nextCheckSpan.innerHTML = `<i class="fas fa-hourglass-half"></i> Polling disabled`;
            }
        }
        
        showAlert(`Auto-polling ${enabled ? 'enabled' : 'disabled'}`, 'success');
        
    } catch (error) {
        console.error('Error:', error);
        showAlert('Failed to toggle polling');
        // Revert the toggle if there was an error
        const toggle = document.getElementById('pollingToggle');
        if (toggle) {
            toggle.checked = !enabled;
        }
    }
}

async function exportAlerts() {
    try {
        const response = await fetch('/api/keyword-monitor/export-alerts', {
            credentials: 'same-origin'
        });
        if (!response.ok) throw new Error('Failed to export alerts');
        
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().split('T')[0];
        a.href = url;
        a.download = `keyword_alerts_${timestamp}.csv`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        a.remove();
        
        showAlert('Alerts exported successfully!', 'success');
    } catch (error) {
        console.error('Error exporting alerts:', error);
        showAlert('Failed to export alerts. Please try again.', 'danger');
    }
}

function toggleArticleSelection(element) {
    const articleData = {
        url: element.dataset.url,
        title: element.dataset.title,
        summary: element.dataset.summary,
        topic: element.dataset.topic,
        groupId: element.dataset.groupId
    };
    
    // Initialize storage if needed
    if (!selectedArticles.byTopic[articleData.topic]) {
        selectedArticles.byTopic[articleData.topic] = [];
    }
    if (!selectedArticles.byGroup[articleData.groupId]) {
        selectedArticles.byGroup[articleData.groupId] = [];
    }
    
    element.classList.toggle('selected');
    
    if (element.classList.contains('selected')) {
        // Add to both topic and group arrays if not already present
        if (!selectedArticles.byTopic[articleData.topic].some(article => article.url === articleData.url)) {
            selectedArticles.byTopic[articleData.topic].push(articleData);
        }
        if (!selectedArticles.byGroup[articleData.groupId].some(article => article.url === articleData.url)) {
            selectedArticles.byGroup[articleData.groupId].push(articleData);
        }
    } else {
        // Remove from both arrays
        selectedArticles.byTopic[articleData.topic] = selectedArticles.byTopic[articleData.topic]
            .filter(article => article.url !== articleData.url);
        selectedArticles.byGroup[articleData.groupId] = selectedArticles.byGroup[articleData.groupId]
            .filter(article => article.url !== articleData.url);
    }
    
    updateBulkButtons(articleData.topic, articleData.groupId);
}

function updateBulkButtons(topic, groupId) {
    const groupArticles = selectedArticles.byGroup[groupId] || [];
    const buttonContainer = document.querySelector(`.d-flex[data-group-id="${groupId}"]`);
    if (!buttonContainer) return;
    
    // Update analyze button for this specific group
    const bulkAnalyzeBtn = buttonContainer.querySelector('.bulk-analyze-btn');
    if (bulkAnalyzeBtn) {
        if (groupArticles.length > 0) {
            bulkAnalyzeBtn.style.display = 'inline-block';
            const selectedCount = bulkAnalyzeBtn.querySelector('.selected-count');
            if (selectedCount) {
                selectedCount.textContent = groupArticles.length;
            }
        } else {
            bulkAnalyzeBtn.style.display = 'none';
        }
    }
    
    // Update delete button for this specific group
    const bulkDeleteBtn = buttonContainer.querySelector('.bulk-delete-btn');
    if (bulkDeleteBtn) {
        if (groupArticles.length > 0) {
            bulkDeleteBtn.style.display = 'inline-block';
            const deleteCount = bulkDeleteBtn.querySelector('.delete-count');
            if (deleteCount) {
                deleteCount.textContent = groupArticles.length;
            }
        } else {
            bulkDeleteBtn.style.display = 'none';
        }
    }
}

// Pagination helper functions
function generatePageNumbers(currentPage, totalPages, topic, groupId) {
    let html = '';
    const maxVisible = 5; // Maximum number of page buttons to show
    
    if (totalPages <= maxVisible) {
        // Show all pages if total is small
        for (let i = 1; i <= totalPages; i++) {
            html += `
                <li class="page-item ${i === currentPage ? 'active' : ''}">
                    <a class="page-link" href="#" 
                       onclick="changePage('${topic}', ${groupId}, ${i}); return false;">
                        ${i}
                    </a>
                </li>
            `;
        }
    } else {
        // Show ellipsis for many pages
        let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
        let endPage = Math.min(totalPages, startPage + maxVisible - 1);
        
        if (endPage - startPage < maxVisible - 1) {
            startPage = Math.max(1, endPage - maxVisible + 1);
        }
        
        if (startPage > 1) {
            html += `
                <li class="page-item">
                    <a class="page-link" href="#" 
                       onclick="changePage('${topic}', ${groupId}, 1); return false;">
                        1
                    </a>
                </li>
            `;
            if (startPage > 2) {
                html += `<li class="page-item disabled"><span class="page-link">...</span></li>`;
            }
        }
        
        for (let i = startPage; i <= endPage; i++) {
            html += `
                <li class="page-item ${i === currentPage ? 'active' : ''}">
                    <a class="page-link" href="#" 
                       onclick="changePage('${topic}', ${groupId}, ${i}); return false;">
                        ${i}
                    </a>
                </li>
            `;
        }
        
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                html += `<li class="page-item disabled"><span class="page-link">...</span></li>`;
            }
            html += `
                <li class="page-item">
                    <a class="page-link" href="#" 
                       onclick="changePage('${topic}', ${groupId}, ${totalPages}); return false;">
                        ${totalPages}
                    </a>
                </li>
            `;
        }
    }
    
    return html;
}

async function changePage(topic, groupId, page) {
    const toggle = document.querySelector(`#showReadToggle_${groupId}`);
    const showRead = toggle ? toggle.checked : false;
    
    // Clear selections when changing pages
    selectedArticles.byGroup[groupId] = [];
    updateBulkActions(groupId);
    
    await refreshGroupArticles(topic, groupId, showRead, true, page);
}

async function changePageSize(topic, groupId, pageSize) {
    // Update page size in state
    if (!paginationState[groupId]) {
        paginationState[groupId] = {};
    }
    paginationState[groupId].pageSize = parseInt(pageSize);
    
    // Reset to page 1 when changing page size
    const toggle = document.querySelector(`#showReadToggle_${groupId}`);
    const showRead = toggle ? toggle.checked : false;
    
    // Clear selections when changing page size
    selectedArticles.byGroup[groupId] = [];
    updateBulkActions(groupId);
    
    await refreshGroupArticles(topic, groupId, showRead, true, 1);
}

function analyzeBulkArticles(topic, groupId) {
    const articles = selectedArticles.byGroup[groupId] || [];
    if (articles.length === 0) {
        showAlert('No articles selected for analysis', 'warning');
            return;
        }
    
    const urls = articles.map(article => article.url).join('\n');
    const params = new URLSearchParams({
        url: urls,
        topic: topic
    });
    
    window.location.href = `/submit-article?${params.toString()}`;
}

// Function to analyze selected articles using checkboxes
function analyzeSelectedArticles(topic, groupId) {
    const checkedBoxes = document.querySelectorAll(`[data-group-id="${groupId}"] .article-checkbox:checked`);
    
    if (checkedBoxes.length === 0) {
        showAlert('No articles selected for analysis', 'warning');
        return;
    }
    
    // Extract URLs from the checked articles
    const urls = Array.from(checkedBoxes).map(checkbox => {
        const row = checkbox.closest('tr');
        const articleLink = row.querySelector('.article-title');
        return articleLink ? articleLink.href : null;
    }).filter(url => url).join('\n');
    
    if (!urls) {
        showAlert('No valid URLs found in selected articles', 'warning');
        return;
    }
    
    // Redirect to submit-article page with the URLs
    const params = new URLSearchParams({
        url: urls,
        topic: topic
    });
    
    window.location.href = `/submit-article?${params.toString()}`;
}

// Function to check if an article has been enriched (has categories, etc.)
function isArticleEnriched(article) {
    // Check if article has been enriched - check for any enrichment fields
    const hasCategory = !!(article.category && article.category.trim() !== '');
    const hasSentiment = !!(article.sentiment && article.sentiment.trim() !== '');
    const hasDriverType = !!(article.driver_type && article.driver_type.trim() !== '');
    const hasTimeToImpact = !!(article.time_to_impact && article.time_to_impact.trim() !== '');
    
    const isEnriched = hasCategory || hasSentiment || hasDriverType || hasTimeToImpact;
    
    // Debug logging for specific articles
    if (article.uri && (article.uri.includes('tomshardware') || article.uri.includes('yahoo') || article.uri.includes('forbes'))) {
        console.log('isArticleEnriched check:', {
            uri: article.uri,
            category: article.category,
            sentiment: article.sentiment,
            driver_type: article.driver_type,
            time_to_impact: article.time_to_impact,
            hasCategory: hasCategory,
            hasSentiment: hasSentiment,
            hasDriverType: hasDriverType,
            hasTimeToImpact: hasTimeToImpact,
            isEnriched: isEnriched,
            articleKeys: Object.keys(article)
        });
    }
    
    return isEnriched;
}

// Function to create enrichment status badge
function createEnrichmentBadge(article) {
    if (isArticleEnriched(article)) {
        return `<span class="badge bg-info ms-1" title="Article has been analyzed">
            <i class="fas fa-check-circle me-1"></i>Analyzed
        </span>`;
    }
    return '';
}



// Function to export alerts for a specific group
async function exportGroupAlerts(topic, groupId) {
    const button = event.target.closest('button');
    const originalHtml = button.innerHTML;
    
    try {
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Exporting...';
        
        console.log(`Exporting alerts for group ${groupId}, topic: ${topic}`);
        
        const response = await fetch(`/api/keyword-monitor/export-group-alerts?topic=${encodeURIComponent(topic)}&group_id=${groupId}`, {
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error('Failed to export group alerts');
        }
        
        // Create download link
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `${topic.replace(/[^a-zA-Z0-9]/g, '_')}_alerts_${timestamp}.csv`;
        
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        a.remove();
        
        showAlert(`Alerts exported successfully for ${topic}!`, 'success');
        
    } catch (error) {
        console.error('Error:', error);
        showAlert(`Failed to export alerts: ${error.message}`, 'danger');
    } finally {
        button.disabled = false;
        button.innerHTML = originalHtml;
    }
}

// Function to update a specific group now
async function updateGroupNow(topic, groupId) {
    const button = event.target.closest('button');
    const originalHtml = button.innerHTML;
    
    try {
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Updating...';
        
        console.log(`Updating group ${groupId} (${topic}) now...`);
        
        const response = await fetch('/api/keyword-monitor/check-now', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                topic: topic,
                group_id: parseInt(groupId)
            }),
            credentials: 'same-origin'
        });
        
        if (response.status === 429) {
            const errorData = await response.json().catch(() => ({}));
            const message = errorData.detail || 'API daily request limit reached. Please try again tomorrow.';
            showAlert(message, 'warning');
            return;
        }
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            
            // Check if the error message contains rate limit information
            if (errorData.detail && errorData.detail.toLowerCase().includes('rate limit')) {
                showAlert('Rate limit exceeded. Please try again later or upgrade your API plan.', 'warning');
            } else {
                throw new Error(errorData.detail || 'Failed to update group');
            }
            return;
        }
        
        const result = await response.json();
        console.log("Group update complete:", result);
        
        // Check if the result indicates rate limiting
        if (result.message && result.message.toLowerCase().includes('rate limit')) {
            showAlert(`Group "${topic}" check completed but rate limit reached. Some keywords may not have been processed.`, 'warning');
        } else {
            // Show success message
            showAlert(`Group "${topic}" updated successfully. Refreshing...`, 'success');
        }
        
        // Wait a moment then refresh the group
        setTimeout(async () => {
            const toggle = document.querySelector(`#showReadToggle_${groupId}`);
            if (toggle) {
                await refreshGroupArticles(topic, groupId, toggle.checked);
            }
        }, 1500);
        
    } catch (error) {
        console.error('Error:', error);
        
        // Check if the error message contains rate limit information
        if (error.message && error.message.toLowerCase().includes('rate limit')) {
            showAlert('Rate limit exceeded. Please try again later or upgrade your API plan.', 'warning');
        } else {
            showAlert(`Failed to update group: ${error.message}`, 'danger');
        }
    } finally {
        button.disabled = false;
        button.innerHTML = originalHtml;
    }
}

async function bulkDeleteArticles(topic, groupId) {
    const articles = selectedArticles.byGroup[groupId] || [];
    
    if (articles.length === 0) {
        showAlert('No articles selected for deletion', 'warning');
        return;
    }
    
    if (!confirm(`Are you sure you want to delete ${articles.length} selected articles from this group?`)) {
        return;
    }
    
    try {
        const response = await fetch('/api/bulk_delete_articles', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                uris: articles.map(article => article.url)
            }),
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error('Failed to delete articles');
        }
        
        const result = await response.json();
        showAlert(`Successfully deleted ${result.deleted_count} articles`, 'success');
        
        // Clear selections
        selectedArticles.byGroup[groupId] = [];
        selectedArticles.byTopic[topic] = [];
        
        // Update UI elements safely with null checks
        const headerBadge = document.querySelector(`a[href="#${groupId}"] .badge, [data-topic="${topic}"] .badge.bg-primary`);
        if (headerBadge) {
            headerBadge.textContent = '0 alerts';
        }
        
        const trendBadge = document.querySelector(`tr[data-topic="${topic}"] td:nth-child(5) .badge.bg-primary`);
        if (trendBadge) {
            trendBadge.textContent = '0 alerts';
        }
        
        // Safely get the toggle element
        const toggle = document.querySelector(`#showReadToggle_${groupId}`);
        if (toggle) {
            const totalSpan = toggle.closest('label')?.querySelector('.total-count');
            if (totalSpan) {
                totalSpan.textContent = '0';
            }
            
            // Refresh the group's content
            await refreshGroupArticles(topic, groupId, toggle.checked || false);
        }
        
        // Update the group content area
        const groupContainer = document.querySelector(`[data-group-id="${groupId}"]`);
        if (groupContainer) {
            const tableBody = groupContainer.closest('.card')?.querySelector('tbody');
            if (tableBody) {
                if (tableBody.children.length === 0) {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="6">
                                <div class="alert alert-info mb-0">
                                    <i class="fas fa-info-circle"></i> No new alerts for this group
                                </div>
                            </td>
                        </tr>
                    `;
                }
            }
        }

    } catch (error) {
        console.error('Error:', error);
        showAlert('Failed to delete articles. Please try again.', 'danger');
    }
}

// Update refreshGroupArticles to skip media bias lookup on refresh and support pagination
async function refreshGroupArticles(topic, groupId, showRead = false, skipMediaBias = true, page = 1) {
    try {
        console.log(`Refreshing articles for group ${groupId} (${topic}), showRead: ${showRead}, page: ${page}`);
        
        // Get current page size from state or use default
        const pageSize = paginationState[groupId]?.pageSize || 50;
        
        const response = await fetch(`/api/keyword-monitor/alerts/${encodeURIComponent(topic)}?show_read=${showRead}&group_id=${groupId}&skip_media_bias=${skipMediaBias}&page=${page}&page_size=${pageSize}`, {
            credentials: 'same-origin',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        });
        
        console.log('API Response status:', response.status);
        console.log('API Response headers:', response.headers.get('content-type'));
        
        if (!response.ok) {
            console.error('API Response not OK:', response.status, response.statusText);
            const text = await response.text();
            console.error('Response body:', text.substring(0, 500));
            throw new Error('Failed to fetch alerts');
        }
        
        const data = await response.json();
        
        // Store pagination info
        if (data.pagination) {
            paginationState[groupId] = {
                ...data.pagination,
                topic: topic,
                showRead: showRead
            };
        }
        
        console.log('API Response data:', data);
        console.log('Number of alerts:', data.alerts ? data.alerts.length : 0);
        console.log('Pagination info:', data.pagination);
        if (data.alerts && data.alerts.length > 0) {
            console.log('First alert:', data.alerts[0]);
            console.log('First alert article:', data.alerts[0].article);
            console.log('First alert enrichment fields:', {
                category: data.alerts[0].article.category,
                sentiment: data.alerts[0].article.sentiment,
                driver_type: data.alerts[0].article.driver_type,
                time_to_impact: data.alerts[0].article.time_to_impact,
                analysis_complete: data.alerts[0].article.analysis_complete
            });
            // Log all articles to see their enrichment status
            data.alerts.forEach((alert, index) => {
                console.log(`Alert ${index} enrichment:`, {
                    title: alert.article.title.substring(0, 50) + '...',
                    category: alert.article.category,
                    sentiment: alert.article.sentiment,
                    driver_type: alert.article.driver_type,
                    time_to_impact: alert.article.time_to_impact,
                    isEnriched: isArticleEnriched(alert.article)
                });
            });
        }
        
        // Try multiple ways to find the card
        let card = null;
        
        // Method 1: Find by group-id in the header
        const groupHeader = document.querySelector(`.d-flex[data-group-id="${groupId}"]`);
        if (groupHeader) {
            card = groupHeader.closest('.card');
        }
        
        // Method 2: Find by the group ID in the card itself
        if (!card) {
            card = document.querySelector(`#group-${groupId}`);
        }
        
        // Method 3: Find any card that contains the group ID
        if (!card) {
            const allCards = document.querySelectorAll('.card');
            for (const candidateCard of allCards) {
                const groupIdElement = candidateCard.querySelector(`[data-group-id="${groupId}"]`);
                if (groupIdElement) {
                    card = candidateCard;
                    break;
                }
            }
        }
        
        if (!card) {
            console.error(`Card not found for group ${groupId} (${topic})`);
            console.error('Available cards:', document.querySelectorAll('.card'));
            showAlert(`Unable to find group ${groupId} on page`, 'warning');
            return;
        }
        
        console.log(`Found card for group ${groupId}:`, card);
        updateGroupAlerts(card, data, groupId);
        
    } catch (error) {
        console.error('Error refreshing articles:', error);
        showAlert('Failed to refresh articles', 'danger');
    }
}

// Update the updateGroupAlerts function to add more debugging for media bias HTML generation
function updateGroupAlerts(card, data, groupId) {
    // Try multiple selectors to find the table body, including nested card structures
    let tableBody = card.querySelector('tbody');
    
    if (!tableBody) {
        // Try to find it in the table-responsive container
        const tableContainer = card.querySelector('.table-responsive');
        if (tableContainer) {
            tableBody = tableContainer.querySelector('tbody');
        }
    }
    
    if (!tableBody) {
        // Try to find any table body in the card (including nested cards)
        tableBody = card.querySelector('table tbody');
    }
    
    // Handle nested card structure - look for content area
    let contentArea = null;
    if (!tableBody) {
        // Check if this is a group with no alerts (showing the alert div)
        // Look in both the main card and any nested cards
        const alertDiv = card.querySelector('.alert.alert-info');
        
        if (alertDiv && data.alerts && data.alerts.length > 0) {
            // We have alerts to show but no table structure - need to create it
            console.log('Creating table structure for group with new alerts');
            
            // Find the appropriate container - could be nested
            contentArea = alertDiv.closest('.card-body');
            
            // If we're in a nested card structure, we might need to replace the entire nested card
            const nestedCard = alertDiv.closest('.card.mb-4');
            if (nestedCard && nestedCard !== card) {
                // We're in a nested card, replace its content with table-responsive structure
                nestedCard.innerHTML = `
                    <div class="table-responsive" style="max-height: 600px; overflow-y: auto;">
                        <!-- Bulk actions bar -->
                        <div class="bulk-actions" id="bulkActions_${groupId}" style="display: none;">
                            <div class="d-flex align-items-center gap-3">
                                <label class="form-check-label">
                                    <input type="checkbox" class="select-all-checkbox me-2" 
                                           onchange="toggleSelectAll(this, '${groupId}')">
                                    Select All
                                </label>
                                <button class="btn btn-sm btn-outline-primary" 
                                        onclick="analyzeSelectedArticles('${data.topic}', '${groupId}')">
                                    <i class="fas fa-microscope"></i> Analyze Selected
                                </button>
                                <button class="btn btn-sm btn-outline-success" 
                                        onclick="bulkMarkAsRead('${groupId}')">
                                    <i class="fas fa-check"></i> Mark Selected as Read
                                </button>
                                <button class="btn btn-sm btn-outline-danger" 
                                        onclick="bulkDeleteSelected('${groupId}')">
                                    <i class="fas fa-trash"></i> Delete Selected
                                </button>
                                <span class="text-muted" id="selectedInfo_${groupId}">0 selected</span>
                            </div>
                        </div>
                        
                        <table class="table table-hover align-middle mb-0">
                            <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                <tr>
                                    <th style="width: 50px; min-width: 50px;">
                                        <input type="checkbox" class="select-all-checkbox" 
                                               onchange="toggleSelectAll(this, '${groupId}')">
                                    </th>
                                    <th style="width: 80px; min-width: 60px;">Status</th>
                                    <th style="width: 30%; min-width: 280px;">Article</th>
                                    <th style="width: 15%; min-width: 120px;">Source</th>
                                    <th style="width: 12%; min-width: 100px;">Detected</th>
                                    <th style="width: 13%; min-width: 100px;">Tags</th>
                                    <th style="width: 25%; min-width: 200px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                        </table>
                    </div>
                `;
                
                // Now find the tbody we just created
                tableBody = nestedCard.querySelector('tbody');
                contentArea = nestedCard;
            } else if (contentArea) {
                // Replace content in the card body
                contentArea.innerHTML = `
                    <div class="table-responsive" style="max-height: 600px; overflow-y: auto;">
                        <!-- Bulk actions bar -->
                        <div class="bulk-actions" id="bulkActions_${groupId}" style="display: none;">
                            <div class="d-flex align-items-center gap-3">
                                <label class="form-check-label">
                                    <input type="checkbox" class="select-all-checkbox me-2" 
                                           onchange="toggleSelectAll(this, '${groupId}')">
                                    Select All
                                </label>
                                <button class="btn btn-sm btn-outline-primary" 
                                        onclick="analyzeSelectedArticles('${data.topic}', '${groupId}')">
                                    <i class="fas fa-microscope"></i> Analyze Selected
                                </button>
                                <button class="btn btn-sm btn-outline-success" 
                                        onclick="bulkMarkAsRead('${groupId}')">
                                    <i class="fas fa-check"></i> Mark Selected as Read
                                </button>
                                <button class="btn btn-sm btn-outline-danger" 
                                        onclick="bulkDeleteSelected('${groupId}')">
                                    <i class="fas fa-trash"></i> Delete Selected
                                </button>
                                <span class="text-muted" id="selectedInfo_${groupId}">0 selected</span>
                            </div>
                        </div>
                        
                        <table class="table table-hover align-middle mb-0">
                            <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                <tr>
                                    <th style="width: 50px; min-width: 50px;">
                                        <input type="checkbox" class="select-all-checkbox" 
                                               onchange="toggleSelectAll(this, '${groupId}')">
                                    </th>
                                    <th style="width: 80px; min-width: 60px;">Status</th>
                                    <th style="width: 30%; min-width: 280px;">Article</th>
                                    <th style="width: 15%; min-width: 120px;">Source</th>
                                    <th style="width: 12%; min-width: 100px;">Detected</th>
                                    <th style="width: 13%; min-width: 100px;">Tags</th>
                                    <th style="width: 25%; min-width: 200px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                        </table>
                    </div>
                `;
                
                // Now find the tbody we just created
                tableBody = contentArea.querySelector('tbody');
            }
        } else if (alertDiv && (!data.alerts || data.alerts.length === 0)) {
            // No alerts and we have the alert div - this is expected, just return without error
            console.log('No alerts for group, keeping the "no alerts" message');
            
            // Update count in the group panel
            const alertCountBadge = card.querySelector('.badge.bg-primary');
            if (alertCountBadge) {
                alertCountBadge.textContent = `0 alerts`;
            }
            
            // Update count in trend dashboard
            const trendRow = document.querySelector(`tr[data-topic="${data.topic}"]`);
            if (trendRow) {
                const trendCountBadge = trendRow.querySelector('td:nth-child(5) .badge.bg-primary');
                if (trendCountBadge) {
                    trendCountBadge.textContent = `0 alerts`;
                }
            }
            
            // Update the total count in toggle label
            const totalCount = card.querySelector('.total-count');
            if (totalCount) {
                totalCount.textContent = data.total_count || 0;
            }
            
            return; // Exit early - no need to process further
        }
        
        if (!tableBody) {
            console.error('Table body not found in card:', card);
            console.error('Available elements:', card.querySelectorAll('*'));
            console.error('Alert div found:', card.querySelector('.alert.alert-info'));
            console.error('Data alerts length:', data.alerts ? data.alerts.length : 'undefined');
            
            // Last resort: try to reload the page if we can't update the structure
            if (data.alerts && data.alerts.length > 0) {
                showAlert('Unable to update group display. Reloading page to show new articles...', 'info');
                setTimeout(() => window.location.reload(), 2000);
            } else {
                // Don't show error for groups with no alerts
                console.log('No table structure needed - group has no alerts');
            }
        return;
        }
    }
    
    // Update count in the group panel
    const alertCountBadge = card.querySelector('.badge.bg-primary');
    if (alertCountBadge) {
        alertCountBadge.textContent = `${data.unread_count} alerts`;
    }
    
    // Update count in trend dashboard (but not the status badge)
    const trendRow = document.querySelector(`tr[data-topic="${data.topic}"]`);
    if (trendRow) {
        // Find the size column badge specifically (not the status badge)
        const trendCountBadge = trendRow.querySelector('td:nth-child(5) .badge.bg-primary');
        if (trendCountBadge) {
            trendCountBadge.textContent = `${data.unread_count} alerts`;
        }
    }
    
    // Generate alerts HTML
    let html = '';
    for (const alert of data.alerts) {

        
        // Process keywords for this alert
        let keywordBadges = '';
        
        // Debug logging for keywords
        if (alert.article.title && alert.article.title.includes("AI Uncertainty")) {
            console.log('DEBUG: Keywords for AI Uncertainty article:', {
                matched_keyword: alert.matched_keyword,
                matched_keywords: alert.matched_keywords
            });
        }
        
        if (alert.matched_keyword) {
            keywordBadges += `<span class="badge bg-info" title="${alert.matched_keyword}">
                <i class="fas fa-tag me-1"></i>${alert.matched_keyword.length > 10 ? alert.matched_keyword.substring(0, 10) + '...' : alert.matched_keyword}
            </span>`;
        }
        
        // Process additional keywords if available
        if (alert.matched_keywords && Array.isArray(alert.matched_keywords)) {
            alert.matched_keywords.forEach(keyword => {
                if (keyword && keyword !== alert.matched_keyword) {
                    keywordBadges += `<span class="badge bg-info ms-1" title="${keyword}">
                        <i class="fas fa-tag me-1"></i>${keyword.length > 10 ? keyword.substring(0, 10) + '...' : keyword}
                    </span>`;
                }
            });
        }
        
        // Create media bias badges if available
        let mediaBiasHtml = '';
        
        if (alert.article.bias || alert.article.factual_reporting) {
            // First try using the global function if it exists
            if (typeof window.createMediaBiasDisplay === 'function') {
                mediaBiasHtml = window.createMediaBiasDisplay(alert.article);
            }
        }
        
        html += `
            <tr class="${alert.is_read ? 'text-muted bg-light' : ''}"
                data-alert-id="${alert.id}" data-group-id="${groupId}"
                data-bias="${alert.article.bias || ''}"
                data-factual-reporting="${alert.article.factual_reporting || ''}"
                data-credibility-rating="${alert.article.mbfc_credibility_rating || ''}"
                data-bias-country="${alert.article.bias_country || ''}"
                data-press-freedom="${alert.article.press_freedom || ''}"
                data-media-type="${alert.article.media_type || ''}"
                data-popularity="${alert.article.popularity || ''}">
                <td>
                    <input type="checkbox" class="article-checkbox" 
                           data-alert-id="${alert.id}"
                           data-group-id="${groupId}"
                           onchange="updateBulkActions('${groupId}')">
                </td>
                <td>
                    <div class="d-flex align-items-center">
                        ${(() => {
                            // Debug logging for specific articles
                            if (alert.article.title && alert.article.title.includes("AI Uncertainty")) {
                                console.log('DEBUG: AI Uncertainty article in updateGroupAlerts:', {
                                    alertId: alert.id,
                                    article: alert.article,
                                    hasCategory: !!alert.article.category,
                                    hasSentiment: !!alert.article.sentiment,
                                    hasDriverType: !!alert.article.driver_type,
                                    hasTimeToImpact: !!alert.article.time_to_impact,
                                    isEnriched: isArticleEnriched(alert.article)
                                });
                            }
                            
                            if (alert.is_read) {
                                return '<span class="badge bg-secondary">Read</span>';
                            } else if (isArticleEnriched(alert.article)) {
                                return '<span class="badge bg-success">Added</span>';
                            } else {
                                return '<span class="badge bg-primary">New</span>';
                            }
                        })()}
                    </div>
                </td>
                <td>
                    <div class="article-content d-flex flex-column">
                        <div class="mb-1">
                            <div class="d-flex gap-2 align-items-start">
                                <a href="${alert.article.url}" target="_blank" class="article-title">${alert.article.title}</a>
                            </div>
                            <p class="text-muted mb-0 small article-summary">${alert.article.summary}</p>
                        </div>
                    </div>
                </td>
                <td>
                    <div class="source-info small">
                        <div class="source-name">${alert.article.source}</div>
                        <div class="text-muted">
                            ${new Date(alert.article.publication_date).toLocaleString()}
                        </div>
                        ${mediaBiasHtml}
                    </div>
                </td>
                <td>
                    <div class="small">
                        <div>${timeAgo(alert.detected_at)}</div>
                        <div class="text-muted">
                            ${new Date(alert.detected_at).toLocaleString()}
                        </div>
                    </div>
                </td>
                <td>
                    <div class="tags-column">
                        ${keywordBadges}
                    </div>
                </td>
                <td>
                    <div class="action-buttons d-flex flex-column gap-1">
                        <div class="d-flex gap-1">
                            ${!alert.is_read ? 
                                `<button class="btn btn-sm btn-outline-success" 
                                         onclick="markAsRead('${alert.id}')"
                                         data-topic="${data.topic}"
                                         data-group-id="${groupId}"
                                         title="Mark as read">
                                    <i class="fas fa-check"></i>
                                </button>` : 
                                `<button class="btn btn-sm btn-outline-secondary" 
                                         onclick="markAsUnread('${alert.id}')"
                                         title="Mark as unread">
                                    <i class="fas fa-undo"></i>
                                </button>`}
                            <a href="/submit-article?url=${encodeURIComponent(alert.article.url)}&topic=${encodeURIComponent(data.topic)}" 
                               class="btn btn-sm btn-outline-primary"
                               title="Analyze article">
                                <i class="fas fa-microscope"></i>
                            </a>
                        </div>
                        <div class="d-flex gap-1">
                            <a href="https://12ft.io/${alert.article.url}" 
                               class="btn btn-sm btn-outline-secondary"
                               title="Bypass Paywall" 
                               target="_blank">
                                <i class="fas fa-unlock"></i>
                            </a>
                            <a href="https://archive.is/${alert.article.url}" 
                               class="btn btn-sm btn-outline-secondary"
                               title="Archive" 
                               target="_blank">
                                <i class="fas fa-archive"></i>
                            </a>
                        </div>
                    </div>
                </td>
            </tr>
        `;
    }
    
    // If there are no alerts, show the "no alerts" message
    if (data.alerts.length === 0) {
        // Handle nested card structure
        const nestedCard = card.querySelector('.card.mb-4');
        if (nestedCard) {
            // Replace the nested card content
            nestedCard.innerHTML = `
                <div class="card-body">
                    <div class="alert alert-info mb-0">
                        <i class="fas fa-info-circle"></i> No new alerts for this group
                    </div>
                </div>
            `;
        } else {
            // Fallback to card body
            const cardBody = tableBody.closest('.card-body') || card.querySelector('.card-body');
            if (cardBody) {
                cardBody.innerHTML = `
                    <div class="alert alert-info mb-0">
                        <i class="fas fa-info-circle"></i> No new alerts for this group
                    </div>
                `;
            }
        }
    } else {
        tableBody.innerHTML = html;
        
        // Add pagination controls if we have pagination data
        if (data.pagination && data.pagination.total_pages > 1) {
            const tableContainer = tableBody.closest('.table-responsive') || tableBody.closest('div');
            
            // Remove existing pagination if any
            const existingPagination = tableContainer.querySelector('.pagination-controls');
            if (existingPagination) {
                existingPagination.remove();
            }
            
            // Create pagination controls
            const paginationHtml = `
                <div class="pagination-controls d-flex justify-content-between align-items-center mt-3 p-3 bg-light rounded">
                    <div class="pagination-info">
                        <span class="text-muted">
                            Page ${data.pagination.page} of ${data.pagination.total_pages}
                            (${data.total_count} total alerts)
                        </span>
                    </div>
                    <nav aria-label="Alert pagination">
                        <ul class="pagination mb-0">
                            <li class="page-item ${!data.pagination.has_prev ? 'disabled' : ''}">
                                <a class="page-link" href="#" 
                                   onclick="changePage('${data.topic}', ${groupId}, ${data.pagination.page - 1}); return false;"
                                   ${!data.pagination.has_prev ? 'tabindex="-1" aria-disabled="true"' : ''}>
                                    <i class="fas fa-chevron-left"></i> Previous
                                </a>
                            </li>
                            ${generatePageNumbers(data.pagination.page, data.pagination.total_pages, data.topic, groupId)}
                            <li class="page-item ${!data.pagination.has_next ? 'disabled' : ''}">
                                <a class="page-link" href="#" 
                                   onclick="changePage('${data.topic}', ${groupId}, ${data.pagination.page + 1}); return false;"
                                   ${!data.pagination.has_next ? 'tabindex="-1" aria-disabled="true"' : ''}>
                                    Next <i class="fas fa-chevron-right"></i>
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <div class="page-size-selector">
                        <label class="me-2 mb-0">Show:</label>
                        <select class="form-select form-select-sm" style="width: auto; display: inline-block;"
                                onchange="changePageSize('${data.topic}', ${groupId}, this.value)">
                            <option value="25" ${data.pagination.page_size === 25 ? 'selected' : ''}>25</option>
                            <option value="50" ${data.pagination.page_size === 50 ? 'selected' : ''}>50</option>
                            <option value="100" ${data.pagination.page_size === 100 ? 'selected' : ''}>100</option>
                            <option value="200" ${data.pagination.page_size === 200 ? 'selected' : ''}>200</option>
                        </select>
                    </div>
                </div>
            `;
            
            // Insert pagination after the table
            tableContainer.insertAdjacentHTML('beforeend', paginationHtml);
        }
    }
    
    // Update the total count in toggle label
    const totalCount = card.querySelector('.total-count');
    if (totalCount) {
        totalCount.textContent = data.total_count;
    }
    
    // Update bulk action buttons only if we have alerts
    if (data.alerts.length > 0) {
    updateBulkButtons(data.topic, groupId);
    }
}

// Update markAsUnread to pass the correct showRead state
async function markAsUnread(alertId) {
    try {
        const response = await fetch(`/api/keyword-monitor/alerts/${alertId}/unread`, {
            method: 'POST',
            credentials: 'same-origin'
        });
        
        if (!response.ok) throw new Error('Failed to mark alert as unread');
        
        const alertElement = document.querySelector(`[onclick*="${alertId}"]`);
        const groupElement = alertElement.closest('.card');
        const buttonContainer = groupElement.querySelector('.d-flex[data-group-id]');
        const topic = alertElement.dataset.topic;
        const groupId = buttonContainer.dataset.groupId;
        const toggle = document.querySelector(`#showReadToggle_${groupId}`);
        
        await refreshGroupArticles(topic, groupId, toggle.checked);
    } catch (error) {
        console.error('Error:', error);
        showAlert('Failed to mark alert as unread', 'danger');
    }
}

$(document).ready(function() {
    // Fetch monitor status on page load
    fetchMonitorStatus();
    
    // Set interval to refresh status every 30 seconds
    setInterval(fetchMonitorStatus, 30000);
    
    // Initialize other components here...
});

function fetchMonitorStatus() {
    fetch('/api/keyword-monitor/status', {
        credentials: 'same-origin'
    })
        .then(response => response.json())
        .then(data => {
            // Update next check time in the header
            updateStatusDisplay(data);
        })
        .catch(error => {
            console.error("Error fetching monitor status:", error);
        });
}

function updateStatusDisplay(data) {
    const bgTask = data.background_task;
    const settings = data.settings;
    
    // Update last check time
    if (bgTask.last_check_time) {
        const lastCheckElem = document.querySelector('.fas.fa-clock').parentElement;
        if (lastCheckElem) {
            // Format consistently with next check time
            const lastCheck = new Date(bgTask.last_check_time);
            const now = new Date();
            const diffMs = now - lastCheck;
            
            if (diffMs < 60000) { // Less than a minute
                lastCheckElem.innerHTML = `<i class="fas fa-clock"></i> Last check: Less than a minute ago`;
            } else if (diffMs < 3600000) { // Less than an hour
                const minutes = Math.floor(diffMs / 60000);
                lastCheckElem.innerHTML = `<i class="fas fa-clock"></i> Last check: ${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            } else {
                const hours = Math.floor(diffMs / 3600000);
                lastCheckElem.innerHTML = `<i class="fas fa-clock"></i> Last check: ${hours} hour${hours > 1 ? 's' : ''} ago`;
            }
        }
    }
    
    // Update next check time (keep the minutes format since it's more precise for upcoming events)
    if (bgTask.next_check_time) {
        const nextCheckElem = document.querySelector('.fas.fa-hourglass-half').parentElement;
        if (nextCheckElem) {
            const now = new Date();
            const nextCheck = new Date(bgTask.next_check_time);
            
            if (settings.is_enabled) {
                if (nextCheck <= now) {
                    nextCheckElem.innerHTML = `<i class="fas fa-hourglass-half"></i> Checking soon...`;
                } else {
                    const timeDiff = nextCheck - now;
                    if (timeDiff <= 60000) { // Less than a minute
                        nextCheckElem.innerHTML = `<i class="fas fa-hourglass-half"></i> Next check: In less than a minute`;
                    } else if (timeDiff < 3600000) { // Less than an hour
                        const minutes = Math.floor(timeDiff / 60000);
                        nextCheckElem.innerHTML = `<i class="fas fa-hourglass-half"></i> Next check: In ${minutes} minute${minutes > 1 ? 's' : ''}`;
                    } else {
                        const hours = Math.floor(timeDiff / 3600000);
                        nextCheckElem.innerHTML = `<i class="fas fa-hourglass-half"></i> Next check: In ${hours} hour${hours > 1 ? 's' : ''}`;
                    }
                }
            } else {
                nextCheckElem.innerHTML = `<i class="fas fa-hourglass-half"></i> Polling disabled`;
            }
        }
    }
    
    // Update error message if there is one
    if (bgTask.last_error) {
        const lastErrorElem = document.querySelector('.fas.fa-exclamation-circle')?.parentElement;
        if (lastErrorElem) {
            lastErrorElem.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${bgTask.last_error}`;
            lastErrorElem.style.display = 'inline-flex';
        }
    } else {
        const lastErrorElem = document.querySelector('.fas.fa-exclamation-circle')?.parentElement;
        if (lastErrorElem) {
            lastErrorElem.style.display = 'none';
        }
    }
    
    // Update polling toggle status
    const pollingToggle = document.getElementById('pollingToggle');
    if (pollingToggle) {
        pollingToggle.checked = settings.is_enabled;
        const label = document.querySelector('label[for="pollingToggle"]');
        if (label) {
            label.textContent = `Auto-polling ${settings.is_enabled ? 'enabled' : 'disabled'}`;
        }
    }
    
    // Update API usage
    if (data.api_usage) {
        const resetTimer = document.getElementById('resetTimer');
        const rateLimitWarning = document.getElementById('rateLimitWarning');
        
        if (resetTimer) {
            const percentage = (data.api_usage.requests_today / data.api_usage.limit) * 100;
            resetTimer.innerHTML = `<i class="fas fa-refresh"></i> API usage: ${data.api_usage.requests_today}/${data.api_usage.limit}`;
            
            if (percentage >= 100) {
                resetTimer.classList.add('text-danger');
                resetTimer.classList.remove('text-warning', 'text-muted');
                
                // Show rate limit warning
                if (rateLimitWarning) {
                    rateLimitWarning.style.display = 'inline';
                }
            } else if (percentage >= 80) {
                resetTimer.classList.add('text-warning');
                resetTimer.classList.remove('text-danger', 'text-muted');
                
                // Hide rate limit warning
                if (rateLimitWarning) {
                    rateLimitWarning.style.display = 'none';
                }
            } else {
                resetTimer.classList.add('text-muted');
                resetTimer.classList.remove('text-danger', 'text-warning');
                
                // Hide rate limit warning
                if (rateLimitWarning) {
                    rateLimitWarning.style.display = 'none';
                }
            }
        }
    }
}

// Update the reset timer function to properly display when API usage will reset
function updateResetTimer() {
    // Get current time in UTC/GMT
    const now = new Date();
    
    // Create tomorrow's date at midnight UTC (when API counter resets)
    const tomorrow = new Date(now);
    tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);
    tomorrow.setUTCHours(0, 0, 0, 0);
    
    const timeUntilReset = tomorrow - now;
    const hours = Math.floor(timeUntilReset / (1000 * 60 * 60));
    const minutes = Math.floor((timeUntilReset % (1000 * 60 * 60)) / (1000 * 60));
    
    const resetTimer = document.getElementById('resetTimer');
    if (resetTimer) {
        // Get current API usage if available
        const usageText = resetTimer.dataset.usage || '';
        resetTimer.innerHTML = `<i class="fas fa-refresh"></i> ${usageText} (Resets in ${hours}h ${minutes}m)`;
        
        // Update color based on API usage status
        if (resetTimer.dataset.status === 'danger') {
            resetTimer.classList.add('text-danger');
        } else if (resetTimer.dataset.status === 'warning') {
            resetTimer.classList.add('text-warning');
        } else {
            resetTimer.classList.remove('text-danger', 'text-warning');
        }
    }
}

// Fetch current API usage periodically
function fetchApiUsage() {
    fetch('/api/keyword-monitor/status', {
        credentials: 'same-origin'
    })
        .then(response => response.json())
        .then(data => {
            if (data.api_usage) {
                const resetTimer = document.getElementById('resetTimer');
                if (resetTimer) {
                    const usage = data.api_usage.requests_today;
                    const limit = data.api_usage.limit;
                    const percentage = (usage / limit) * 100;
                    
                    // Store the usage text for the reset timer
                    resetTimer.dataset.usage = `API usage: ${usage}/${limit}`;
                    
                    // Update status for coloring
                    if (percentage >= 100) {
                        resetTimer.dataset.status = 'danger';
                    } else if (percentage >= 80) {
                        resetTimer.dataset.status = 'warning';
                    } else {
                        resetTimer.dataset.status = 'normal';
                    }
                    
                    // Update the timer display
                    updateResetTimer();
                }
            }
        })
        .catch(error => console.error('Error fetching API usage:', error));
}

// Function to manually reset the API counter
async function resetApiCounter() {
    if (!confirm("Are you sure you want to manually reset the API counter? This should only be needed if the automatic daily reset isn't working.")) {
            return;
        }
        
    try {
        const response = await fetch('/api/keyword-monitor/reset-api-counter', {
            method: 'POST',
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error('Failed to reset API counter');
        }
        
        const result = await response.json();
        showAlert(`API counter reset successfully: ${result.message}`, 'success');
        
        // Refresh the API usage display
        fetchApiUsage();
    } catch (error) {
        console.error('Error:', error);
        showAlert('Failed to reset API counter: ' + error.message, 'danger');
    }
}

// Handle smooth scrolling to keyword groups when manage links are clicked
document.addEventListener('DOMContentLoaded', function() {
    // Check if there's a hash in the URL for group navigation
    if (window.location.hash && window.location.hash.startsWith('#group-')) {
        const groupId = window.location.hash.substring(7); // Remove '#group-'
        const groupElement = document.getElementById(`group-${groupId}`);
        if (groupElement) {
            setTimeout(() => {
                groupElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Add a highlight effect
                groupElement.style.boxShadow = '0 0 20px rgba(255, 105, 180, 0.5)';
                setTimeout(() => {
                    groupElement.style.boxShadow = '';
                }, 3000);
            }, 500);
        }
    }
    
    // Enhanced tooltip system for better multi-screen support
    initializeTooltips();
});

// Initialize enhanced tooltip system
function initializeTooltips() {
    // Create a tooltip container
    const tooltipContainer = document.createElement('div');
    tooltipContainer.id = 'tooltip-container';
    tooltipContainer.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.8rem;
        max-width: 300px;
        word-wrap: break-word;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        display: none;
    `;
    document.body.appendChild(tooltipContainer);
    
    // Add event listeners to all elements with title attributes
    document.addEventListener('mouseover', function(e) {
        const element = e.target.closest('[title]');
        if (element && element.title) {
            showTooltip(element, element.title, e);
        }
    });
    
    document.addEventListener('mouseout', function(e) {
        const element = e.target.closest('[title]');
        if (element) {
            hideTooltip();
        }
    });
    
    document.addEventListener('mousemove', function(e) {
        const tooltip = document.getElementById('tooltip-container');
        if (tooltip.style.display === 'block') {
            positionTooltip(tooltip, e);
        }
    });
}

function showTooltip(element, text, event) {
    const tooltip = document.getElementById('tooltip-container');
    tooltip.textContent = text;
    tooltip.style.display = 'block';
    positionTooltip(tooltip, event);
    setTimeout(() => {
        tooltip.style.opacity = '1';
    }, 10);
}

function hideTooltip() {
    const tooltip = document.getElementById('tooltip-container');
    tooltip.style.opacity = '0';
    setTimeout(() => {
        tooltip.style.display = 'none';
    }, 200);
}

function positionTooltip(tooltip, event) {
    const rect = tooltip.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    let x = event.clientX + 10;
    let y = event.clientY - rect.height - 10;
    
    // Adjust if tooltip would go off-screen horizontally
    if (x + rect.width > viewportWidth) {
        x = event.clientX - rect.width - 10;
    }
    
    // Adjust if tooltip would go off-screen vertically
    if (y < 0) {
        y = event.clientY + 10;
    }
    
    // Ensure tooltip stays within viewport bounds
    x = Math.max(10, Math.min(x, viewportWidth - rect.width - 10));
    y = Math.max(10, Math.min(y, viewportHeight - rect.height - 10));
    
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
}

// After initializing reset timer and media bias enhancement
// Automatically refresh each group once to ensure status badges are correct on first load
async function initialRefreshGroups() {
    const toggles = document.querySelectorAll('.show-read-toggle');
    for (const toggle of toggles) {
        const topic = toggle.dataset.topic;
        const groupId = toggle.dataset.groupId;
        if (!topic || !groupId) continue;
        try {
            // Check if the group has any alerts before refreshing
            const groupCard = document.querySelector(`#group-${groupId}`);
            if (groupCard) {
                // Check if it has the "no alerts" message
                const hasNoAlerts = groupCard.querySelector('.alert.alert-info');
                if (hasNoAlerts && hasNoAlerts.textContent.includes('No new alerts')) {
                    console.log(`Group ${groupId} has no alerts, skipping initial refresh`);
                    continue;
                }
            }
            await refreshGroupArticles(topic, groupId, toggle.checked, true);
        } catch (err) {
            console.error('Initial refresh error for group', groupId, err);
        }
    }
}
// Give the page a short moment to render, then trigger the refresh
setTimeout(initialRefreshGroups, 100);
</script>
{% endblock %} 