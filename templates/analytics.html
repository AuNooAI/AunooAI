{% extends "base.html" %}
{% block title %}FNA - Analytics{% endblock %}
{% block content %}
<style>
    :root {
        --primary-color: #FF69B4;  /* Hot Pink */
        --primary-dark: #FF1493;   /* Deep Pink */
        --secondary-color: #32CD32;  /* Lime Green */
        --secondary-dark: #228B22;   /* Forest Green */
        --text-color: #333;
        --light-gray: #f8f9fa;
        --medium-gray: #e9ecef;
        --dark-gray: #343a40;
    }

    body {
        background-color: var(--light-gray);
        color: var(--text-color);
    }

    .container-fluid {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    h1, h2, h5 {
        color: var(--primary-color);
        margin-bottom: 20px;
    }

    .card {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        padding: 20px;
        border: 1px solid var(--primary-color);
    }

    .form-select {
        width: 100%;
        padding: 8px;
        margin-bottom: 15px;
        border: 1px solid var(--primary-color);
        border-radius: 4px;
    }

    .form-select:focus {
        border-color: var(--primary-dark);
        box-shadow: 0 0 0 0.2rem rgba(255, 105, 180, 0.25);
    }

    #articleCount {
        color: var(--primary-color);
    }
</style>

<div class="container-fluid mt-5">
    <h1>Analytics Dashboard</h1>
    
    <div class="row mb-3">
        <div class="col-md-4">
            <select id="timeframeSelector" class="form-select">
                <option value="1">Last 24 hours</option>
                <option value="3">Last 3 days</option>
                <option value="7">Last 7 days</option>
                <option value="30">Last 30 days</option>
                <option value="90">Last 90 days</option>
                <option value="all">All time</option>
            </select>
        </div>
        <div class="col-md-4">
            <select id="categorySelector" class="form-select">
                <option value="all">All Categories</option>
            </select>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Total Articles</h5>
                    <p id="articleCount" class="card-text display-4">0</p>
                </div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-md-6">
            <div class="card">
                <h5>Sentiment Distribution (Pie Chart)</h5>
                <div id="sentimentDistributionPie"></div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card">
                <h5>Sentiment Distribution (Bar Chart)</h5>
                <div id="sentimentDistributionBar"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-md-6">
            <div class="card">
                <h5>Time to Impact Distribution (Pie Chart)</h5>
                <div id="timeToImpactPie"></div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card">
                <h5>Time to Impact Distribution (Bar Chart)</h5>
                <div id="timeToImpactBar"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-md-6">
            <div class="card">
                <h5>Future Signal Distribution (Pie Chart)</h5>
                <div id="futureSignalPie"></div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card">
                <h5>Future Signal Distribution (Bar Chart)</h5>
                <div id="futureSignalBar"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <h5>Sentiment Distribution Across Categories</h5>
                <div id="sentimentByCategory"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <h5>Future Signal Distribution Across Categories</h5>
                <div id="futureSignalByCategory"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <h5>Articles Mapped by Future Signal and Sentiment</h5>
                <div id="articlesBubbleChart"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <h5>Articles Mapped by Future Signal and Time to Impact</h5>
                <div id="articlesFutureTimeBubbleChart"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <h5>Radar Chart of Articles by Future Signal, Sentiment, and Time to Impact</h5>
                <div id="radarChart"></div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <h5>Integrated Analysis: Driver Type, Time Impact, Sentiment, and Future Signal</h5>
                <div id="integratedAnalysisChart"></div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const timeframeSelector = document.getElementById('timeframeSelector');
    const categorySelector = document.getElementById('categorySelector');
    const articleCountElement = document.getElementById('articleCount');

    // Fetch categories and populate the dropdown
    fetch('/api/categories')
        .then(response => response.json())
        .then(categories => {
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelector.appendChild(option);
            });
        })
        .catch(error => console.error('Error fetching categories:', error));

    function updateCharts() {
        const timeframe = timeframeSelector.value;
        const category = categorySelector.value;
        fetchDataAndUpdateCharts(timeframe, category);
    }

    timeframeSelector.addEventListener('change', updateCharts);
    categorySelector.addEventListener('change', updateCharts);

    updateCharts();
});

async function fetchDataAndUpdateCharts(timeframe, category) {
    try {
        const response = await fetch(`/api/analytics?timeframe=${timeframe}&category=${category}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        updateRadarChart(data.radarChartData);
        updateSentimentDistribution(data.sentimentDistribution);
        updateTimeToImpactDistribution(data.timeToImpactDistribution);
        updateFutureSignalDistribution(data.futureSignalDistribution);
        updateSentimentByCategory(data.sentimentByCategory);
        updateFutureSignalByCategory(data.futureSignalByCategory);
        updateArticlesBubbleChart(data.articlesBubbleChart);
        updateArticlesFutureTimeBubbleChart(data.articlesFutureTimeBubbleChart);
        updateArticleCount(data.totalArticles);
        createIntegratedAnalysisChart(data.integratedAnalysis);
    } catch (error) {
        console.error('Error fetching analytics data:', error);
    }
}

function updateSentimentDistribution(data) {
    const orderedSentiments = ['Positive', 'Neutral', 'Negative', 'Critical', 'Mixed'];
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#9782ad',   // Lilac
        'Negative': '#f05b06',  // Red Orange
        'Critical': '#ff0080',  // Fuchsia
        'Mixed': '#432f70'      // Indigo
    };

    // Create ordered arrays for labels, values, and colors
    const orderedLabels = [];
    const orderedValues = [];
    const orderedColors = [];

    orderedSentiments.forEach(sentiment => {
        const index = data.labels.indexOf(sentiment);
        if (index !== -1) {
            orderedLabels.push(sentiment);
            orderedValues.push(data.values[index]);
            orderedColors.push(colors[sentiment]);
        }
    });

    // Pie Chart
    Plotly.newPlot('sentimentDistributionPie', [{
        values: orderedValues,
        labels: orderedLabels,
        type: 'pie',
        marker: {
            colors: orderedColors
        }
    }], {
        title: 'Sentiment Distribution (Pie Chart)'
    });

    // Bar Chart
    Plotly.newPlot('sentimentDistributionBar', [{
        x: data.labels,
        y: data.values,
        type: 'bar',
        marker: {
            color: data.labels.map(label => colors[label] || 'gray')
        }
    }], {
        title: 'Sentiment Distribution (Bar Chart)',
        xaxis: { title: 'Sentiment' },
        yaxis: { title: 'Count' }
    });
}

function updateTimeToImpactDistribution(data) {
    console.log("Time to Impact Distribution data:", data);

    const orderedTimeToImpact = ['Immediate', 'Short-term', 'Mid-term', 'Long-term'];
    const colors = {
        'Immediate': '#FF1493',  // Deep Pink
        'Short-term': '#f05b06',  // Red Orange
        'Mid-term': '#32CD32',   // Lime Green
        'Long-term': '#9782ad'   // Lilac
    };

    // Create ordered arrays for labels, values, and colors
    const orderedLabels = [];
    const orderedValues = [];
    const orderedColors = [];

    orderedTimeToImpact.forEach(tti => {
        const index = data.labels.findIndex(label => label.toLowerCase() === tti.toLowerCase());
        if (index !== -1) {
            orderedLabels.push(data.labels[index]);
            orderedValues.push(data.values[index]);
            orderedColors.push(colors[tti] || 'gray');
        }
    });

    // Add any remaining categories that weren't in our predefined order
    data.labels.forEach((label, index) => {
        if (!orderedLabels.includes(label)) {
            orderedLabels.push(label);
            orderedValues.push(data.values[index]);
            orderedColors.push('gray');
        }
    });

    console.log("Ordered data:", { labels: orderedLabels, values: orderedValues, colors: orderedColors });

    // Pie Chart
    Plotly.newPlot('timeToImpactPie', [{
        values: orderedValues,
        labels: orderedLabels,
        type: 'pie',
        marker: {
            colors: orderedColors
        }
    }], {
        title: 'Time to Impact Distribution (Pie Chart)'
    });

    // Bar Chart
    Plotly.newPlot('timeToImpactBar', [{
        x: orderedLabels,
        y: orderedValues,
        type: 'bar',
        marker: {
            color: orderedColors
        }
    }], {
        title: 'Time to Impact Distribution (Bar Chart)',
        xaxis: { title: 'Time to Impact' },
        yaxis: { title: 'Count' }
    });
}

function updateFutureSignalDistribution(data) {
    console.log("Future Signal Distribution data:", data);

    const orderedFutureSignals = ['AI will accelerate', 'AI will evolve gradually', 'AI is hype', 'AI has plateaued'];
    const colors = {
        'AI will accelerate': '#FF1493',      // Deep Pink
        'AI will evolve gradually': '#32CD32',  // Lime Green
        'AI is hype': '#f05b06',  // Red Orange
        'AI has plateaued': '#9782ad',   // Lilac
        'AI is a bubble': '#432f70'      // Indigo
    };

    // Create ordered arrays for labels, values, and colors
    const orderedLabels = [];
    const orderedValues = [];
    const orderedColors = [];

    orderedFutureSignals.forEach(signal => {
        const index = data.labels.findIndex(label => label.toLowerCase() === signal.toLowerCase());
        if (index !== -1) {
            orderedLabels.push(data.labels[index]);
            orderedValues.push(data.values[index]);
            orderedColors.push(colors[signal] || 'lightgray');
        }
    });

    // Add any remaining categories that weren't in our predefined order
    data.labels.forEach((label, index) => {
        if (!orderedLabels.includes(label)) {
            orderedLabels.push(label);
            orderedValues.push(data.values[index]);
            orderedColors.push('lightgray');
        }
    });

    console.log("Ordered Future Signal data:", { labels: orderedLabels, values: orderedValues, colors: orderedColors });

    // Pie Chart
    Plotly.newPlot('futureSignalPie', [{
        values: orderedValues,
        labels: orderedLabels,
        type: 'pie',
        marker: {
            colors: orderedColors
        }
    }], {
        title: 'Future Signal Distribution (Pie Chart)'
    });

    // Bar Chart
    Plotly.newPlot('futureSignalBar', [{
        x: orderedLabels,
        y: orderedValues,
        type: 'bar',
        marker: {
            color: orderedColors
        }
    }], {
        title: 'Future Signal Distribution (Bar Chart)',
        xaxis: { title: 'Future Signal' },
        yaxis: { title: 'Count' }
    });
}

function updateSentimentByCategory(data) {
    const { categories, sentiments, data: chartData } = data;
    const traces = sentiments.map(sentiment => ({
        x: categories,
        y: categories.map(category => chartData[category][sentiment]),
        name: sentiment,
        type: 'bar'
    }));

    const layout = {
        barmode: 'stack',
        title: 'Sentiment Distribution Across Categories',
        xaxis: { title: 'Category', tickangle: -45 },
        yaxis: { title: 'Number of Articles' },
        legend: { title: 'Sentiment' }
    };

    Plotly.newPlot('sentimentByCategory', traces, layout);
}

function updateFutureSignalByCategory(data) {
    const { categories, future_signals, data: chartData } = data;
    const traces = future_signals.map(signal => ({
        x: categories,
        y: categories.map(category => chartData[category][signal]),
        name: signal,
        type: 'bar'
    }));

    const layout = {
        barmode: 'stack',
        title: 'Future Signal Distribution Across Categories',
        xaxis: { title: 'Category', tickangle: -45 },
        yaxis: { title: 'Number of Articles' },
        legend: { title: 'Future Signal' }
    };

    Plotly.newPlot('futureSignalByCategory', traces, layout);
}

function updateArticlesBubbleChart(data) {
    const futureSignals = ['AI has plateaued', 'AI is hype', 'AI will accelerate', 'AI will evolve gradually'];
    const sentiments = ['Critical', 'Negative', 'Neutral', 'Positive'];
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#9782ad',   // Lilac
        'Negative': '#f05b06',  // Red Orange
        'Critical': '#ff0080',  // Fuchsia
        'Mixed': '#432f70'      // Indigo
    };

    const traces = sentiments.map(sentiment => ({
        x: futureSignals,
        y: new Array(futureSignals.length).fill(sentiment),
        mode: 'markers',
        name: sentiment,
        marker: {
            color: colors[sentiment],
            size: futureSignals.map(signal => {
                const match = data.find(item => item.future_signal === signal && item.sentiment === sentiment);
                return match ? Math.sqrt(match.count) * 25 : 0;
            }),
            sizemode: 'area',
            sizeref: 0.1
        },
        text: futureSignals.map(signal => {
            const match = data.find(item => item.future_signal === signal && item.sentiment === sentiment);
            return match ? `Count: ${match.count}` : 'Count: 0';
        }),
        hoverinfo: 'text'
    }));

    const layout = {
        title: 'Articles Mapped by Future Signal and Sentiment',
        xaxis: { title: 'Future Signal', tickangle: -45 },
        yaxis: { title: 'Sentiment' },
        showlegend: true
    };

    Plotly.newPlot('articlesBubbleChart', traces, layout);
}

function updateArticlesFutureTimeBubbleChart(data) {
    const futureSignals = ['AI has plateaued', 'AI is hype', 'AI will accelerate', 'AI will evolve gradually'];
    const timeToImpacts = ['Immediate', 'Short-term', 'Mid-term', 'Long-term'];
    const colors = {
        'Immediate': '#FF1493',  // Deep Pink
        'Short-term': '#f05b06',  // Red Orange
        'Mid-term': '#32CD32',   // Lime Green
        'Long-term': '#9782ad'   // Lilac

    };

    const traces = timeToImpacts.map(timeToImpact => ({
        x: futureSignals,
        y: new Array(futureSignals.length).fill(timeToImpact),
        mode: 'markers',
        name: timeToImpact,
        marker: {
            color: colors[timeToImpact],
            size: futureSignals.map(signal => {
                const match = data.find(item => item.future_signal === signal && item.time_to_impact === timeToImpact);
                return match ? Math.sqrt(match.count) * 25 : 0;
            }),
            sizemode: 'area',
            sizeref: 0.1
        },
        text: futureSignals.map(signal => {
            const match = data.find(item => item.future_signal === signal && item.time_to_impact === timeToImpact);
            return match ? `Count: ${match.count}` : 'Count: 0';
        }),
        hoverinfo: 'text'
    }));

    const layout = {
        title: 'Articles Mapped by Future Signal and Time to Impact',
        xaxis: { title: 'Future Signal', tickangle: -45 },
        yaxis: { title: 'Time to Impact' },
        showlegend: true
    };

    Plotly.newPlot('articlesFutureTimeBubbleChart', traces, layout);
}

function updateRadarChart(data) {
    const futureSignals = ['AI will evolve gradually', 'AI will accelerate', 'AI has plateaued', 'AI is hype'];
    const sentiments = ['Positive', 'Neutral', 'Negative', 'Critical'];
    const timeToImpacts = ['Immediate', 'Short-term', 'Mid-term', 'Long-term'];
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#9782ad',   // Lilac
        'Negative': '#f05b06',  // Red Orange
        'Critical': '#ff0080',  // Fuchsia
        'Mixed': '#432f70'      // Indigo
    };
    const symbols = {
        'Positive': 'circle',
        'Neutral': 'square',
        'Negative': 'diamond',
        'Critical': 'x'
    };

    const traces = [];

    // Create data traces
    futureSignals.forEach(signal => {
        sentiments.forEach(sentiment => {
            const signalSentimentData = data.filter(item => 
                item.future_signal === signal && 
                item.sentiment === sentiment
            );

            signalSentimentData.forEach(item => {
                const baseR = timeToImpacts.indexOf(item.time_to_impact) + 1;
                const scatter = (Math.random() - 0.5) * 0.8; // Random value between -0.4 and 0.4
                traces.push({
                    type: 'scatterpolar',
                    r: [baseR + scatter],
                    theta: [signal],
                    marker: {
                        color: colors[sentiment],
                        symbol: symbols[sentiment],
                        size: 10
                    },
                    showlegend: false
                });
            });
        });
    });

    // Add concentric circles for time-to-impact stages
    [1, 2, 3, 4].forEach((r, index) => {
        traces.push({
            type: 'scatterpolar',
            r: Array(futureSignals.length + 1).fill(r),
            theta: [...futureSignals, futureSignals[0]],
            mode: 'lines',
            line: {
                color: 'lightgray',
                dash: 'dot'
            },
            showlegend: false,
            hoverinfo: 'none'
        });
    });

    // Create legend traces
    sentiments.forEach(sentiment => {
        traces.push({
            type: 'scatterpolar',
            r: [0],
            theta: [futureSignals[0]],
            name: sentiment,
            marker: {
                color: colors[sentiment],
                symbol: symbols[sentiment],
            },
            showlegend: true
        });
    });

    const layout = {
        title: 'Radar Chart of Articles by Future Signal, Sentiment, and Time to Impact',
        polar: {
            radialaxis: {
                visible: true,
                range: [0, 4.5],
                tickvals: [1, 2, 3, 4],
                ticktext: timeToImpacts,
                tickfont: { size: 8 },
                angle: 90
            },
            angularaxis: {
                tickfont: { size: 10 },
                rotation: 90,
                direction: 'clockwise'
            }
        },
        showlegend: true,
        legend: { 
            orientation: 'h', 
            y: -0.2,
            title: {
                text: 'Sentiment',
                side: 'top'
            }
        }
    };

    Plotly.newPlot('radarChart', traces, layout);
}

function updateArticleCount(count) {
    document.getElementById('articleCount').textContent = count;
}

function createIntegratedAnalysisChart(data) {
    console.log('Creating integrated analysis chart with data:', data);
    if (!data || !Array.isArray(data) || data.length === 0) {
        console.error('Invalid or empty data received for integrated analysis chart');
        document.getElementById('integratedAnalysisChart').innerHTML = 'No data available for the integrated analysis chart.';
        return;
    }

    // Check if all required properties are present
    const requiredProps = ['driver_type', 'time_to_impact', 'sentiment', 'future_signal', 'count'];
    const hasAllProps = data.every(item => requiredProps.every(prop => prop in item));
    if (!hasAllProps) {
        console.error('Data is missing one or more required properties');
        document.getElementById('integratedAnalysisChart').innerHTML = 'Data is incomplete for the integrated analysis chart.';
        return;
    }

    const driverTypes = [...new Set(data.map(item => item.driver_type || 'Unknown'))];
    const timeToImpacts = [...new Set(data.map(item => item.time_to_impact).filter(Boolean))];
    const sentiments = [...new Set(data.map(item => item.sentiment).filter(Boolean))];
    const futureSignals = [...new Set(data.map(item => item.future_signal).filter(Boolean))];

    if (driverTypes.length === 0 || timeToImpacts.length === 0 || sentiments.length === 0 || futureSignals.length === 0) {
        console.error('One or more dimensions have no valid data');
        document.getElementById('integratedAnalysisChart').innerHTML = 'Insufficient data for the integrated analysis chart.';
        return;
    }

    const traces = [];

    driverTypes.forEach(driver => {
        timeToImpacts.forEach(time => {
            const trace = {
                x: sentiments,
                y: futureSignals,
                mode: 'markers',
                name: `${driver} - ${time}`,
                marker: {
                    size: [],
                    sizemode: 'area',
                    sizeref: 2 * Math.max(...data.map(item => item.count || 0)) / (40 ** 2),
                    sizemin: 4
                },
                text: [],
                hoverinfo: 'text'
            };

            sentiments.forEach(sentiment => {
                futureSignals.forEach(signal => {
                    const item = data.find(d => 
                        d.driver_type === driver && 
                        d.time_to_impact === time && 
                        d.sentiment === sentiment && 
                        d.future_signal === signal
                    );

                    if (item) {
                        trace.marker.size.push(item.count || 0);
                        trace.text.push(`Driver: ${driver}<br>Time: ${time}<br>Sentiment: ${sentiment}<br>Signal: ${signal}<br>Count: ${item.count || 0}`);
                    } else {
                        trace.marker.size.push(0);
                        trace.text.push('');
                    }
                });
            });

            traces.push(trace);
        });
    });

    const layout = {
        title: 'Integrated Analysis',
        xaxis: { title: 'Sentiment' },
        yaxis: { title: 'Future Signal' },
        hovermode: 'closest',
        showlegend: true,
        height: 600,
        width: 1000
    };

    Plotly.newPlot('integratedAnalysisChart', traces, layout);
}

function updateCharts() {
    const timeframe = timeframeSelector.value;
    const category = categorySelector.value;

    console.log(`Fetching integrated analysis data for timeframe: ${timeframe}, category: ${category}`);

    fetch(`/api/integrated_analysis?timeframe=${timeframe}&category=${category}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Received data for integrated analysis:', data);
            if (data.error) {
                throw new Error(data.error);
            }
            createIntegratedAnalysisChart(data);
        })
        .catch(error => {
            console.error('Error fetching or processing integrated analysis data:', error);
            document.getElementById('integratedAnalysisChart').innerHTML = `Error loading the integrated analysis chart: ${error.message}`;
        });

    // ... rest of the updateCharts function ...
}

timeframeSelector.addEventListener('change', updateCharts);
categorySelector.addEventListener('change', updateCharts);

updateCharts();
</script>
{% endblock %}
