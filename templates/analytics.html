{% extends "base_with_shared_nav.html" %}
{% block title %}Analytics - Aunoo{% endblock %}
{% block content %}
<div class="analytics-container">
    <!-- Breadcrumb Header -->
    <div class="page-breadcrumb-header">
        <div class="breadcrumb-text">
            <span>Settings</span>
            <span>/</span>
            <span class="font-medium">Analytics</span>
            <span>â€¢</span>
            <span>Data visualization and insights</span>
        </div>
        <div class="page-header-actions">
            <button type="button" class="btn btn-icon" title="Notifications">
                <i class="far fa-bell"></i>
            </button>
            <button class="btn-topic-setup" onclick="window.location.href='/onboarding?redo=true'" title="Set up a new topic">
                <span>Set up topic</span>
                <i class="fas fa-plus"></i>
            </button>
        </div>
    </div>

    <!-- Scrollable Content Area -->
    <div class="analytics-scrollable">

<style>
    :root {
        --primary-color: var(--colors-accent-7);  /* Hot Pink */
        --primary-dark: var(--colors-accent-10);   /* Deep Pink */
        --secondary-color: #32CD32;  /* Lime Green */
        --secondary-dark: #228B22;   /* Forest Green */
        --text-color: var(--colors-neutral-11);
        --light-gray: var(--colors-neutral-2);
        --medium-gray: var(--colors-neutral-4);
        --dark-gray: var(--colors-neutral-10);
    }

    body {
        background-color: var(--light-gray);
        color: var(--text-color);
    }

    .container-fluid {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
    }

    h1, h2, h5 {
        color: var(--primary-color);
        margin-bottom: 20px;
    }

    .card {
        background-color: var(--colors-white);
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        padding: 20px;
        border: 1px solid var(--primary-color);
    }

    .form-select {
        width: 100%;
        padding: 8px;
        margin-bottom: 15px;
        border: 1px solid var(--primary-color);
        border-radius: 4px;
    }

    /* Multiple select styling */
    select[multiple] {
        height: auto;
        min-height: 100px;
    }
    
    select[multiple] option {
        padding: 8px;
        margin: 2px 0;
        border-radius: 3px;
    }
    
    select[multiple] option:checked {
        background-color: var(--primary-color) !important;
        color: white;
    }

    .form-select:focus {
        border-color: var(--primary-dark);
        box-shadow: 0 0 0 0.2rem rgba(255, 105, 180, 0.25);
    }

    #articleCount {
        color: var(--primary-color);
    }

    /* Dropdown styling */
    .dropdown-menu {
        max-height: 300px;
        overflow-y: auto;
    }

    .dropdown-item.active, 
    .dropdown-item:active {
        background-color: var(--primary-color);
    }

    .multiselect-dropdown {
        position: relative;
    }

    .multiselect-dropdown .selected-items {
        margin-top: 5px;
    }

    .multiselect-dropdown .selected-items .badge {
        margin-right: 3px;
        margin-bottom: 3px;
        background-color: var(--primary-color);
    }

    /* Smaller summary cards */
    .summary-card {
        padding: 10px;
    }

    .summary-card .card-title {
        font-size: 0.9rem;
        margin-bottom: 5px;
    }

    .summary-card .display-4 {
        font-size: 1.8rem;
        font-weight: bold;
    }

    .summary-card small {
        font-size: 0.75rem;
    }
    
    /* Tab styling */
    .nav-tabs .nav-link {
        color: var(--dark-gray);
        border: 1px solid transparent;
        border-top-left-radius: 0.25rem;
        border-top-right-radius: 0.25rem;
        padding: 0.5rem 1rem;
        margin-right: 0.25rem;
    }
    
    .nav-tabs .nav-link.active {
        color: var(--primary-color);
        background-color: var(--colors-white);
        border-color: var(--colors-neutral-5) var(--colors-neutral-5) var(--colors-white);
        font-weight: bold;
    }
    
    .tab-content {
        padding-top: 1rem;
    }
    
    /* Flow chart specific styles */
    .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 1rem;
    }
    
    .filter-box {
        min-width: 160px;
    }
    
    .filter-panel {
        background-color: var(--light-gray);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .filter-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 15px;
        margin-bottom: 0;
    }
</style>

<div class="container-fluid mt-4">
    <h2 class="mb-3">Analytics Dashboard</h2>
    
    <!-- Tab Navigation -->
    <ul class="nav nav-tabs mb-4" id="analyticsTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="charts-tab" data-bs-toggle="tab" data-bs-target="#charts" type="button" role="tab" aria-controls="charts" aria-selected="true">Charts</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="flow-tab" data-bs-toggle="tab" data-bs-target="#flow" type="button" role="tab" aria-controls="flow" aria-selected="false">Follow the Flow</button>
        </li>
    </ul>
    
    <div class="tab-content" id="analyticsTabsContent">
        <!-- Charts Tab -->
        <div class="tab-pane fade show active" id="charts" role="tabpanel" aria-labelledby="charts-tab">
            <!-- Primary Controls -->
            <div class="row mb-4">
                <div class="col-md-3">
                    <label for="topicSelect">Select Topic</label>
                    <select class="form-select" id="topicSelect">
                        <option value="">Select a topic</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label for="categorySelect">Category</label>
                    <div class="multiselect-dropdown">
                        <button class="btn btn-outline-secondary dropdown-toggle form-select text-start" type="button" id="categoryDropdown" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                            Select Categories
                        </button>
                        <ul class="dropdown-menu w-100" id="categorySelect" aria-labelledby="categoryDropdown">
                            <li><a class="dropdown-item" href="#" data-value="all">All Categories</a></li>
                        </ul>
                        <div class="selected-items" id="selectedCategories"></div>
                    </div>
                </div>
                <div class="col-md-3">
                    <label for="timeframeSelect">Timeframe</label>
                    <select class="form-select" id="timeframeSelect">
                        <option value="7">Last 7 days</option>
                        <option value="30">Last 30 days</option>
                        <option value="90">Last 90 days</option>
                        <option value="180">Last 180 days</option>
                        <option value="365">Last year</option>
                        <option value="all" selected>All time</option>
                    </select>
                </div>
                <div class="col-md-3 d-flex align-items-end">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="curatedCheckbox" checked />
                        <label class="form-check-label" for="curatedCheckbox">
                            Only Curated
                        </label>
                    </div>
                </div>
            </div>

            <!-- Secondary Filters - now including Sentiment -->
            <div class="row mb-4">
                <div class="col-md-4">
                    <label for="sentimentSelect">Sentiment</label>
                    <div class="multiselect-dropdown">
                        <button class="btn btn-outline-secondary dropdown-toggle form-select text-start" type="button" id="sentimentDropdown" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                            Select Sentiments
                        </button>
                        <ul class="dropdown-menu w-100" id="sentimentSelect" aria-labelledby="sentimentDropdown">
                            <li><a class="dropdown-item" href="#" data-value="all">All Sentiments</a></li>
                        </ul>
                        <div class="selected-items" id="selectedSentiments"></div>
                    </div>
                </div>
                <div class="col-md-4">
                    <label for="impactSelect">Time to Impact</label>
                    <div class="multiselect-dropdown">
                        <button class="btn btn-outline-secondary dropdown-toggle form-select text-start" type="button" id="impactDropdown" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                            Select Time to Impact
                        </button>
                        <ul class="dropdown-menu w-100" id="impactSelect" aria-labelledby="impactDropdown">
                            <li><a class="dropdown-item" href="#" data-value="all">All Time to Impact</a></li>
                        </ul>
                        <div class="selected-items" id="selectedImpacts"></div>
                    </div>
                </div>
                <div class="col-md-4">
                    <label for="driverTypeSelect">Driver Type</label>
                    <div class="multiselect-dropdown">
                        <button class="btn btn-outline-secondary dropdown-toggle form-select text-start" type="button" id="driverTypeDropdown" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                            Select Driver Types
                        </button>
                        <ul class="dropdown-menu w-100" id="driverTypeSelect" aria-labelledby="driverTypeDropdown">
                            <li><a class="dropdown-item" href="#" data-value="all">All Driver Types</a></li>
                        </ul>
                        <div class="selected-items" id="selectedDriverTypes"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-3">
                <div class="col-md-3 col-sm-6">
                    <div class="card summary-card">
                        <div class="card-body">
                            <h5 class="card-title">Total Articles</h5>
                            <p id="articleCount" class="card-text display-4">0</p>
                        </div>
                    </div>
                </div>
                <div class="col-md-3 col-sm-6">
                    <div class="card summary-card">
                        <div class="card-body">
                            <h5 class="card-title">Top Sentiment</h5>
                            <p id="topSentiment" class="card-text display-4">-</p>
                            <small id="topSentimentCount" class="text-muted">0 articles</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3 col-sm-6">
                    <div class="card summary-card">
                        <div class="card-body">
                            <h5 class="card-title">Top Future Signal</h5>
                            <p id="topFutureSignal" class="card-text display-4">-</p>
                            <small id="topFutureSignalCount" class="text-muted">0 articles</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3 col-sm-6">
                    <div class="card summary-card">
                        <div class="card-body">
                            <h5 class="card-title">Top Time to Impact</h5>
                            <p id="topTimeToImpact" class="card-text display-4">-</p>
                            <small id="topTimeToImpactCount" class="text-muted">0 articles</small>
                        </div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card">
                        <h5>Sentiment Distribution (Pie Chart)</h5>
                        <div id="sentimentDistributionPie"></div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card">
                        <h5>Sentiment Distribution (Bar Chart)</h5>
                        <div id="sentimentDistributionBar"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card">
                        <h5>Time to Impact Distribution (Pie Chart)</h5>
                        <div id="timeToImpactPie"></div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card">
                        <h5>Time to Impact Distribution (Bar Chart)</h5>
                        <div id="timeToImpactBar"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card">
                        <h5>Future Signal Distribution (Pie Chart)</h5>
                        <div id="futureSignalPie"></div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card">
                        <h5>Future Signal Distribution (Bar Chart)</h5>
                        <div id="futureSignalBar"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Sentiment Distribution Across Categories</h5>
                        <div id="sentimentByCategory"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Future Signal Distribution Across Categories</h5>
                        <div id="futureSignalByCategory"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Articles Mapped by Future Signal and Sentiment</h5>
                        <div id="articlesBubbleChart"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Articles Mapped by Future Signal and Time to Impact</h5>
                        <div id="articlesFutureTimeBubbleChart"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Radar Chart of Articles by Future Signal, Sentiment, and Time to Impact</h5>
                        <div id="radarChart"></div>
                    </div>
                </div>
            </div>

            <!-- Time-series Charts -->
            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Sentiment Over Time</h5>
                        <div id="sentimentTimeSeries"></div>
                    </div>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <h5>Category Counts Over Time</h5>
                        <div id="categoryStackedBar" style="width:100%; min-height:500px;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Flow Tab -->
        <div class="tab-pane fade" id="flow" role="tabpanel" aria-labelledby="flow-tab">
            <div class="controls">
                <select id="flowTopicSelect" class="form-select" style="max-width:220px;"></select>
                <select id="flowTimeframeSelect" class="form-select" style="max-width:160px;">
                    <option value="all" selected>All time</option>
                    <option value="7">Last 7 days</option>
                    <option value="30">Last 30 days</option>
                    <option value="90">Last 90 days</option>
                </select>
                <input id="topSourcesInput" type="number" value="12" min="3" max="50" class="form-control" title="Top sources count" style="width:120px;"/>
                <select id="colorMode" class="form-select" style="width:180px;">
                    <option value="stage" selected>Colour by stage</option>
                    <option value="source">Colour by source</option>
                    <option value="category">Colour by category</option>
                </select>
                <button id="refreshBtn" class="btn btn-primary">Refresh</button>
            </div>
            <div id="filtersContainer" class="filter-panel">
                <div class="filter-row">
                    <select id="sourceFilter" class="form-select filter-box select2-multiple" multiple title="Filter by source"></select>
                    <select id="categoryFilter" class="form-select filter-box select2-multiple" multiple title="Filter by category"></select>
                    <select id="sentimentFilter" class="form-select filter-box select2-multiple" multiple title="Filter by sentiment"></select>
                    <div class="form-check align-self-center">
                        <input class="form-check-input me-1" type="checkbox" id="includeOtherCheckbox" checked>
                        <label class="form-check-label" for="includeOtherCheckbox">Include "Other sources"</label>
                    </div>
                    <div class="form-check align-self-center">
                        <input class="form-check-input me-1" type="checkbox" id="showCategoryCheckbox" checked>
                        <label class="form-check-label" for="showCategoryCheckbox">Show category stage</label>
                    </div>
                </div>
            </div>
            <div id="sankeyChart" style="width:100%; height:700px;"></div>
        </div>
    </div>
</div>

<!-- Add jQuery and Select2 for Flow Tab -->
<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // First load topics
    loadTopics().then(() => {
        // Check for topic in URL parameters first
        const urlParams = new URLSearchParams(window.location.search);
        const topicFromUrl = urlParams.get('topic');

        // After topics are loaded, restore from URL or localStorage
        const topicToSelect = topicFromUrl || localStorage.getItem('analyticsTopic');
        if (topicToSelect) {
            const topicSelect = document.getElementById('topicSelect');
            topicSelect.value = topicToSelect;
            // Trigger change event to load categories and charts
            topicSelect.dispatchEvent(new Event('change'));
        }
    });
    
    // Add event listeners
    document.getElementById('topicSelect').addEventListener('change', function(event) {
        localStorage.setItem('analyticsTopic', event.target.value);
        handleTopicChange(event);
    });
    document.getElementById('categoryDropdown').addEventListener('change', function(event) {
        localStorage.setItem('analyticsCategory', JSON.stringify(Array.from(event.target.selectedOptions, option => option.value)));
        handleCategoryChange(event);
    });
    document.getElementById('timeframeSelect').addEventListener('change', function(event) {
        localStorage.setItem('analyticsTimeframe', event.target.value);
        handleTimeframeChange(event);
    });
    document.getElementById('curatedCheckbox').addEventListener('change', function() {
        updateCharts();
    });
    document.getElementById('sentimentDropdown').addEventListener('change', function() {
        updateCharts();
    });
    document.getElementById('impactDropdown').addEventListener('change', function() {
        updateCharts();
    });
    document.getElementById('driverTypeDropdown').addEventListener('change', function() {
        updateCharts();
    });
    
    // Initialize Flow Chart
    initFlowChart();
});

let topicOptions = {
    sentiments: [],
    futureSignals: [],
    timeToImpacts: [],
    driverTypes: []
};

function loadTopics() {
    return fetch('/api/topics')
        .then(response => response.json())
        .then(topics => {
            const topicSelect = document.getElementById('topicSelect');
            topicSelect.innerHTML = '<option value="">Select a topic</option>';
            topics.forEach(topic => {
                const option = document.createElement('option');
                option.value = topic.name;
                option.textContent = topic.name;
                topicSelect.appendChild(option);
            });
        })
        .catch(error => console.error('Error loading topics:', error));
}

function handleTopicChange(event) {
    const topicName = event.target.value;
    const categoryDropdown = document.getElementById('categoryDropdown');
    
    if (topicName) {
        // Enable category select and load categories for selected topic
        categoryDropdown.disabled = false;
        loadTopicOptions(topicName).then(() => {
            loadCategoriesForTopic(topicName);
            // Update charts with the new topic (without category)
            updateCharts();
        });
    } else {
        // Disable and clear category select
        categoryDropdown.disabled = true;
        document.getElementById('categorySelect').innerHTML = '<li><a class="dropdown-item" href="#" data-value="all">All Categories</a></li>';
        document.getElementById('selectedCategories').innerHTML = '';
        // Clear all charts
        clearCharts();
    }
}

async function loadTopicOptions(topicName) {
    try {
        const response = await fetch(`/api/topic-options/${encodeURIComponent(topicName)}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const options = await response.json();
        topicOptions = {
            sentiments: options.sentiments,
            futureSignals: options.futureSignals,
            timeToImpacts: options.timeToImpacts,
            driverTypes: options.driverTypes
        };
        populateAdditionalFilters();
        console.log('Loaded topic options:', topicOptions);
    } catch (error) {
        console.error('Error loading topic options:', error);
    }
}

function populateAdditionalFilters() {
    // Enable dropdowns and populate options
    const sentimentDropdown = document.getElementById('sentimentDropdown');
    const impactDropdown = document.getElementById('impactDropdown');
    const driverTypeDropdown = document.getElementById('driverTypeDropdown');
    const sentimentSelect = document.getElementById('sentimentSelect');
    const impactSelect = document.getElementById('impactSelect');
    const driverTypeSelect = document.getElementById('driverTypeSelect');
    
    sentimentDropdown.disabled = false;
    impactDropdown.disabled = false;
    driverTypeDropdown.disabled = false;
    
    // Clear existing dropdown items
    sentimentSelect.innerHTML = '<li><a class="dropdown-item" href="#" data-value="all">All Sentiments</a></li>';
    impactSelect.innerHTML = '<li><a class="dropdown-item" href="#" data-value="all">All Time to Impact</a></li>';
    driverTypeSelect.innerHTML = '<li><a class="dropdown-item" href="#" data-value="all">All Driver Types</a></li>';
    
    // Add new items and setup event listeners
    function setupDropdown(dropdownElem, values, selectedContainerId) {
        const selectedContainer = document.getElementById(selectedContainerId);
        selectedContainer.innerHTML = '';
        
        // Add items to dropdown
        values.forEach(value => {
            const item = document.createElement('li');
            const link = document.createElement('a');
            link.className = 'dropdown-item';
            link.href = '#';
            link.dataset.value = value;
            link.textContent = value;
            
            link.addEventListener('click', function(e) {
                e.preventDefault();
                
                // Handle "All" selection
                if (value === 'all') {
                    selectedContainer.innerHTML = '';
                    updateCharts();
                    return;
                }
                
                // Toggle selection
                const existingBadge = document.querySelector(`#${selectedContainerId} .badge[data-value="${value}"]`);
                
                if (existingBadge) {
                    // Remove if already selected
                    existingBadge.remove();
                } else {
                    // Add if not selected
                    const badge = document.createElement('span');
                    badge.className = 'badge';
                    badge.dataset.value = value;
                    badge.textContent = value;
                    
                    // Add remove button
                    const removeBtn = document.createElement('span');
                    removeBtn.innerHTML = '&times;';
                    removeBtn.className = 'ms-1';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.addEventListener('click', function() {
                        badge.remove();
                        updateCharts();
                    });
                    
                    badge.appendChild(removeBtn);
                    selectedContainer.appendChild(badge);
                }
                
                updateCharts();
            });
            
            item.appendChild(link);
            dropdownElem.appendChild(item);
        });
        
        // Set up "All" selection handler
        const allOption = dropdownElem.querySelector('a[data-value="all"]');
        if (allOption) {
            allOption.addEventListener('click', function(e) {
                e.preventDefault();
                selectedContainer.innerHTML = '';
                updateCharts();
            });
        }
    }
    
    setupDropdown(sentimentSelect, topicOptions.sentiments, 'selectedSentiments');
    setupDropdown(impactSelect, topicOptions.timeToImpacts, 'selectedImpacts');
    setupDropdown(driverTypeSelect, topicOptions.driverTypes, 'selectedDriverTypes');
}

function setupCategoryDropdown(values) {
    const dropdownElem = document.getElementById('categorySelect');
    dropdownElem.innerHTML = '<li><a class="dropdown-item" href="#" data-value="all">All Categories</a></li>';
    const selectedContainer = document.getElementById('selectedCategories');
    selectedContainer.innerHTML = '';

    // Helper to handle click toggle
    const addItem = (val) => {
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.dataset.value = val;
        badge.textContent = val;
        const removeBtn = document.createElement('span');
        removeBtn.innerHTML = '&times;';
        removeBtn.className = 'ms-1';
        removeBtn.style.cursor = 'pointer';
        removeBtn.addEventListener('click', () => {
            badge.remove();
            updateCharts();
        });
        badge.appendChild(removeBtn);
        selectedContainer.appendChild(badge);
    };

    values.forEach(val => {
        const li = document.createElement('li');
        const link = document.createElement('a');
        link.className = 'dropdown-item';
        link.href = '#';
        link.dataset.value = val;
        link.textContent = val;
        link.addEventListener('click', (e) => {
            e.preventDefault();
            if (val === 'all') {
                selectedContainer.innerHTML = '';
                updateCharts();
                return;
            }
            const existing = document.querySelector(`#selectedCategories .badge[data-value="${val}"]`);
            if (existing) {
                existing.remove();
            } else {
                addItem(val);
            }
            updateCharts();
        });
        li.appendChild(link);
        dropdownElem.appendChild(li);
    });

    // Handle saved selections
    const saved = JSON.parse(localStorage.getItem('analyticsCategory') || '[]');
    saved.forEach(v => addItem(v));
}

function loadCategoriesForTopic(topicName) {
    fetch(`/api/categories/${encodeURIComponent(topicName)}`)
        .then(r => r.json())
        .then(cats => setupCategoryDropdown(cats))
        .catch(err => console.error('Error loading categories:', err));
}

function handleCategoryChange() {
    updateCharts();
}

function handleTimeframeChange() {
    updateCharts();
}

function updateCharts() {
    const topic = document.getElementById('topicSelect').value;
    const categoryDropdown = document.getElementById('categoryDropdown');
    const categoryFilters = Array.from(document.querySelectorAll('#selectedCategories .badge')).map(b => b.dataset.value);
    const timeframe = document.getElementById('timeframeSelect').value;

    // Get selections from custom dropdowns
    const sentimentFilters = Array.from(document.querySelectorAll('#selectedSentiments .badge'))
        .map(badge => badge.dataset.value);
    const impactFilters = Array.from(document.querySelectorAll('#selectedImpacts .badge'))
        .map(badge => badge.dataset.value);
    const driverFilters = Array.from(document.querySelectorAll('#selectedDriverTypes .badge'))
        .map(badge => badge.dataset.value);
    const curatedOnly = document.getElementById('curatedCheckbox').checked;

    // Persist selections
    localStorage.setItem('analyticsCategory', JSON.stringify(categoryFilters));
    // Only fetch and update charts if a topic is selected
    if (topic) {
        fetchDataAndUpdateCharts({
            timeframe,
            categories: categoryFilters,
            topic,
            sentiments: sentimentFilters,
            timeToImpacts: impactFilters,
            driverTypes: driverFilters,
            curated: curatedOnly
        });
    }
}

async function fetchDataAndUpdateCharts(params) {
    try {
        // Create URLSearchParams for the API call
        const query = new URLSearchParams();
        
        // Add basic parameters
        query.append('timeframe', params.timeframe);
        query.append('topic', params.topic);
        query.append('curated', params.curated);
        
        // Add category filters
        (params.categories || []).forEach(value => query.append('category', value));
        
        // Add multiple selections for filters
        params.sentiments.forEach(value => query.append('sentiment', value));
        params.timeToImpacts.forEach(value => query.append('timeToImpact', value));
        params.driverTypes.forEach(value => query.append('driverType', value));

        const response = await fetch(`/api/analytics?${query.toString()}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        // Update your existing chart update functions
        updateRadarChart(data.radarChartData);
        updateSentimentDistribution(data.sentimentDistribution);
        updateTimeToImpactDistribution(data.timeToImpactDistribution);
        updateFutureSignalDistribution(data.futureSignalDistribution);
        updateSentimentByCategory(data.sentimentByCategory);
        updateFutureSignalByCategory(data.futureSignalByCategory);
        updateArticlesBubbleChart(data.articlesBubbleChart);
        updateArticlesFutureTimeBubbleChart(data.articlesFutureTimeBubbleChart);
        updateArticleCount(data.totalArticles);
        updateSentimentTimeSeries(data.sentimentTimeSeries);
        updateCategoryStackedBar(data.categoryTimeSeries);
        updateSummaryStats(data);
    } catch (error) {
        console.error('Error fetching analytics data:', error);
    }
}

function updateSentimentDistribution(data) {
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#9782ad',   // Lilac
        'Negative': '#f05b06',  // Red Orange
        'Critical': '#ff0080',  // Fuchsia
        'Mixed': '#432f70'      // Indigo
    };

    // Create ordered arrays for labels, values, and colors
    const orderedLabels = [];
    const orderedValues = [];
    const orderedColors = [];

    // Use dynamic sentiments from topicOptions
    topicOptions.sentiments.forEach(sentiment => {
        const index = data.labels.indexOf(sentiment);
        if (index !== -1) {
            orderedLabels.push(sentiment);
            orderedValues.push(data.values[index]);
            orderedColors.push(colors[sentiment] || 'gray');
        }
    });

    // Add any remaining sentiments that weren't in our predefined order
    data.labels.forEach((label, index) => {
        if (!orderedLabels.includes(label)) {
            orderedLabels.push(label);
            orderedValues.push(data.values[index]);
            orderedColors.push(colors[label] || 'gray');
        }
    });

    // Pie Chart
    Plotly.newPlot('sentimentDistributionPie', [{
        values: orderedValues,
        labels: orderedLabels,
        type: 'pie',
        marker: {
            colors: orderedColors
        }
    }], {
        title: 'Sentiment Distribution (Pie Chart)'
    });

    // Bar Chart
    Plotly.newPlot('sentimentDistributionBar', [{
        x: orderedLabels,
        y: orderedValues,
        type: 'bar',
        marker: {
            color: orderedColors
        }
    }], {
        title: 'Sentiment Distribution (Bar Chart)',
        xaxis: { title: 'Sentiment' },
        yaxis: { title: 'Count' }
    });
}

function updateTimeToImpactDistribution(data) {
    console.log('Time Impact Data:', data);  // Debug log
    
    // Check if we have the expected data structure
    if (!data || (!data.timeToImpactDistribution && !data.labels)) {
        console.warn('No time to impact distribution data available');
        return;
    }

    // Handle both possible data formats
    let processedData;
    if (data.timeToImpactDistribution) {
        processedData = Object.entries(data.timeToImpactDistribution)
            .map(([key, value]) => ({ name: key, value: value }));
    } else if (data.labels && data.values) {
        processedData = data.labels.map((label, index) => ({
            name: label,
            value: data.values[index]
        }));
    } else {
        console.warn('Unexpected data format:', data);
        return;
    }

    // Sort according to predefined order
    const timeToImpactOrder = ['Immediate', 'Short-term', 'Mid-term', 'Long-term'];
    processedData.sort((a, b) => 
        timeToImpactOrder.indexOf(a.name) - timeToImpactOrder.indexOf(b.name)
    );

    // Update charts with processed data
    const values = processedData.map(item => item.value);
    const labels = processedData.map(item => item.name);

    // Update pie chart
    Plotly.newPlot('timeToImpactPie', [{
        values: values,
        labels: labels,
        type: 'pie'
    }], {
        title: 'Time to Impact Distribution'
    });

    // Update bar chart
    Plotly.newPlot('timeToImpactBar', [{
        x: labels,
        y: values,
        type: 'bar'
    }], {
        title: 'Time to Impact Distribution',
        xaxis: { title: 'Time to Impact' },
        yaxis: { title: 'Count' }
    });
}

function updateFutureSignalDistribution(data) {
    console.log('Future Signal Data:', data);  // Debug log
    
    // Check if we have the expected data structure
    if (!data || (!data.futureSignalDistribution && !data.labels)) {
        console.warn('No future signal distribution data available');
        return;
    }

    // Handle both possible data formats
    let processedData;
    if (data.futureSignalDistribution) {
        processedData = Object.entries(data.futureSignalDistribution)
            .map(([key, value]) => ({ name: key, value: value }));
    } else if (data.labels && data.values) {
        processedData = data.labels.map((label, index) => ({
            name: label,
            value: data.values[index]
        }));
    } else {
        console.warn('Unexpected data format:', data);
        return;
    }

    // Sort according to the order in topicOptions
    if (topicOptions && topicOptions.futureSignals) {
        processedData.sort((a, b) => 
            topicOptions.futureSignals.indexOf(a.name) - 
            topicOptions.futureSignals.indexOf(b.name)
        );
    }

    const values = processedData.map(item => item.value);
    const labels = processedData.map(item => item.name);

    // Update pie chart
    Plotly.newPlot('futureSignalPie', [{
        values: values,
        labels: labels,
        type: 'pie'
    }], {
        title: 'Future Signal Distribution'
    });

    // Update bar chart
    Plotly.newPlot('futureSignalBar', [{
        x: labels,
        y: values,
        type: 'bar'
    }], {
        title: 'Future Signal Distribution',
        xaxis: { title: 'Future Signal' },
        yaxis: { title: 'Count' }
    });
}

function updateSentimentByCategory(data) {
    const { categories, sentiments, data: chartData } = data;
    const traces = sentiments.map(sentiment => ({
        x: categories,
        y: categories.map(category => chartData[category][sentiment]),
        name: sentiment,
        type: 'bar'
    }));

    const layout = {
        barmode: 'stack',
        title: 'Sentiment Distribution Across Categories',
        xaxis: { title: 'Category', tickangle: -45 },
        yaxis: { title: 'Number of Articles' },
        legend: { title: 'Sentiment' }
    };

    Plotly.newPlot('sentimentByCategory', traces, layout);
}

function updateFutureSignalByCategory(data) {
    const { categories, future_signals, data: chartData } = data;
    const traces = future_signals.map(signal => ({
        x: categories,
        y: categories.map(category => chartData[category][signal]),
        name: signal,
        type: 'bar'
    }));

    const layout = {
        barmode: 'stack',
        title: 'Future Signal Distribution Across Categories',
        xaxis: { title: 'Category', tickangle: -45 },
        yaxis: { title: 'Number of Articles' },
        legend: { title: 'Future Signal' }
    };

    Plotly.newPlot('futureSignalByCategory', traces, layout);
}

function updateArticlesBubbleChart(data) {
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#9782ad',   // Lilac
        'Negative': '#f05b06',  // Red Orange
        'Critical': '#ff0080',  // Fuchsia
        'Mixed': '#432f70'      // Indigo
    };

    const traces = topicOptions.sentiments.map(sentiment => ({
        x: topicOptions.futureSignals,
        y: new Array(topicOptions.futureSignals.length).fill(sentiment),
        mode: 'markers',
        name: sentiment,
        marker: {
            color: colors[sentiment] || 'gray',
            size: topicOptions.futureSignals.map(signal => {
                const match = data.find(item => item.future_signal === signal && item.sentiment === sentiment);
                return match ? Math.sqrt(match.count) * 25 : 0;
            }),
            sizemode: 'area',
            sizeref: 0.1
        },
        text: topicOptions.futureSignals.map(signal => {
            const match = data.find(item => item.future_signal === signal && item.sentiment === sentiment);
            return match ? `Count: ${match.count}` : 'Count: 0';
        }),
        hoverinfo: 'text'
    }));

    const layout = {
        title: 'Articles Mapped by Future Signal and Sentiment',
        xaxis: { title: 'Future Signal', tickangle: -45 },
        yaxis: { title: 'Sentiment' },
        showlegend: true
    };

    Plotly.newPlot('articlesBubbleChart', traces, layout);
}

function updateArticlesFutureTimeBubbleChart(data) {
    const colors = {
        'Immediate': 'var(--colors-accent-10)',  // Deep Pink
        'Short-term': '#f05b06',  // Red Orange
        'Mid-term': '#32CD32',   // Lime Green
        'Long-term': '#9782ad'   // Lilac
    };

    const traces = topicOptions.timeToImpacts.map(timeToImpact => ({
        x: topicOptions.futureSignals,
        y: new Array(topicOptions.futureSignals.length).fill(timeToImpact),
        mode: 'markers',
        name: timeToImpact,
        marker: {
            color: colors[timeToImpact] || 'gray',
            size: topicOptions.futureSignals.map(signal => {
                const match = data.find(item => item.future_signal === signal && item.time_to_impact === timeToImpact);
                return match ? Math.sqrt(match.count) * 25 : 0;
            }),
            sizemode: 'area',
            sizeref: 0.1
        },
        text: topicOptions.futureSignals.map(signal => {
            const match = data.find(item => item.future_signal === signal && item.time_to_impact === timeToImpact);
            return match ? `Count: ${match.count}` : 'Count: 0';
        }),
        hoverinfo: 'text'
    }));

    const layout = {
        title: 'Articles Mapped by Future Signal and Time to Impact',
        xaxis: { title: 'Future Signal', tickangle: -45 },
        yaxis: { title: 'Time to Impact' },
        showlegend: true
    };

    Plotly.newPlot('articlesFutureTimeBubbleChart', traces, layout);
}

function updateRadarChart(data) {
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#9782ad',   // Lilac
        'Negative': '#f05b06',  // Red Orange
        'Critical': '#ff0080',  // Fuchsia
        'Mixed': '#432f70',     // Indigo
        'Hyperbolic': '#777777' // Gray
    };

    // Process data to group by future signal, sentiment, and time to impact
    const processedData = {};
    data.forEach(item => {
        if (!processedData[item.future_signal]) {
            processedData[item.future_signal] = {};
        }
        if (!processedData[item.future_signal][item.sentiment]) {
            processedData[item.future_signal][item.sentiment] = 0;
        }
        processedData[item.future_signal][item.sentiment] += item.count;
    });

    // Create traces for each sentiment
    const traces = [];
    
    // Create sentiment traces with bubbles
    topicOptions.sentiments.forEach(sentiment => {
        const r = [];
        const theta = [];
        const sizes = [];
        const hoverTexts = [];

        topicOptions.futureSignals.forEach(signal => {
            const count = processedData[signal]?.[sentiment] || 0;
            if (count > 0) {
                r.push(count);
                theta.push(signal);
                sizes.push(Math.sqrt(count) * 2);
                hoverTexts.push(`${signal}, ${sentiment}: ${count} articles`);
            }
        });

        traces.push({
            type: 'scatterpolar',
            r: r,
            theta: theta,
            mode: 'markers',
            name: sentiment,
            marker: {
                color: colors[sentiment] || 'gray',
                size: sizes,
                opacity: 0.7,
                line: {
                    width: 1,
                    color: 'white'
                }
            },
            text: hoverTexts,
            hoverinfo: 'text'
        });
    });

    // Add concentric circles for scales
    const maxCount = Math.max(...data.map(item => item.count));
    const scales = [50, 100, 150, 200, 250, 300];
    const visibleScales = scales.filter(scale => scale <= maxCount * 1.2);
    
    // Add gridlines as separate traces
    visibleScales.forEach(scale => {
        const fullCircleTheta = [...topicOptions.futureSignals, topicOptions.futureSignals[0]];
        traces.push({
            type: 'scatterpolar',
            r: Array(fullCircleTheta.length).fill(scale),
            theta: fullCircleTheta,
            mode: 'lines',
            line: {
                color: 'lightgray',
                width: 1
            },
            hoverinfo: 'none',
            showlegend: false
        });
    });

    const layout = {
        title: 'Radar Chart of Articles by Future Signal, Sentiment, and Time to Impact',
        polar: {
            radialaxis: {
                visible: true,
                range: [0, Math.max(...visibleScales) * 1.1],
                tickvals: visibleScales,
                tickfont: { size: 10 },
                gridcolor: 'lightgray',
                gridwidth: 1
            },
            angularaxis: {
                tickfont: { size: 12 },
                rotation: 90,
                direction: 'clockwise',
                gridcolor: 'lightgray'
            },
            bgcolor: 'white'
        },
        showlegend: true,
        legend: { 
            orientation: 'v',
            x: 1.1,
            y: 0.5,
            title: {
                text: 'Sentiment',
                side: 'top'
            }
        },
        margin: {
            l: 50,
            r: 50,
            t: 50,
            b: 50
        },
        paper_bgcolor: 'white',
        plot_bgcolor: 'white'
    };

    Plotly.newPlot('radarChart', traces, layout);
}

function updateArticleCount(count) {
    document.getElementById('articleCount').textContent = count;
}

// Function to update the summary stats
function updateSummaryStats(data) {
    // Update top sentiment
    if (data.sentimentDistribution && data.sentimentDistribution.labels && data.sentimentDistribution.labels.length > 0) {
        const sentimentValues = data.sentimentDistribution.values || [];
        const sentimentLabels = data.sentimentDistribution.labels || [];
        
        // Find the max value and its index
        let maxIndex = 0;
        let maxValue = 0;
        
        sentimentValues.forEach((value, index) => {
            if (value > maxValue) {
                maxValue = value;
                maxIndex = index;
            }
        });
        
        if (maxValue > 0 && sentimentLabels[maxIndex]) {
            document.getElementById('topSentiment').textContent = sentimentLabels[maxIndex];
            document.getElementById('topSentimentCount').textContent = `${maxValue} articles`;
        } else {
            document.getElementById('topSentiment').textContent = '-';
            document.getElementById('topSentimentCount').textContent = '0 articles';
        }
    }
    
    // Update top future signal
    if (data.futureSignalDistribution && data.futureSignalDistribution.labels && data.futureSignalDistribution.labels.length > 0) {
        const fsValues = data.futureSignalDistribution.values || [];
        const fsLabels = data.futureSignalDistribution.labels || [];
        
        // Find the max value and its index
        let maxIndex = 0;
        let maxValue = 0;
        
        fsValues.forEach((value, index) => {
            if (value > maxValue) {
                maxValue = value;
                maxIndex = index;
            }
        });
        
        if (maxValue > 0 && fsLabels[maxIndex]) {
            document.getElementById('topFutureSignal').textContent = fsLabels[maxIndex];
            document.getElementById('topFutureSignalCount').textContent = `${maxValue} articles`;
        } else {
            document.getElementById('topFutureSignal').textContent = '-';
            document.getElementById('topFutureSignalCount').textContent = '0 articles';
        }
    }
    
    // Update top time to impact
    if (data.timeToImpactDistribution && data.timeToImpactDistribution.labels && data.timeToImpactDistribution.labels.length > 0) {
        const ttiValues = data.timeToImpactDistribution.values || [];
        const ttiLabels = data.timeToImpactDistribution.labels || [];
        
        // Find the max value and its index
        let maxIndex = 0;
        let maxValue = 0;
        
        ttiValues.forEach((value, index) => {
            if (value > maxValue) {
                maxValue = value;
                maxIndex = index;
            }
        });
        
        if (maxValue > 0 && ttiLabels[maxIndex]) {
            document.getElementById('topTimeToImpact').textContent = ttiLabels[maxIndex];
            document.getElementById('topTimeToImpactCount').textContent = `${maxValue} articles`;
        } else {
            document.getElementById('topTimeToImpact').textContent = '-';
            document.getElementById('topTimeToImpactCount').textContent = '0 articles';
        }
    }
}

function updateSentimentTimeSeries(data) {
    if (!data || data.length === 0) return;

    // Add time period buttons to the chart div
    const chartDiv = document.getElementById('sentimentTimeSeries');
    if (!document.getElementById('timeSeriesPeriods')) {
        const periodsDiv = document.createElement('div');
        periodsDiv.id = 'timeSeriesPeriods';
        periodsDiv.className = 'btn-group btn-group-sm mb-3';
        periodsDiv.style.cssText = 'position: absolute; top: 10px; right: 10px; z-index: 100;';
        
        const periods = ['1m', '6m', 'YTD', '1y', 'all'];
        periods.forEach(period => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-outline-secondary';
            btn.textContent = period;
            btn.dataset.period = period;
            btn.onclick = function() {
                document.querySelectorAll('#timeSeriesPeriods button').forEach(b => 
                    b.classList.remove('active'));
                this.classList.add('active');
                filterTimeSeriesData(data, period);
            };
            periodsDiv.appendChild(btn);
        });
        
        chartDiv.parentNode.style.position = 'relative';
        chartDiv.parentNode.appendChild(periodsDiv);
        
        // Activate 'all' by default
        periodsDiv.querySelector('[data-period="all"]').classList.add('active');
    }

    // Process and display the full dataset initially
    filterTimeSeriesData(data, 'all');
}

function filterTimeSeriesData(data, periodFilter) {
    // Group data by date and sentiment
    const sentiments = [...new Set(data.map(d => d.sentiment))];
    let dates = [...new Set(data.map(d => d.date))].sort();

    // Filter data based on selected period
    const now = new Date();
    if (periodFilter !== 'all') {
        let cutoffDate = new Date();
        if (periodFilter === '1m') {
            cutoffDate.setMonth(now.getMonth() - 1);
        } else if (periodFilter === '6m') {
            cutoffDate.setMonth(now.getMonth() - 6);
        } else if (periodFilter === 'YTD') {
            cutoffDate = new Date(now.getFullYear(), 0, 1); // Jan 1 of current year
        } else if (periodFilter === '1y') {
            cutoffDate.setFullYear(now.getFullYear() - 1);
        }
        
        const cutoffStr = cutoffDate.toISOString().split('T')[0];
        dates = dates.filter(date => date >= cutoffStr);
    }

    // Prepare data for each sentiment
    const traces = [];
    const colors = {
        'Positive': '#32CD32',  // Lime Green
        'Neutral': '#FFD700',   // Gold
        'Negative': '#FF4500',  // Orange Red
        'Critical': '#FF0000',  // Red
        'Mixed': '#9370DB',     // Medium Purple
        'Hyperbolic': '#A9A9A9' // Dark Gray
    };

    // Main sentiment lines
    sentiments.forEach(sentiment => {
        const counts = dates.map(date => {
            const match = data.find(d => d.date === date && d.sentiment === sentiment);
            return match ? match.count : 0;
        });
        
        // Create the main line trace
        traces.push({
            x: dates,
            y: counts,
            mode: 'lines+markers',
            name: sentiment,
            line: {
                width: 3,
                color: colors[sentiment] || '#888'
            },
            marker: {
                size: 8,
                color: colors[sentiment] || '#888'
            }
        });

        // Calculate 3-month moving average
        const maValues = [];
        let validPoints = 0;
        for (let i = 0; i < counts.length; i++) {
            let sum = 0;
            for (let j = Math.max(0, i - 2); j <= i; j++) {
                if (counts[j] !== undefined) {
                    sum += counts[j];
                    validPoints++;
                }
            }
            
            maValues.push(validPoints > 0 ? sum / validPoints : null);
        }

        // Add moving average trace
        traces.push({
            x: dates,
            y: maValues,
            mode: 'lines',
            name: `${sentiment} (3-month MA)`,
            line: {
                width: 2,
                color: colors[sentiment] || '#888',
                dash: 'dot'
            },
            showlegend: true
        });
    });

    // Create a mini-chart for the brush selector
    const miniChartData = sentiments.map(sentiment => {
        const counts = dates.map(date => {
            const match = data.find(d => d.date === date && d.sentiment === sentiment);
            return match ? match.count : 0;
        });
        return {
            x: dates,
            y: counts,
            type: 'scatter',
            mode: 'lines',
            name: sentiment,
            line: {
                width: 1,
                color: colors[sentiment]
            },
            showlegend: false
        };
    });

    // Layout for main chart
    const layout = {
        title: 'Sentiment Trends Over Time',
        xaxis: { 
            title: 'Month',
            tickangle: 0,
            tickformat: '%b %Y',
            type: 'date'
        },
        yaxis: { 
            title: 'Number of Articles',
            rangemode: 'tozero'
        },
        legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: -0.2
        },
        margin: {
            l: 50,
            r: 20,
            t: 50,
            b: 100
        },
        grid: {
            rows: 2,
            columns: 1,
            pattern: 'independent',
            roworder: 'bottom to top',
            subplots: [['xy'], ['xy2']]
        },
        xaxis2: {
            domain: [0, 1],
            showticklabels: false
        },
        yaxis2: {
            domain: [0, 0.15],
            showticklabels: false
        }
    };

    // Create plot with main chart and mini-chart
    Plotly.newPlot('sentimentTimeSeries', [...traces, ...miniChartData], layout);
}

function updateCategoryStackedBar(data) {
    if (!data || data.length === 0) return;

    // Add time period buttons to the chart div
    const chartDiv = document.getElementById('categoryStackedBar');
    if (!document.getElementById('categoryTimeSeriesPeriods')) {
        const periodsDiv = document.createElement('div');
        periodsDiv.id = 'categoryTimeSeriesPeriods';
        periodsDiv.className = 'btn-group btn-group-sm mb-3';
        periodsDiv.style.cssText = 'position: absolute; top: 10px; right: 10px; z-index: 100;';
        
        const periods = ['1m', '6m', 'YTD', '1y', 'all'];
        periods.forEach(period => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-outline-secondary';
            btn.textContent = period;
            btn.dataset.period = period;
            btn.onclick = function() {
                document.querySelectorAll('#categoryTimeSeriesPeriods button').forEach(b => 
                    b.classList.remove('active'));
                this.classList.add('active');
                filterCategoryTimeSeriesData(data, period);
            };
            periodsDiv.appendChild(btn);
        });
        
        chartDiv.parentNode.style.position = 'relative';
        chartDiv.parentNode.appendChild(periodsDiv);
        
        // Activate 'all' by default
        periodsDiv.querySelector('[data-period="all"]').classList.add('active');
    }

    // Process and display the full dataset initially
    filterCategoryTimeSeriesData(data, 'all');
}

function filterCategoryTimeSeriesData(data, periodFilter) {
    // Group data by date and category
    const categories = [...new Set(data.map(d => d.category))];
    let dates = [...new Set(data.map(d => d.date))].sort();

    // Filter data based on selected period
    const now = new Date();
    if (periodFilter !== 'all') {
        let cutoffDate = new Date();
        if (periodFilter === '1m') {
            cutoffDate.setMonth(now.getMonth() - 1);
        } else if (periodFilter === '6m') {
            cutoffDate.setMonth(now.getMonth() - 6);
        } else if (periodFilter === 'YTD') {
            cutoffDate = new Date(now.getFullYear(), 0, 1); // Jan 1 of current year
        } else if (periodFilter === '1y') {
            cutoffDate.setFullYear(now.getFullYear() - 1);
        }
        
        const cutoffStr = cutoffDate.toISOString().split('T')[0];
        dates = dates.filter(date => date >= cutoffStr);
    }

    // Better color palette with more distinguishable colors
    const categoryColors = {};
    
    // Create a consistent but more varied color palette
    const colorPalette = [
        '#4e79a7', // Blue
        '#f28e2b', // Orange
        '#e15759', // Red
        '#76b7b2', // Teal
        '#59a14f', // Green
        '#edc949', // Yellow
        '#af7aa1', // Purple
        '#ff9da7', // Pink
        '#9c755f', // Brown
        '#bab0ab', // Gray
        '#6b9ac4', // Light Blue
        '#d67e53', // Light Orange
        '#e49285', // Light Red
        '#9dd3cf', // Light Teal
        '#8bbc77', // Light Green
        '#f4d57a', // Light Yellow
        '#c9a3c1', // Light Purple
        '#ffbec5', // Light Pink
        '#c2a186', // Light Brown
        '#d6d1ce'  // Light Gray
    ];
    
    // Assign colors to categories, limiting to top 10 if there are too many
    const topCategories = categories
        .map(cat => {
            const total = data
                .filter(d => d.category === cat)
                .reduce((sum, d) => sum + d.count, 0);
            return { category: cat, total };
        })
        .sort((a, b) => b.total - a.total)
        .slice(0, 8) // Limit to top 8 categories for better visibility
        .map(item => item.category);
    
    // Other category for combining less significant ones
    const otherCategory = "Other";
    
    // Assign colors to top categories
    topCategories.forEach((cat, idx) => {
        categoryColors[cat] = colorPalette[idx % colorPalette.length];
    });
    
    // Assign color for "Other" category if needed
    if (categories.length > topCategories.length) {
        categoryColors[otherCategory] = 'var(--colors-neutral-6)ccc'; // Gray for "Other"
    }

    // Fill in missing dates to ensure smooth visualization
    const sortedDates = [...dates].sort((a, b) => new Date(a) - new Date(b));
    const filledDates = [];
    
    if (sortedDates.length > 1) {
        const firstDate = new Date(sortedDates[0]);
        const lastDate = new Date(sortedDates[sortedDates.length - 1]);
        
        // Create a series of dates between the first and last date
        const currentDate = new Date(firstDate);
        while (currentDate <= lastDate) {
            filledDates.push(currentDate.toISOString().split('T')[0]);
            currentDate.setDate(currentDate.getDate() + 1);
        }
    } else if (sortedDates.length === 1) {
        filledDates.push(sortedDates[0]);
    }
    
    // Create a data structure for daily counts by category
    const categoryData = {};
    
    // Initialize with zero counts for all dates
    topCategories.forEach(cat => {
        categoryData[cat] = {};
        filledDates.forEach(date => {
            categoryData[cat][date] = 0;
        });
    });
    
    // Add "Other" category if needed
    if (categories.length > topCategories.length) {
        categoryData[otherCategory] = {};
        filledDates.forEach(date => {
            categoryData[otherCategory][date] = 0;
        });
    }
    
    // Fill in actual counts
    data.forEach(item => {
        const { date, category, count } = item;
        if (filledDates.includes(date)) {
            if (topCategories.includes(category)) {
                categoryData[category][date] = (categoryData[category][date] || 0) + count;
            } else {
                categoryData[otherCategory][date] = (categoryData[otherCategory][date] || 0) + count;
            }
        }
    });
    
    // Compute a moving average for smoother visualization
    const smoothData = {};
    const window = 3; // 3-day moving average
    
    const applyMovingAverage = (values) => {
        const result = [];
        for (let i = 0; i < values.length; i++) {
            let sum = 0;
            let validPoints = 0;
            
            // Look at window/2 days before and after
            for (let j = Math.max(0, i - Math.floor(window/2)); 
                 j <= Math.min(values.length - 1, i + Math.floor(window/2)); j++) {
                sum += values[j];
                validPoints++;
            }
            
            result.push(validPoints > 0 ? sum / validPoints : 0);
        }
        return result;
    };
    
    // Create traces for area chart
    let traces = [];
    
    // Process categories in reverse order (for proper stacking)
    const displayCategories = [...topCategories];
    if (categories.length > topCategories.length) {
        displayCategories.push(otherCategory);
    }
    
    // Add traces for each category (for area chart)
    displayCategories.reverse().forEach(cat => {
        const catData = categoryData[cat];
        const values = filledDates.map(date => catData[date] || 0);
        
        // Apply smoothing for better visualization
        const smoothedValues = applyMovingAverage(values);
        
        traces.push({
            x: filledDates,
            y: smoothedValues,
            name: cat,
            type: 'scatter',
            mode: 'none',
            stackgroup: 'one',
            groupnorm: '',
            hovertemplate: '<b>%{fullData.name}</b>: %{y:.1f}<extra></extra>',
            fillcolor: categoryColors[cat],
            line: {
                color: categoryColors[cat],
                shape: 'spline',
                width: 0
            }
        });
    });

    // Add a total line
    const totalByDate = filledDates.map(date => {
        return Object.keys(categoryData).reduce((sum, cat) => {
            return sum + (categoryData[cat][date] || 0);
        }, 0);
    });

    // Apply smoothing to the total line
    const smoothedTotal = applyMovingAverage(totalByDate);
    
    traces.push({
        x: filledDates,
        y: smoothedTotal,
        name: 'Total',
        type: 'scatter',
        mode: 'lines',
        line: {
            color: 'rgba(0,0,0,0.7)',
            width: 2,
            shape: 'spline'
        },
        hovertemplate: '<b>Total</b>: %{y:.0f}<extra></extra>'
    });

    const layout = {
        barmode: 'stack',
        title: 'Category Counts Over Time',
        autosize: true,
        height: 500, // Increase chart height
        xaxis: { 
            title: 'Date',
            tickangle: 0,
            tickformat: '%b %Y',
            type: 'date',
            tickmode: 'auto',
            nticks: 12 // Limit the number of ticks for clarity
        },
        yaxis: { 
            title: 'Count',
            rangemode: 'tozero',
            gridcolor: '#f0f0f0'
        },
        yaxis2: {
            title: 'Total Count',
            overlaying: 'y',
            side: 'right',
            rangemode: 'tozero',
            gridcolor: 'rgba(0,0,0,0)'
        },
        legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: -0.3,
            traceorder: 'normal'
        },
        margin: {
            l: 50,
            r: 50,
            t: 50,
            b: 120
        },
        plot_bgcolor: 'var(--colors-white)',
        paper_bgcolor: 'var(--colors-white)',
        hoverlabel: {
            bgcolor: 'var(--colors-white)',
            bordercolor: 'var(--colors-neutral-6)',
            font: {size: 12}
        },
        bargap: 0.01, // Minimize the gap between bars for wider appearance
        bargroupgap: 0.01, // Minimize the gap between bar groups
        hovermode: 'closest',
        uniformtext: {
            mode: 'hide',
            minsize: 8
        },
        modebar: {
            remove: ['lasso', 'select']
        }
    };

    // Create responsive chart that fills container
    const config = {
        responsive: true,
        displayModeBar: false // Hide the modebar for cleaner look
    };
    
    Plotly.newPlot('categoryStackedBar', traces, layout, config);
}

// Add this new function to clear all charts
function clearCharts() {
    // Clear each chart with empty data
    Plotly.newPlot('sentimentDistributionPie', [{ values: [], labels: [], type: 'pie' }]);
    Plotly.newPlot('sentimentDistributionBar', [{ x: [], y: [], type: 'bar' }]);
    Plotly.newPlot('timeToImpactPie', [{ values: [], labels: [], type: 'pie' }]);
    Plotly.newPlot('timeToImpactBar', [{ x: [], y: [], type: 'bar' }]);
    Plotly.newPlot('futureSignalPie', [{ values: [], labels: [], type: 'pie' }]);
    Plotly.newPlot('futureSignalBar', [{ x: [], y: [], type: 'bar' }]);
    Plotly.newPlot('sentimentByCategory', [{ x: [], y: [], type: 'bar' }]);
    Plotly.newPlot('futureSignalByCategory', [{ x: [], y: [], type: 'bar' }]);
    Plotly.newPlot('articlesBubbleChart', [{ x: [], y: [], mode: 'markers' }]);
    Plotly.newPlot('articlesFutureTimeBubbleChart', [{ x: [], y: [], mode: 'markers' }]);
    Plotly.newPlot('radarChart', [{ r: [], theta: [], type: 'scatterpolar' }]);
    Plotly.newPlot('sentimentTimeSeries', [{ x: [], y: [] }]);
    Plotly.newPlot('categoryStackedBar', [{ x: [], y: [], type: 'bar' }]);
    
    // Clear article count
    document.getElementById('articleCount').textContent = '0';
}

// Flow Chart Code
function initFlowChart() {
    loadFlowTopics().then(() => {
        // Initialize Select2 multi-selects
        $('.select2-multiple').select2({
            placeholder: 'Select options',
            allowClear: true,
            width: 'resolve'
        }).on('change', fetchAndRender);
        
        fetchAndRender();
    });
    
    // Add event listeners for Flow tab
    document.getElementById('refreshBtn').addEventListener('click', fetchAndRender);
    
    ['sourceFilter', 'categoryFilter', 'sentimentFilter', 'colorMode', 'topSourcesInput', 
     'includeOtherCheckbox', 'showCategoryCheckbox'].forEach(id => {
        document.getElementById(id).addEventListener('change', fetchAndRender);
    });
}

async function loadFlowTopics() {
    try {
        const res = await fetch('/api/topics');
        const topics = await res.json();
        const select = document.getElementById('flowTopicSelect');
        select.innerHTML = '<option value="">All topics</option>';
        topics.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t.name;
            opt.textContent = t.name;
            select.appendChild(opt);
        });
    } catch(e) { console.error(e); }
}

// Utility for fallback pastel hues when stage color not used
function pastelColor(idx, total) {
    const hue = (idx * 360 / total) % 360;
    return `hsl(${hue},60%,70%)`;
}

const STAGE_COLORS = ['#4e79a7', '#f28e2c', '#59a14f']; // source, category, sentiment

function buildSankeyData(articles, maxSources, includeOther=true, includeCategory=true) {
    const MAX_SOURCES = maxSources;

    // Count occurrences per source
    const sourceCounts = articles.reduce((acc, art) => {
        const src = art.source || 'Unknown source';
        acc[src] = (acc[src] || 0) + 1;
        return acc;
    }, {});

    // Determine top sources
    const topSources = Object.entries(sourceCounts)
        .sort((a,b)=>b[1]-a[1])
        .slice(0, MAX_SOURCES)
        .map(([name])=>name);

    const nodeIndices = new Map();
    const nodes = [];
    function getIndex(label) {
        if(!nodeIndices.has(label)) {
            nodeIndices.set(label, nodes.length);
            nodes.push(label);
        }
        return nodeIndices.get(label);
    }

    const pairCounts = new Map();
    const stageMap = new Map(); // label -> stage index 0-2

    articles.forEach(art => {
        let src = art.source || 'Unknown source';
        if(!topSources.includes(src)) {
            if(!includeOther) return; // skip this article altogether
            src = 'Other sources';
        }

        let cat = art.category || 'Unknown';
        if(cat.toLowerCase().includes('unknown')) return; // Skip unknowns

        const sent = art.sentiment || 'Unknown sentiment';

        // only three stages
        const pairs = includeCategory ? [[src, cat],[cat, sent]] : [[src, sent]];
        pairs.forEach(([a,b]) => {
            const key = `${a}>>${b}`;
            pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
            const aIdx = getIndex(a);
            const bIdx = getIndex(b);
            // Track stage for coloring
            if(!stageMap.has(a)) stageMap.set(a, includeCategory? (pairs.length===2 && b===cat?0: pairs.indexOf([a,b])) : 0);
            if(!stageMap.has(b)) {
                const stageGuess = stageMap.get(a)+1;
                stageMap.set(b, stageGuess);
            }
        });
    });

    const sources = [];
    const targets = [];
    const values = [];
    pairCounts.forEach((val, key) => {
        const [a, b] = key.split('>>');
        sources.push(getIndex(a));
        targets.push(getIndex(b));
        values.push(val);
    });

    // Generate colors: use stage palette fallback pastel
    const palette = includeCategory ? STAGE_COLORS : ['#4e79a7','#59a14f'];
    const nodeColors = nodes.map(label => {
        const stage = stageMap.get(label);
        if(stage !== undefined) return palette[stage] || pastelColor(0,1);
        return pastelColor(0,1);
    });

    // Unique color for each link
    const linkColors = values.map((_, idx) => pastelColor(idx, values.length));

    return { nodes, sources, targets, values, nodeColors, linkColors };
}

function renderSankey(data) {
    const trace = {
        type: 'sankey',
        orientation: 'h',
        node: {
            pad: 30,
            thickness: 30,
            label: data.nodes,
            color: data.nodeColors,
            font: {size: 10, color: 'var(--colors-black)'}
        },
        link: {
            source: data.sources,
            target: data.targets,
            value: data.values,
            color: data.linkColors
        }
    };
    const layout = {
        title: 'Article Flow Across Stages',
        font: {size: 12},
        height: 650,
        width: 1300,
        margin: {l: 30, r: 30, t: 40, b: 10},
        autosize: true
    };
    Plotly.react('sankeyChart', [trace], layout, {responsive: true});
}

function applyFilters(records) {
    const sel = id => Array.from(document.getElementById(id).selectedOptions).map(o=>o.value);
    const srcSel = sel('sourceFilter');
    const catSel = sel('categoryFilter');
    const sentSel = sel('sentimentFilter');
    return records.filter(r=>{
        const srcOk = srcSel.length? srcSel.includes(r.source): true;
        const catOk = catSel.length? catSel.includes(r.category): true;
        const sentOk = sentSel.length? sentSel.includes(r.sentiment): true;
        return srcOk && catOk && sentOk;
    });
}

function populateFilters(records){
    function unique(field){return [...new Set(records.map(r=>r[field]).filter(Boolean))].sort();}
    const setOptions=(id,list)=>{
        const select=document.getElementById(id);
        if(select.options.length) return; // only first time
        list.forEach(v=>{
            const opt=document.createElement('option');
            opt.value=opt.textContent=v; select.appendChild(opt);
        });
    };
    setOptions('sourceFilter',unique('source'));
    setOptions('categoryFilter',unique('category').filter(v=>v!=='Unknown category'));
    setOptions('sentimentFilter',unique('sentiment'));
}

async function fetchAndRender() {
    const topic = document.getElementById('flowTopicSelect').value;
    const timeframe = document.getElementById('flowTimeframeSelect').value;
    const topSources = parseInt(document.getElementById('topSourcesInput').value || '12',10);
    const mode = document.getElementById('colorMode').value;
    const includeOther = document.getElementById('includeOtherCheckbox').checked;
    const includeCategory = document.getElementById('showCategoryCheckbox').checked;
    const params = new URLSearchParams({timeframe, topSources});
    if(topic) params.append('topic', topic);
    const res = await fetch(`/api/flow_data?${params.toString()}`);
    const records = await res.json();
    populateFilters(records);
    const filtered = applyFilters(records);
    const sankey = buildSankeyData(filtered, topSources, includeOther, includeCategory);
    renderSankey(sankey);
}
</script>

    </div> <!-- End analytics-scrollable -->
</div> <!-- End analytics-container -->

<style>
/* Analytics container matching other pages */
.analytics-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    line-height: 1.6;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.analytics-scrollable {
    flex: 1;
    overflow-y: auto;
    padding: 1.5rem;
}

/* Breadcrumb Header */
.page-breadcrumb-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    background: white;
    border-bottom: 1px solid var(--colors-neutral-4);
    flex-shrink: 0;
}

.breadcrumb-text {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--colors-neutral-8);
}

.breadcrumb-text .font-medium {
    font-weight: 500;
    color: var(--colors-neutral-12);
}

.page-header-actions {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

/* Subtle button styling */
.btn-icon {
    background: white;
    border: 1px solid var(--colors-neutral-4);
    color: var(--colors-neutral-8);
    padding: 0.5rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
}

.btn-icon:hover {
    background: var(--colors-neutral-3);
    border-color: #d1d5db;
    color: var(--colors-neutral-12);
}

.btn-topic-setup {
    background: var(--colors-neutral-3);
    border: none;
    color: var(--colors-neutral-12);
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
}

.btn-topic-setup:hover {
    background: var(--colors-neutral-4);
    color: var(--colors-neutral-12);
}

/* Override bright pink buttons to subtle style */
.btn-primary {
    background: white !important;
    border: 1px solid var(--colors-neutral-4) !important;
    color: var(--colors-accent-8) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-primary:hover {
    background: var(--colors-accent-1) !important;
    border-color: var(--colors-accent-3) !important;
    color: var(--colors-accent-8) !important;
}

.btn-success {
    background: white !important;
    border: 1px solid var(--colors-neutral-4) !important;
    color: var(--colors-success-9) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-success:hover {
    background: #f0fdf4 !important;
    border-color: #d1fae5 !important;
    color: var(--colors-success-9) !important;
}

.btn-secondary {
    background: white !important;
    border: 1px solid var(--colors-neutral-4) !important;
    color: var(--colors-neutral-12) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-secondary:hover {
    background: var(--colors-neutral-3) !important;
    border-color: #d1d5db !important;
    color: var(--colors-neutral-12) !important;
}

.btn-danger, .btn-outline-danger {
    background: white !important;
    border: 1px solid var(--colors-neutral-4) !important;
    color: var(--colors-error-7) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-danger:hover, .btn-outline-danger:hover {
    background: #fef2f2 !important;
    border-color: #fecaca !important;
    color: var(--colors-error-7) !important;
}

.btn-warning {
    background: white !important;
    border: 1px solid var(--colors-neutral-4) !important;
    color: var(--colors-warning-6) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-warning:hover {
    background: var(--colors-white)beb !important;
    border-color: #fde68a !important;
    color: var(--colors-warning-6) !important;
}

.btn-info {
    background: white !important;
    border: 1px solid var(--colors-neutral-4) !important;
    color: #3b82f6 !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-info:hover {
    background: #eff6ff !important;
    border-color: #bfdbfe !important;
    color: #3b82f6 !important;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .page-breadcrumb-header {
        padding: 0.5rem 1rem;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
    }

    .breadcrumb-text {
        font-size: 0.75rem;
    }

    .page-header-actions {
        width: 100%;
        justify-content: flex-end;
    }

    .btn-topic-setup {
        font-size: 0.75rem;
        padding: 0.375rem 0.75rem;
    }
}
</style>
{% endblock %}
