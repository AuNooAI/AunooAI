{% extends "base.html" %}

{% block title %}Reference Graph{% endblock %}

{% block styles %}
<style>
    .reference-graph-container {
        padding: 20px;
        height: 100vh;
        display: flex;
        flex-direction: column;
        background-color: #f5f5f5;
    }
    
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
    .controls-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .graph-wrapper {
        flex: 1;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        position: relative;
        min-height: 600px;
        height: calc(100vh - 200px);
    }
    
    #cy {
        width: 100% !important;
        height: 100% !important;
        position: absolute;
        top: 0;
        left: 0;
        min-height: 600px !important;
        background-color: #f9f9f9 !important;
        border: 2px solid #ddd !important;
    }
    
    .stats-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 100;
        font-size: 12px;
    }
    
    .legend {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 6px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 100;
        font-size: 12px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
    }
    
    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-right: 8px;
    }
    
    .action-buttons {
        position: absolute;
        bottom: 10px;
        right: 10px;
        z-index: 100;
    }
    
    .action-buttons .btn {
        margin-left: 5px;
        font-size: 12px;
    }
</style>
{% endblock %}

{% block content %}
<div class="reference-graph-container">
    <div class="controls-panel">
        <div class="row align-items-end">
            <div class="col-md-3">
                <label for="categoryFilter" class="form-label">Category:</label>
                <select id="categoryFilter" class="form-select form-select-sm">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div class="col-md-4">
                <label for="semanticQuery" class="form-label">Search:</label>
                <input type="text" id="semanticQuery" class="form-control form-control-sm" 
                       placeholder="Enter search terms...">
            </div>
            <div class="col-md-2">
                <label for="articleLimit" class="form-label">Limit:</label>
                <select id="articleLimit" class="form-select form-select-sm">
                    <option value="50">50</option>
                    <option value="100" selected>100</option>
                    <option value="200">200</option>
                </select>
            </div>
            <div class="col-md-3 text-end">
                <button id="generateGraph" class="btn btn-primary btn-sm">
                    <i class="fa fa-refresh"></i> Generate
                </button>
                <button id="resetView" class="btn btn-secondary btn-sm">
                    <i class="fa fa-home"></i> Reset
                </button>
                <button id="testGraph" class="btn btn-danger btn-sm">
                    <i class="fa fa-bug"></i> Test
                </button>
            </div>
        </div>
    </div>
    
    <div class="graph-wrapper">
        <div id="cy"></div>
        
        <div class="stats-panel">
            <h6 style="margin: 0 0 8px 0; font-size: 14px;">Graph Stats</h6>
            <div>Categories: <strong id="catCount">0</strong></div>
            <div>Topics: <strong id="topicCount">0</strong></div>
            <div>Articles: <strong id="articleCount">0</strong></div>
        </div>
        
        <div class="legend">
            <h6 style="margin: 0 0 8px 0; font-size: 14px;">Legend</h6>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF6B6B;"></div>
                <span>Categories</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4ECDC4;"></div>
                <span>Topics</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #96CEB4;"></div>
                <span>Articles</span>
            </div>
            <small class="text-muted">Click nodes to expand</small>
        </div>
        
        <div class="action-buttons">
            <button id="expandAll" class="btn btn-success btn-sm">
                <i class="fa fa-expand"></i> Expand All
            </button>
            <button id="collapseAll" class="btn btn-warning btn-sm">
                <i class="fa fa-compress"></i> Collapse All
            </button>
            <button id="saveGraph" class="btn btn-info btn-sm">
                <i class="fa fa-download"></i> Save
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>

<script>
let cy = null;
let graphData = null;
let expandedNodes = new Set();

document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing reference graph...');
    initCytoscape();
    loadCategories();
    setupEventListeners();
    
    // Generate initial graph
    setTimeout(() => generateGraph(), 100);
});

function initCytoscape() {
    const container = document.getElementById('cy');
    
    // Force container to have proper dimensions
    const wrapper = container.parentElement;
    console.log('Container setup:', {
        container: container.offsetWidth + 'x' + container.offsetHeight,
        wrapper: wrapper ? wrapper.offsetWidth + 'x' + wrapper.offsetHeight : 'null'
    });
    
    if (wrapper && wrapper.offsetHeight === 0) {
        console.log('Wrapper height is 0, forcing height...');
        wrapper.style.height = '600px';
        wrapper.style.minHeight = '600px';
        wrapper.style.display = 'block';
    }
    
    // Also ensure the container itself has dimensions
    if (container.offsetHeight === 0) {
        console.log('Container height is 0, forcing height...');
        container.style.height = '600px';
        container.style.minHeight = '600px';
        container.style.display = 'block';
    }
    
    cy = cytoscape({
        container: container,
        
        style: [
            {
                selector: 'node',
                style: {
                    'label': 'data(label)',
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'background-color': 'data(color)',
                    'color': '#fff',
                    'text-outline-width': 1,
                    'text-outline-color': '#333',
                    'font-size': '10px',
                    'font-weight': 'bold',
                    'width': 'data(size)',
                    'height': 'data(size)',
                    'text-wrap': 'wrap',
                    'text-max-width': '80px'
                }
            },
            {
                selector: 'node[type="category"]',
                style: {
                    'shape': 'roundrectangle',
                    'background-color': '#FF6B6B',
                    'font-size': '12px',
                    'width': 80,
                    'height': 50,
                    'border-width': 2,
                    'border-color': '#fff'
                }
            },
            {
                selector: 'node[type="topic"]',
                style: {
                    'shape': 'ellipse',
                    'background-color': '#4ECDC4',
                    'font-size': '9px',
                    'width': 60,
                    'height': 40
                }
            },
            {
                selector: 'node[type="article"]',
                style: {
                    'shape': 'rectangle',
                    'background-color': '#96CEB4',
                    'font-size': '8px',
                    'width': 40,
                    'height': 25
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 1,
                    'line-color': '#ccc',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'straight'
                }
            },
            {
                selector: '.hidden',
                style: {
                    'display': 'none'
                }
            },
            {
                selector: '.expandable',
                style: {
                    'border-width': 3,
                    'border-color': '#28a745'
                }
            }
        ],
        
        layout: {
            name: 'preset'
        },
        
        minZoom: 0.2,
        maxZoom: 3
    });
    
    // Event handlers
    cy.on('tap', 'node', function(evt) {
        const node = evt.target;
        handleNodeClick(node);
    });
    
    cy.on('mouseover', 'node', function(evt) {
        const node = evt.target;
        node.style('border-color', '#ffc107');
        node.style('border-width', 3);
    });
    
    cy.on('mouseout', 'node', function(evt) {
        const node = evt.target;
        if (!node.hasClass('expandable')) {
            node.style('border-color', '#fff');
            node.style('border-width', 2);
        }
    });
}

function setupEventListeners() {
    document.getElementById('generateGraph').addEventListener('click', generateGraph);
    document.getElementById('resetView').addEventListener('click', () => {
        if (cy) cy.fit(30);
    });
    document.getElementById('testGraph').addEventListener('click', testGraph);
    document.getElementById('expandAll').addEventListener('click', expandAllNodes);
    document.getElementById('collapseAll').addEventListener('click', collapseAllNodes);
    document.getElementById('saveGraph').addEventListener('click', saveGraph);
    
    document.getElementById('semanticQuery').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') generateGraph();
    });
}

function handleNodeClick(node) {
    const nodeType = node.data('type');
    const nodeId = node.id();
    
    if (nodeType === 'article' && node.data('url')) {
        // Open article in new tab
        window.open(node.data('url'), '_blank');
        return;
    }
    
    // Toggle expansion for categories and topics
    if (node.data('expandable') || expandedNodes.has(nodeId)) {
        toggleNodeExpansion(node);
    }
}

function toggleNodeExpansion(node) {
    const nodeId = node.id();
    
    if (expandedNodes.has(nodeId)) {
        collapseNode(node);
    } else {
        expandNode(node);
    }
}

function expandNode(node) {
    const nodeId = node.id();
    
    if (expandedNodes.has(nodeId)) return;
    
    console.log(`Expanding node: ${nodeId}`);
    
    // Show child nodes and edges
    cy.edges(`[source="${nodeId}"]`).forEach(edge => {
        edge.removeClass('hidden');
        const target = edge.target();
        target.removeClass('hidden');
    });
    
    expandedNodes.add(nodeId);
    node.removeClass('expandable');
    
    // Re-layout visible nodes
    layoutVisibleNodes();
}

function collapseNode(node) {
    const nodeId = node.id();
    
    if (!expandedNodes.has(nodeId)) return;
    
    console.log(`Collapsing node: ${nodeId}`);
    
    // Hide child nodes recursively
    const hideChildren = (parentId) => {
        cy.edges(`[source="${parentId}"]`).forEach(edge => {
            edge.addClass('hidden');
            const target = edge.target();
            const targetId = target.id();
            
            target.addClass('hidden');
            
            // Recursively hide children
            if (expandedNodes.has(targetId)) {
                expandedNodes.delete(targetId);
                hideChildren(targetId);
            }
        });
    };
    
    hideChildren(nodeId);
    expandedNodes.delete(nodeId);
    
    // Mark as expandable if it has children
    if (cy.edges(`[source="${nodeId}"]`).length > 0) {
        node.addClass('expandable');
    }
    
    layoutVisibleNodes();
}

function expandAllNodes() {
    console.log('Expanding all nodes');
    
    // Show all nodes and edges
    cy.nodes().removeClass('hidden');
    cy.edges().removeClass('hidden');
    
    // Mark all parent nodes as expanded
    cy.nodes().forEach(node => {
        if (cy.edges(`[source="${node.id()}"]`).length > 0) {
            expandedNodes.add(node.id());
            node.removeClass('expandable');
        }
    });
    
    layoutVisibleNodes();
}

function collapseAllNodes() {
    console.log('Collapsing all nodes');
    
    // Hide all non-category nodes
    cy.nodes('[type!="category"]').addClass('hidden');
    cy.edges().addClass('hidden');
    
    // Mark categories as expandable
    cy.nodes('[type="category"]').forEach(node => {
        if (cy.edges(`[source="${node.id()}"]`).length > 0) {
            node.addClass('expandable');
        }
    });
    
    expandedNodes.clear();
    layoutVisibleNodes();
}

function layoutVisibleNodes() {
    const visibleNodes = cy.nodes(':visible');
    
    if (visibleNodes.length === 0) return;
    
    console.log(`Laying out ${visibleNodes.length} visible nodes`);
    
    // Separate nodes by type for hierarchical column layout
    const categories = cy.nodes('[type="category"]:visible').toArray();
    const topics = cy.nodes('[type="topic"]:visible').toArray();
    const articles = cy.nodes('[type="article"]:visible').toArray();
    
    console.log(`Hierarchical layout: ${categories.length} categories, ${topics.length} topics, ${articles.length} articles`);
    
    // Column positions and spacing
    const colWidth = 250;
    const rowHeight = 80;
    const startX = 50;
    const startY = 50;
    
    // Column 1: Categories (left)
    categories.forEach((node, index) => {
        const x = startX;
        const y = startY + (index * rowHeight);
        node.position({ x: x, y: y });
        console.log(`Category ${node.id()} at (${x}, ${y})`);
    });
    
    // Column 2: Topics (middle) - group by parent category
    const topicsByCategory = {};
    topics.forEach(topicNode => {
        // Find the parent category for this topic
        const parentEdge = cy.edges(`[target="${topicNode.id()}"][type="category_to_topic"]`).first();
        if (parentEdge.length > 0) {
            const parentId = parentEdge.source().id();
            if (!topicsByCategory[parentId]) {
                topicsByCategory[parentId] = [];
            }
            topicsByCategory[parentId].push(topicNode);
        }
    });
    
    // Position topics grouped by their parent category
    let topicIndex = 0;
    categories.forEach((categoryNode, catIndex) => {
        const categoryTopics = topicsByCategory[categoryNode.id()] || [];
        categoryTopics.forEach((topicNode, topicSubIndex) => {
            const x = startX + colWidth;
            const y = startY + (catIndex * rowHeight) + (topicSubIndex * 30); // Offset within category
            topicNode.position({ x: x, y: y });
            console.log(`Topic ${topicNode.id()} (cat ${categoryNode.id()}) at (${x}, ${y})`);
            topicIndex++;
        });
    });
    
    // Column 3: Articles (right) - group by parent topic
    const articlesByTopic = {};
    articles.forEach(articleNode => {
        // Find the parent topic for this article
        const parentEdge = cy.edges(`[target="${articleNode.id()}"][type="topic_to_article"]`).first();
        if (parentEdge.length > 0) {
            const parentId = parentEdge.source().id();
            if (!articlesByTopic[parentId]) {
                articlesByTopic[parentId] = [];
            }
            articlesByTopic[parentId].push(articleNode);
        }
    });
    
    // Position articles grouped by their parent topic
    let articleIndex = 0;
    categories.forEach((categoryNode, catIndex) => {
        const categoryTopics = topicsByCategory[categoryNode.id()] || [];
        categoryTopics.forEach((topicNode, topicSubIndex) => {
            const topicArticles = articlesByTopic[topicNode.id()] || [];
            topicArticles.forEach((articleNode, articleSubIndex) => {
                const x = startX + (colWidth * 2);
                const y = startY + (catIndex * rowHeight) + (topicSubIndex * 30) + (articleSubIndex * 15);
                articleNode.position({ x: x, y: y });
                console.log(`Article ${articleNode.id()} (topic ${topicNode.id()}) at (${x}, ${y})`);
                articleIndex++;
            });
        });
    });
    
    // Fit viewport to show all nodes
    setTimeout(() => {
        cy.fit(30);
        updateStats();
        
        // Debug: Check final positions
        console.log('Hierarchical layout complete. Sample positions:');
        const positions = [];
        cy.nodes(':visible').forEach(node => {
            const pos = node.position();
            positions.push(`${node.data('type')} ${node.id()}: (${Math.round(pos.x)}, ${Math.round(pos.y)})`);
        });
        console.log('Node positions:', positions.slice(0, 8).join(', '));
        
        // Force a redraw and check rendering
        cy.forceRender();
        
        // Debug: Check if nodes are actually rendered
        setTimeout(() => {
            const renderedNodes = cy.nodes(':visible').length;
            const containerDims = {
                width: cy.container().offsetWidth,
                height: cy.container().offsetHeight
            };
            console.log(`Render check: ${renderedNodes} visible nodes, container: ${containerDims.width}x${containerDims.height}`);
            
            // Check if any nodes have actual rendered positions
            const firstNode = cy.nodes(':visible').first();
            if (firstNode.length > 0) {
                const renderedPos = firstNode.renderedPosition();
                const modelPos = firstNode.position();
                console.log(`First node positions - Model: (${modelPos.x}, ${modelPos.y}), Rendered: (${renderedPos.x}, ${renderedPos.y})`);
            }
        }, 200);
    }, 100);
}

async function loadCategories() {
    try {
        const response = await fetch('/api/topic-map/filter-options');
        const data = await response.json();
        
        const select = document.getElementById('categoryFilter');
        select.innerHTML = '<option value="">All Categories</option>';
        
        if (data.categories) {
            data.categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                select.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error loading categories:', error);
    }
}

async function generateGraph() {
    try {
        const params = new URLSearchParams();
        const category = document.getElementById('categoryFilter').value;
        const query = document.getElementById('semanticQuery').value;
        const limit = document.getElementById('articleLimit').value;
        
        if (category) params.append('category', category);
        if (query) params.append('query', query);
        params.append('limit', limit);
        
        console.log('Fetching graph data...');
        const response = await fetch(`/api/topic-map/reference-graph?${params}`);
        const data = await response.json();
        
        console.log('Received data:', data);
        
        if (data.error) {
            alert(data.error);
            return;
        }
        
        graphData = data;
        renderGraph(data);
        
    } catch (error) {
        console.error('Error generating graph:', error);
        alert('Error generating graph: ' + error.message);
    }
}

function renderGraph(data) {
    console.log('Rendering graph with', data.nodes.length, 'nodes');
    
    // Clear existing elements
    cy.elements().remove();
    expandedNodes.clear();
    
    // Add nodes with positions
    const nodes = data.nodes.map((node, index) => ({
        data: {
            id: node.id,
            label: node.label || 'Unnamed',
            type: node.type,
            size: Math.max(30, Math.min(80, node.size || 50)),
            color: node.color || '#999',
            expandable: node.expandable || false,
            article_count: node.article_count,
            topic_words: node.topic_words,
            url: node.url
        }
    }));
    
    // Add edges
    const edges = data.edges.map(edge => ({
        data: {
            id: `${edge.source}-${edge.target}`,
            source: edge.source,
            target: edge.target,
            type: edge.type
        }
    }));
    
    cy.add(nodes);
    cy.add(edges);
    
    console.log(`Added ${cy.nodes().length} nodes and ${cy.edges().length} edges`);
    
    // Start collapsed - show only categories
    collapseAllNodes();
    
    updateStats();
}

function updateStats() {
    if (!graphData) return;
    
    const cats = graphData.nodes.filter(n => n.type === 'category').length;
    const topics = graphData.nodes.filter(n => n.type === 'topic').length;
    const articles = graphData.nodes.filter(n => n.type === 'article').length;
    
    document.getElementById('catCount').textContent = cats;
    document.getElementById('topicCount').textContent = topics;
    document.getElementById('articleCount').textContent = articles;
}

function testGraph() {
    console.log('Testing graph visibility...');
    
    if (!cy) {
        console.error('Cytoscape not initialized!');
        alert('Cytoscape not initialized!');
        return;
    }
    
    // Clear and add test nodes with proper data
    cy.elements().remove();
    
    cy.add([
        { 
            data: { 
                id: 'test1', 
                label: 'Test Node 1',
                color: '#FF6B6B',
                size: 60
            }, 
            position: { x: 100, y: 100 } 
        },
        { 
            data: { 
                id: 'test2', 
                label: 'Test Node 2',
                color: '#4ECDC4',
                size: 60
            }, 
            position: { x: 200, y: 200 } 
        },
        { 
            data: { 
                id: 'test3', 
                label: 'Test Node 3',
                color: '#96CEB4',
                size: 60
            }, 
            position: { x: 300, y: 150 } 
        }
    ]);
    
    console.log(`Added ${cy.nodes().length} test nodes`);
    console.log('Container dimensions:', {
        width: cy.container().offsetWidth,
        height: cy.container().offsetHeight
    });
    
    // Force container to have height if it's 0
    const container = cy.container();
    if (container.offsetHeight === 0) {
        console.log('Container height is 0, forcing height...');
        container.style.height = '600px';
        cy.resize();
    }
    
    cy.fit(50);
    alert(`Test: Added ${cy.nodes().length} nodes. Container: ${container.offsetWidth}x${container.offsetHeight}`);
}

function saveGraph() {
    if (!graphData) {
        alert('No graph data to save');
        return;
    }
    
    const saveData = {
        graphData: graphData,
        expandedNodes: Array.from(expandedNodes),
        timestamp: new Date().toISOString()
    };
    
    const dataStr = JSON.stringify(saveData, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `reference-graph-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
}
</script>
{% endblock %} 