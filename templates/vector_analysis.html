{% extends 'base.html' %}
{% block title %}Vector Analysis{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.css" />
<style>
    .layout {
        display: grid;
        grid-template-columns: 220px 1fr 260px;
        gap: 1rem;
        margin-top: 1.5rem;
        /* keep sidebars fixed, results scroll inside */
        height: calc(100vh - 120px);
        overflow: hidden;
    }
    .sidebar, .meta {
        background: var(--light-gray);
        padding: 1rem;
        border-radius: 8px;
        overflow-y: auto;
    }
    .main {
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    #results {
        flex: 1;
        margin-top: 1rem;
        overflow-y: auto;
        height: 100%;
    }
    /* square icon buttons */
    .icon-btn {
        width: 32px;
        height: 32px;
        padding: 0;
        border-radius: 4px !important;
        background: var(--primary-color);
        color: #fff;
    }
    .icon-btn i { font-size: 14px; pointer-events: none; }
    /* metadata table */
    .meta table {width:100%; font-size:0.85rem;}
    .meta th{color:var(--primary-color); font-weight:500; white-space:nowrap;}
    .meta td{word-break:break-word;}
    /* toolbar tweaks */
    .input-group>.btn-icon {
        width: 34px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
    }
    .input-group .form-select-sm {
        padding-right: 0.5rem;
        padding-left: 0.5rem;
    }
    /* let the search field consume all remaining width */
    #searchInput {
        /* flex property removed */
        /* min-width removed */
    }
    #searchGroup {
        flex: 1 1 0;
    }
    /* Awesomplete dropdown above everything */
    .awesomplete > ul {
        z-index: 1055; /* above Bootstrap modal backdrop */
    }
    /* filter sidebar improvements */
    .filter-group {
        margin-bottom: 1.25rem;
    }
    .filter-group h6 {
        font-weight: 600;
        color: var(--primary-color);
        margin-bottom: 0.5rem;
    }
    .filter-section {
        margin-bottom: 0.75rem;
    }
    .filter-item {
        background: rgba(255,255,255,0.7);
        border-radius: 4px;
        padding: 3px 6px;
        display: inline-block;
        margin-right: 5px;
        margin-bottom: 5px;
        font-size: 0.9rem;
        border: 1px solid #eaeaea;
        cursor: pointer;
    }
    .filter-item:hover {
        background: white;
        border-color: var(--primary-color);
    }
    .filter-code {
        font-family: monospace;
        font-size: 0.9em;
        padding: 1px 3px;
        background: rgba(0,0,0,0.05);
        border-radius: 3px;
    }
    /* Make individual pattern cards scrollable */
    .pattern-card-body {
        max-height: 200px; /* Adjust height as needed */
        overflow-y: auto;
    }
    /* Ensure Summarized badge is visible */
    .fw-bold .badge.bg-success-subtle.text-success-emphasis {
        background-color: #198754 !important; /* Force Bootstrap success green background */
        color: white !important; /* Force white text */
        opacity: 1 !important; /* Ensure visible */
        visibility: visible !important; /* Ensure visible */
        margin-left: 5px; /* Add spacing */
    }
</style>

<div class="layout">
    <!-- Left Sidebar -->
    <div class="sidebar">
        <h5 class="mb-3 text-primary">Active Filters</h5>
        
        <!-- Dynamic Facets from search response -->
        <div id="facetList" class="mb-4 small"></div>
        
        <h6 class="text-pink" style="color:#ff6384">Search & Filter Help</h6>
        <p class="small mb-2">Type <em>anything</em> for natural-language search, plus add filters:</p>
        
        <div class="mb-3">
            <div class="mb-2 px-2 py-1 border rounded bg-white" style="cursor:pointer" onclick="document.getElementById('searchInput').value+=' category=&quot;AI Business&quot;'">
                category="AI Business"
            </div>
            <div class="mb-2 px-2 py-1 border rounded bg-white" style="cursor:pointer" onclick="document.getElementById('searchInput').value+=' sentiment=positive'">
                sentiment=positive
            </div>
            <div class="mb-2 px-2 py-1 border rounded bg-white" style="cursor:pointer" onclick="document.getElementById('searchInput').value+=' has:driver_type'">
                has:driver_type
            </div>
        </div>
        
        <h6 class="mt-4 text-primary">Operators</h6>
        <p class="mb-1 small">
            <code>=</code> / <code>equal</code> same as,<br>
            <code>!=</code> / <code>not&nbsp;equal</code> different from,<br>
            <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> compare values
        </p>
        <h6 class="mt-3 text-primary">Logic Operators</h6>
        <p class="mb-1 small">
            <code>AND</code> all terms match<br>
            <code>OR</code> any term matches<br> 
            <code>NOT</code> exclude following term
        </p>
        <p class="mb-1 small">
            <code>in(a,b,c)</code> set membership<br>
            <code>has:field</code> existence check<br>
            <code>field=min..max</code> range
        </p>
        <details class="mb-2">
          <summary class="small fw-semibold text-primary">Meta Controls &amp; Enhancement Examples</summary>
          <div class="mt-2 small">
            <h6 class="text-primary">Meta Controls</h6>
            <p class="mb-1">
              <code>sort:field[:asc|desc]</code> — sort results, e.g. <code>sort:publication_date:desc</code><br>
              <code>limit:n</code> — cap number of results, e.g. <code>limit:50</code><br>
              <code>similar:id</code> — find items like given id, e.g. <code>similar:abc123</code><br>
              <code>cluster=n</code> — restrict to cluster, e.g. <code>cluster=4</code>
            </p>
            <h6 class="text-primary mt-3">Enhancement</h6>
            <p class="mb-1">
              <code>^n</code> — boost term weight, e.g. <code>AI^3</code><br>
              <code>"exact phrase"</code> — exact match, e.g. <code>"artificial intelligence"</code><br>
              <code>"near phrase"~5</code> — proximity, e.g. <code>"climate change"~3</code>
            </p>
          </div>
        </details>
    </div>

    <!-- Center Main Content -->
    <div class="main">
        <div class="sticky-top bg-white pt-2" style="z-index:2;">
            <div class="input-group w-100 mb-2">
                <span class="input-group-text border-0 bg-transparent" id="searchIcon" style="cursor:pointer;" title="Search"><i class="fas fa-search"></i></span>
                <input type="text" id="searchInput" class="form-control border-0 shadow-none flex-grow-1" placeholder="Search news…">
                <button id="askAuspexBtn" class="btn btn-sm btn-outline-primary" style="height:34px;padding:0 .5rem;display:flex;align-items:center;justify-content:center;" title="Ask Auspex"><i class="fas fa-comment-dots"></i></button>
            </div>
            <div id="activeFilters" class="mb-2"></div>
            <!-- Tabs -->
            <ul class="nav nav-tabs small mb-2" id="resultTabs" role="tablist">
              <li class="nav-item" role="presentation"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#eventsPane" type="button" role="tab">Data Points</button></li>
              <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#patternsPane" type="button" role="tab">Patterns</button></li>
              <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#vizPane" type="button" role="tab">Visuals</button></li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="eventsPane" role="tabpanel">
                <canvas id="timelineChart" height="80"></canvas>
              </div>
              <div class="tab-pane fade" id="patternsPane" role="tabpanel">
                <div id="patternList" class="small p-2"></div>
              </div>
              <div class="tab-pane fade" id="vizPane" role="tabpanel">
                <div class="p-3 text-muted small" id="vizLoading">Loading…</div>
                <div class="d-flex align-items-center mb-1">
                  <select id="embedMethod" class="form-select form-select-sm me-2" style="width:120px;">
                    <option value="umap">UMAP</option>
                    <option value="tsne">t-SNE</option>
                    <option value="pca">PCA</option>
                  </select>
                  <div class="form-check me-2 small">
                    <input class="form-check-input" type="checkbox" id="embed3d">
                    <label class="form-check-label" for="embed3d">3D</label>
                  </div>
                  <select id="colorMode" class="form-select form-select-sm me-2" style="width:160px;">
                    <option value="cluster" selected>Color: cluster</option>
                    <option value="sentiment">Color: sentiment</option>
                    <option value="driver_type">Color: driver_type</option>
                    <option value="category">Color: category</option>
                    <option value="time_to_impact">Color: time_to_impact</option>
                  </select>
                  <div id="clusterLegend" class="small flex-wrap"></div>
                </div>
                <div id="scatter" style="width:100%;height:600px;display:none;"></div>
              </div>
            </div>
        </div>
        <div id="results"></div>
    </div>

    <!-- Right Metadata -->
    <div class="meta">
        <h5>Metadata</h5>
        <div id="metaContent" class="small"></div>
    </div>
</div>

<!-- Auspex summary modal -->
<div class="modal fade" id="auspexModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Auspex Summary</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="auspexContent">
        <div class="text-muted">Waiting for Auspex…</div>
      </div>
      <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="exportSummaryBtn" style="display: none;">Export Markdown</button>
          <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.min.js"></script>
<script>
// Global storage for summaries and associated articles
window._clusterSummaries = {};
window._clusterArticles = {};

// Interval IDs for rotating facts
let patternsLoadingIntervalId = null;
let vizLoadingIntervalId = null;
let auspexLoadingIntervalId = null;
// Interval IDs for countdown timers
let patternsCountdownId = null;
let vizCountdownId = null;
let auspexCountdownId = null;
// Fact rotation interval in seconds
const FACT_ROTATION_SECONDS = 18;

// Global storage for news facts
window._newsFacts = [];

const DEFAULT_PAGE_SIZE = 20; // Number of results per page for pagination

async function runSearch() {
    const raw = document.getElementById('searchInput').value;
    if (!raw) return;

    let parsed=parseQuery(raw);
    const metaExtra=extractMetaTokens(parsed);
    parsed.cleaned=metaExtra.cleaned;
    const metadata=parsed.metadata;
    const extra=metaExtra.extra;

    // Determine result cap (topK) and pagination size
    let topK = 10000; // default 10000 (effectively unlimited)
    let pageSize = DEFAULT_PAGE_SIZE;

    if (extra.limit !== undefined) {
        topK = extra.limit;
        if (topK === 0) { // treat 0 as unlimited
            topK = 10000;
            pageSize = DEFAULT_PAGE_SIZE; // Use default pagination for unlimited
        } else {
            pageSize = topK; // Fetch N, display N - no pagination needed
        }
    } else if (extra.cluster !== undefined) {
        // If filtering by cluster, fetch more initially to ensure the cluster is likely represented
        // Let pagination handle display limit.
        topK = 1000; // Fetch more if filtering by cluster
        pageSize = DEFAULT_PAGE_SIZE;
    }
    // Store page size globally for pagination rendering
    window._pageSize = pageSize;

    let data;

    // Keyword operator – runs full-text keyword search pathway
    if(parsed.metadata.keyword){
        const kw = parsed.metadata.keyword;
        delete parsed.metadata.keyword; // do not forward as vector filter

        const params=new URLSearchParams({
            keyword: kw,
            per_page: topK, // Use topK for API limit
            search_fields: 'title,summary,tags',
        });
        const res=await fetch(`/api/search_articles?${params.toString()}`);
        const raw=await res.json();
        const kwResults = raw.articles.map(a=>({id:a.uri,score:0,metadata:a}));
        // Build facets and simple timeline (by category & date)
        const facets = {};
        const timeline = {};
        kwResults.forEach(res=>{
            const m=res.metadata;
            ["topic","category","news_source","driver_type","sentiment"].forEach(f=>{
                if(m[f]){
                    facets[f]??={};
                    facets[f][m[f]] = (facets[f][m[f]]||0)+1;
                }
            });
            if(m.publication_date){
                const d=new Date(m.publication_date).toISOString().split('T')[0];
                const cat=m.category||'Uncategorized';
                timeline[cat]??={};
                timeline[cat][d]=(timeline[cat][d]||0)+1;
            }
        });
        data={results:kwResults,facets,timeline};
    }else{
        const params = new URLSearchParams({ q: parsed.cleaned, top_k: topK }); // Use topK for API limit
        if(extra.sort){params.append('sort',extra.sort.join(':'));}
        if (extra.cluster !== undefined) { params.append('cluster', extra.cluster); }
        Object.entries(metadata).forEach(([k,v])=>params.append(k, v));
        const res = await fetch(`/api/vector-search?${params.toString()}`);
        data = await res.json();
    }
    currentIndex=0;
    lastResults=data.results;
    selectedUris.clear();
    updateActionButtons();
    renderNextPage();
    const facets=data.facets || {};
    renderFacets(facets);
    updateAttrSuggestions(facets);
    renderTimeline(data.timeline || {});
    updateActiveChips();
}

function renderResults(results, reset=false) {
    const container = document.getElementById('results');
    if(reset){container.innerHTML='';}
    results.forEach(r => {
        const card = document.createElement('div');
        card.className = 'card mb-2 position-relative ps-5';
        // Selection checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-check-input position-absolute';
        checkbox.style.left = '12px';
        checkbox.style.top = '18px';
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                selectedUris.add(r.id);
            } else {
                selectedUris.delete(r.id);
            }
            updateActionButtons();
        });

        const body = document.createElement('div');
        body.className = 'card-body';
        const title = r.metadata.title || 'Untitled';
        const link = r.metadata.uri ? `<a href="${r.metadata.uri}" target="_blank" rel="noopener">${title}</a>` : title;
        const summary = (r.metadata.summary || '').slice(0, 160);
        const cat = r.metadata.category ? `Category: ${r.metadata.category}` : '';
        const topic = r.metadata.topic ? `Topic: ${r.metadata.topic}` : '';
        const pub = r.metadata.publication_date ? new Date(r.metadata.publication_date).toISOString().split('T')[0] : '';

        body.innerHTML = `<h6 class="ms-4">${link}</h6>
            <p class='mb-1 ms-4'><small>${pub} · ${r.metadata.news_source || ''}</small></p>
            <p class='mb-1 text-muted small ms-4'>${summary}</p>
            <p class='mb-1 ms-4'><small>${cat}${cat && topic ? ' · ' : ''}${topic}</small></p>
            <p class='mb-1 ms-4'><small>Score: ${r.score.toFixed(3)}</small></p>
            <div class='d-flex gap-1 ms-4 mb-1'>
              <button class="btn icon-btn view-db" data-uri="${r.id}" title="View / edit"><i class="fas fa-eye"></i></button>
              <button class="btn icon-btn edit-note" data-uri="${r.id}" title="Annotate"><i class="fas fa-pen"></i></button>
              <a href="https://12ft.io/${r.metadata.uri}" target="_blank" class="btn icon-btn" title="Bypass paywall"><i class="fas fa-unlock"></i></a>
              <a href="https://archive.is/newest/${r.metadata.uri}" target="_blank" class="btn icon-btn" title="Archive snapshot"><i class="fas fa-box"></i></a>
            </div>`;
        card.appendChild(body);
        card.appendChild(checkbox);
        card.addEventListener('click', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'A' || e.target.closest('a')) return;
            renderMetadata(r.metadata);
        });
        container.appendChild(card);
    });
}

function renderFacets(facets) {
    const el = document.getElementById('facetList');
    el.innerHTML = '';
    Object.entries(facets).forEach(([field, values]) => {
        const group = document.createElement('div');
        group.className = 'mb-2';
        group.innerHTML = `<strong>${field}</strong>`;
        const list = document.createElement('ul');
        list.className = 'list-unstyled ms-2';

        const entries = Object.entries(values).sort((a, b) => b[1] - a[1]);
        entries.forEach(([val, count], idx) => {
            const li = document.createElement('li');
            if (idx >= 5) li.classList.add('d-none', 'extra');
            li.innerHTML = `<a href="#" data-field="${field}" data-value="${val}">${val}</a> <span class="text-muted">(${count})</span>`;
            list.appendChild(li);
        });

        if (entries.length > 5) {
            const toggle = document.createElement('a');
            toggle.href = '#';
            toggle.className = 'small';
            toggle.textContent = 'show more...';
            toggle.addEventListener('click', (e) => {
                e.preventDefault();
                list.querySelectorAll('.extra').forEach(li => li.classList.toggle('d-none'));
                toggle.textContent = toggle.textContent.startsWith('show') ? 'show less' : 'show more...';
            });
            group.appendChild(list);
            group.appendChild(toggle);
        } else {
            group.appendChild(list);
        }

        el.appendChild(group);
    });

    // Add click handler to facet links to auto-fill filters and rerun search
    el.querySelectorAll('a[data-field]').forEach((a) => {
        a.addEventListener('click', (evt) => {
            evt.preventDefault();
            const { field, value } = a.dataset;
            const input=document.getElementById('searchInput');
            const simple=`${field}="${value}"`;
            const legacy=`filter(${field}="${value}")`;
            if(input.value.includes(simple)){
                input.value=input.value.replace(simple,'').trim();
            }else if(input.value.includes(legacy)){
                input.value=input.value.replace(legacy,'').trim();
            }else{
                input.value=`${input.value} ${simple}`.trim();
            }
            runSearch();
        });
    });
}

// Simple bar chart with Chart.js (use CDN)
let timelineChart;
async function renderTimeline(timeline){
    if(!timeline || !Object.keys(timeline).length){return;}

    // Build date axis
    const dateSet=new Set();
    Object.values(timeline).forEach(catObj=>{
        Object.keys(catObj).forEach(d=>dateSet.add(d));
    });
    const labels=Array.from(dateSet).sort();

    const palette=[
        '#6c63ff','#ff6384','#36a2eb','#ff9f40','#4bc0c0','#9966ff','#c9cbcf',
    ];
    const datasets=Object.entries(timeline).map(([cat,obj],idx)=>({
        label:cat,
        data:labels.map(d=>obj[d]||0),
        backgroundColor:palette[idx%palette.length],
        stack:'stack1'
    }));

    if(!window.Chart){await loadChartJs();}
    const ctx=document.getElementById('timelineChart').getContext('2d');
    if(timelineChart){timelineChart.destroy();}
    timelineChart=new Chart(ctx,{
        type:'bar',
        data:{labels,datasets},
        options:{
            plugins:{legend:{display:true,position:'bottom'}},
            scales:{
                x:{stacked:true,ticks:{autoSkip:true,maxTicksLimit:10}},
                y:{stacked:true,beginAtZero:true},
            }
        }
    });
}

function loadChartJs(){
    return new Promise(res=>{
        const s=document.createElement('script');
        s.src='https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
        s.onload=res;
        document.head.appendChild(s);
    });
}

function renderMetadata(meta){
    const pre = document.getElementById('metaContent');
    const rows = Object.entries(meta).map(([k,v])=>{
        let val = v;
        if(k==='uri' || k==='url'){
            val = `<a href="${v}" target="_blank">link</a>`;
        }
        if(['topic','category','news_source','sentiment'].includes(k)){
            val = `<a href="#" class="meta-filter" data-field="${k}" data-val="${v}">${v}</a>`;
        }
        return `<tr><th class='text-end pe-2'>${k}</th><td>${val ?? ''}</td></tr>`;
    }).join('');
    pre.innerHTML = `<table class='table table-sm'>${rows}</table>`;

    // Related articles (same topic)
    const relDiv = document.createElement('div');
    relDiv.innerHTML = '<h6 class="mt-3">Related</h6>';
    const relList=document.createElement('ul');
    relList.className='list-unstyled small';
    // Fetch from backend similar endpoint
    fetch(`/api/vector-similar?uri=${encodeURIComponent(meta.uri)}&top_k=5`).then(r=>r.json()).then(d=>{
        d.results.forEach(r=>{
            const li=document.createElement('li');
            li.innerHTML=`<a href="#" class="related-link" data-id="${r.id}">${r.metadata.title}</a>`;
            relList.appendChild(li);
        });
    });
    relDiv.appendChild(relList);
    pre.appendChild(relDiv);

    // click related link to drill
    pre.querySelectorAll('.related-link').forEach(a=>{
        a.addEventListener('click',e=>{
            e.preventDefault();
            const id=a.dataset.id;
            const target= (lastResults||[]).find(r=>r.id===id);
            if(target) renderMetadata(target.metadata);
        });
    });

    // drill-down meta filters
    pre.querySelectorAll('.meta-filter').forEach(a=>{
        a.addEventListener('click',e=>{
            e.preventDefault();
            const { field, val } = a.dataset;
            const input=document.getElementById('searchInput');
            const token=`${field}="${val}"`;
            if(!input.value.includes(token)){
                input.value=`${input.value} ${token}`.trim();
            }
            runSearch();
        });
    });
}

// -------------
// Filter parser
// -------------
function parseQuery(q){
    const metadata = {};
    const filterRegex = /filter\(([^)]+)\)/g;
    let cleaned=q;
    let m;
    while((m=filterRegex.exec(q))!==null){
        cleaned=cleaned.replace(m[0],'').trim();
        const inner=m[1];
        // Find every key="value" (quotes required to allow spaces)
        const pairRe=/(\w+)\s*=\s*"([^"]+)"/g;
        let p;
        while((p=pairRe.exec(inner))!==null){
            metadata[p[1]]=p[2];
        }
    }
    // ---------------------------------------------------
    // Natural-language operator synonyms → symbolic form
    // Ex: "status equal active" → "status = active"
    //     "status not equal inactive" → "status != inactive"
    // We normalise textual operators before regex parsing.
    cleaned = cleaned
        .replace(/(\b\w+)\s+not\s+equal(?:s)?\b/gi, '$1 !=')
        .replace(/(\b\w+)\s+(?:equals?|equal|is|compare)\b/gi, '$1 =');
    // ----------------------------------------------
    // 2. Simple attribute operators (field op value)
    // ----------------------------------------------
    // Supported ops: = != >= <= > <
    // We only forward equality to the backend for now – others stay in *cleaned* for full-text search / future use.
    // Copy of the query to safely scan attribute tokens without mutating in-place
    const scan = cleaned;
    const attrRe = /(\b\w+)\s*(=|!=|>=|<=|>|<)\s*("[^"]+"|[^\s]+)/g;
    let match;
    while((match = attrRe.exec(scan)) !== null){
        const [full, field, op, rawVal] = match;
        let val = rawVal;
        if(val.startsWith('"') && val.endsWith('"')){
            val = val.slice(1,-1);
        }
        if(op === '='){
            metadata[field] = val;
            cleaned = cleaned.replace(full,'').trim();
        }
    }
    // cluster:n or cluster=n
    cleaned=cleaned.replace(/\bcluster(?:=|:)(\d+)\b/i,(m,n)=>{extra.cluster=parseInt(n);return '';});
    return {cleaned, metadata};
}

// Helper to extract limit & sort tokens; augment parseQuery externally
function extractMetaTokens(qObj){
  const extra={};
  let {cleaned}=qObj;
  // limit:n
  cleaned=cleaned.replace(/\blimit:(\d+)\b/i,(m,n)=>{extra.limit=parseInt(n);return '';});
  // sort:field[:dir]
  cleaned=cleaned.replace(/\bsort:([\w_]+)(?::(asc|desc))?/i,(m,f,d)=>{extra.sort=[f,d||'asc'];return ''});
  // cluster:n or cluster=n
  cleaned=cleaned.replace(/\bcluster(?:=|:)(\d+)\b/i,(m,n)=>{extra.cluster=parseInt(n);return '';});
  return {cleaned:cleaned.trim(), extra};
}

function updateActiveChips() {
    const container = document.getElementById('activeFilters');
    const { metadata } = parseQuery(document.getElementById('searchInput').value);
    container.innerHTML = '';

    Object.entries(metadata).forEach(([field, value]) => {
        const chip = document.createElement('span');
        chip.className = 'badge bg-primary me-1';
        chip.style.cursor = 'pointer';
        chip.textContent = `${field}: ${value} ×`;
        chip.addEventListener('click', () => {
            const raw = document.getElementById('searchInput').value;
            let updated = raw.replace(`filter(${field}="${value}")`,'');
            updated = updated.replace(`${field}="${value}"`, '').replace(`${field}=${value}`,'');
            document.getElementById('searchInput').value = updated.trim();
            runSearch();
        });
        container.appendChild(chip);
    });
    if (!Object.keys(metadata).length) {
        container.innerHTML = '<small class="text-muted">No filters applied</small>';
    }
}

// Selected URIs – retained for potential future actions
const selectedUris = new Set();
function updateActionButtons() {/* no-op – legacy buttons removed */}

document.getElementById('searchIcon').addEventListener('click', runSearch);
// Trigger search on Enter key inside input
document.getElementById('searchInput').addEventListener('keydown',e=>{if(e.key==='Enter'){runSearch();}});

// Annotation modal appended at end of body when DOM ready
if(!document.getElementById('noteModal')){
    const modalHtml=`<div class="modal fade" id="noteModal" tabindex="-1"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">Annotate</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><textarea id="noteText" class="form-control" rows="4"></textarea><div class="form-check mt-2"><input class="form-check-input" type="checkbox" id="notePrivate"><label class="form-check-label">Private</label></div></div><div class="modal-footer"><button class="btn btn-primary" id="noteSave">Save</button></div></div></div></div>`;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

let currentAnnotateUri='';
document.body.addEventListener('click',e=>{
    const noteBtn=e.target.closest('.edit-note');
    if(noteBtn){
        currentAnnotateUri=noteBtn.dataset.uri;
        document.getElementById('noteText').value='';
        document.getElementById('notePrivate').checked=false;
        bootstrap.Modal.getOrCreateInstance(document.getElementById('noteModal')).show();
    }
});

document.getElementById('noteSave').addEventListener('click',async()=>{
    const txt=document.getElementById('noteText').value.trim();
    if(!txt) return;
    await fetch(`/api/articles/${encodeURIComponent(currentAnnotateUri)}/annotations`,{
        method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({content:txt,is_private:document.getElementById('notePrivate').checked})
    });
    bootstrap.Modal.getInstance(document.getElementById('noteModal')).hide();
    alert('Annotation saved');
});

// Article detail modal
if(!document.getElementById('articleModal')){
    document.body.insertAdjacentHTML('beforeend',`<div class="modal fade" id="articleModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">Article Detail</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div id="articleDetail">Loading…</div></div></div></div></div>`);
}

document.body.addEventListener('click',async e=>{
    const btn=e.target.closest('.view-db');
    if(btn){
        const uri=btn.dataset.uri;
        const detailBox=document.getElementById('articleDetail');
        detailBox.textContent='Loading…';
        bootstrap.Modal.getOrCreateInstance('#articleModal').show();
        const res=await fetch(`/api/article?uri=${encodeURIComponent(uri)}`);
        if(res.ok){
            const data=await res.json();
            detailBox.innerHTML=`<pre class='small'>${JSON.stringify(data,null,2)}</pre>`;
        }else{
            detailBox.textContent='Failed to load article.';
        }
    }
});

// Search mode dropdown handlers
// (search mode dropdown removed – keyword search handled via keyword= operator)

// ---------------------------
// Embedding visualisation (Plotly)
// ---------------------------
// Load and render once when the tab first becomes visible
let scatterLoaded=false;
document.querySelector('button[data-bs-target="#vizPane"]').addEventListener('shown.bs.tab',()=>{
    if(scatterLoaded) return;
    scatterLoaded=true;
    initScatter();
});

async function initScatter(){
    const loading=document.getElementById('vizLoading');
    const div=document.getElementById('scatter');

    // Bring in plotly if missing
    if(!window.Plotly){
        await new Promise(res=>{
            const s=document.createElement('script');
            s.src='https://cdn.plot.ly/plotly-2.27.0.min.js';
            s.onload=res;
            document.head.appendChild(s);
        });
    }

    // Initial fetch
    window.scatterPoints=[];
    await updateScatter();

    // click handler
    div.on('plotly_click',async ev=>{
        const idx=ev.points[0].pointIndex;
        if(!window.scatterPoints || !window.scatterPoints[idx]){return;}
        const selId=window.scatterPoints[idx].id;
        const neighbours=await fetch(`/api/embedding_neighbours?id=${encodeURIComponent(selId)}&top_k=5`).then(r=>r.json());
        const ids=[selId,...neighbours.map(n=>n.id)];
        const style=window.scatterPoints.map(p=>ids.includes(p.id)?1:0.15);
        Plotly.restyle(div,{ 'marker.opacity':[style] });
    });

    loading.style.display='none';
    div.style.display='block';
}

// Refresh scatter with current filters
async function updateScatter(){
    const loading=document.getElementById('vizLoading');
    const div=document.getElementById('scatter');

    // Show spinner and random fact
    let randomFact = window._newsFacts.length > 0 ? window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)] : 'Generating visualization...';
    // Clear previous interval if any
    if (vizLoadingIntervalId) clearInterval(vizLoadingIntervalId);
    // Clear any existing countdown
    if (vizCountdownId) {
      clearInterval(vizCountdownId);
      vizCountdownId = null;
    }

    loading.innerHTML = `
        <div class="d-flex justify-content-center align-items-center p-4 my-4">
            <div class="spinner-border text-primary me-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div id="viz-loading-fact" class="fs-6">
                <strong>Did you know?...</strong> ${randomFact}
                <span id="viz-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>
            </div>
        </div>`;
    loading.style.display = 'block';
    div.style.display = 'none'; // Hide plot while loading

    // Start countdown timer (updates every second)
    let secondsLeft = FACT_ROTATION_SECONDS;
    vizCountdownId = setInterval(() => {
      secondsLeft -= 1;
      const countdownEl = document.getElementById('viz-countdown');
      if (countdownEl) {
        countdownEl.textContent = `${secondsLeft}s`;
      }
      if (secondsLeft <= 0) {
        secondsLeft = FACT_ROTATION_SECONDS; // Reset when a new fact appears
      }
    }, 1000);

    // Start interval to rotate facts
    vizLoadingIntervalId = setInterval(() => {
        const factElement = document.getElementById('viz-loading-fact');
        if (factElement && window._newsFacts.length > 0) {
            let newFact = window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)];
            factElement.innerHTML = `<strong>Did you know?...</strong> ${newFact}
                <span id="viz-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>`;
            // Reset the countdown
            secondsLeft = FACT_ROTATION_SECONDS;
        }
    }, FACT_ROTATION_SECONDS * 1000);

    // Build filter params
    const { metadata } = parseQuery(document.getElementById('searchInput').value);
    const params=new URLSearchParams();
    Object.entries(metadata).forEach(([k,v])=>params.append(k,v));
    const dims3d=document.getElementById('embed3d').checked;
    const colorMode=document.getElementById('colorMode').value;
    params.append('method',document.getElementById('embedMethod').value);
    params.append('dims',dims3d?'3':'2');
    const res=await fetch(`/api/embedding_projection?${params.toString()}`);
    const data=await res.json();

    const pts = data.points || data;
    if(!pts.length){loading.textContent='No data';return;}

    window.scatterPoints=pts;
    window.clusterExplain=data.explain||{};
    window.clusterCentroids=data.centroids||{};

    const custom=pts.map(p=>(window.clusterExplain[p.cluster]||[]).join(', '));

    const colorSentiment=false;
    let legendItems;
    let colourMap=new Map();
    let pointColors;

    if(colorMode!=='cluster'){
        legendItems=[...new Set(pts.map(p=>(p[colorMode]||'unknown')))].sort();
        const colours=palette(legendItems.length);
        legendItems.forEach((s,idx)=>colourMap.set(s,colours[idx]));
        pointColors=pts.map(p=>colourMap.get(p[colorMode]||'unknown'));
    }else{
        legendItems=[...new Set(pts.map(p=>p.cluster))].sort((a,b)=>a-b);
        const colours=palette(legendItems.length);
        legendItems.forEach((c,idx)=>colourMap.set(c,colours[idx]));
        pointColors=pts.map(p=>colourMap.get(p.cluster));
    }

    let trace;
    let layout;
    if(dims3d){
        trace={
          type:'scatter3d',mode:'markers',
          x:pts.map(p=>p.x),
          y:pts.map(p=>p.y),
          z:pts.map(p=>p.z||0),
          marker:{size:3,color:pointColors,opacity:0.8},
          text:pts.map(p=>p.title||''),
          customdata:custom,
          hovertemplate:'%{text}<br><small>%{customdata}</small><extra></extra>'
        };
        layout={margin:{t:0,l:0,r:0,b:0},scene:{aspectmode:'data'}};
    }else{
        trace={
          type:'scattergl',mode:'markers',
          x:pts.map(p=>p.x),
          y:pts.map(p=>p.y),
          marker:{size:7,color:pointColors,opacity:0.9},
          text:pts.map(p=>p.title||''),
          customdata:custom,
          hovertemplate:'%{text}<br><small>%{customdata}</small><extra></extra>'
        };
        layout={margin:{t:0,l:0,r:0,b:0},hovermode:'closest'};
    }
    Plotly.react(div,[trace],layout);

    // Build legend after fetching points
    rebuildLegend(legendItems, colourMap, colorMode!=='cluster', colorMode);

    loading.style.display='none';
    // Clear the interval timer now that viz is loaded
    if (vizLoadingIntervalId) {
       clearInterval(vizLoadingIntervalId);
       vizLoadingIntervalId = null;
    }
    // Also clear the countdown
    if (vizCountdownId) {
      clearInterval(vizCountdownId);
      vizCountdownId = null;
    }
    div.style.display = 'block'; // Show plot again
}

// Utility to build filter params object
function buildQueryParams(){
  const { cleaned, metadata } = parseQuery(document.getElementById('searchInput').value);
  const p=new URLSearchParams();
  if(cleaned){p.append('q', cleaned);}
  Object.entries(metadata).forEach(([k,v])=>p.append(k,v));
  return p;
}

function buildFilterParams(){
  const { metadata } = parseQuery(document.getElementById('searchInput').value);
  return metadata;
}

// ---------------------------
// Patterns and Statistics loaders
// ---------------------------
let patternsLoaded=false;

document.querySelector('button[data-bs-target="#patternsPane"]').addEventListener('shown.bs.tab',()=>{
  if(patternsLoaded) return;
  loadPatterns();
  patternsLoaded=true;
});

async function loadPatterns(){
  const list = document.getElementById('patternList');
  
  // Show spinner and random fact
  let randomFact = window._newsFacts.length > 0 ? 
      window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)] : 
      'Generating patterns...';
  
  // Clear any existing interval
  if (patternsLoadingIntervalId) {
    clearInterval(patternsLoadingIntervalId);
    patternsLoadingIntervalId = null;
  }
  // Clear any existing countdown
  if (patternsCountdownId) {
    clearInterval(patternsCountdownId);
    patternsCountdownId = null;
  }
  
  // Set loading indicator with spinner and fact
  list.innerHTML = `
    <div class="d-flex justify-content-center align-items-center p-4 my-4">
      <div class="spinner-border text-primary me-3" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div id="patterns-loading-fact" class="fs-6">
        <strong>Did you know?...</strong> ${randomFact}
        <span id="patterns-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>
      </div>
    </div>`;
  
  // Start countdown timer (updates every second)
  let secondsLeft = FACT_ROTATION_SECONDS;
  patternsCountdownId = setInterval(() => {
    secondsLeft -= 1;
    const countdownEl = document.getElementById('patterns-countdown');
    if (countdownEl) {
      countdownEl.textContent = `${secondsLeft}s`;
    }
    if (secondsLeft <= 0) {
      secondsLeft = FACT_ROTATION_SECONDS; // Reset when a new fact appears
    }
  }, 1000);

  // Start interval to rotate facts
  patternsLoadingIntervalId = setInterval(() => {
    const factElement = document.getElementById('patterns-loading-fact');
    if (factElement && window._newsFacts.length > 0) {
      let newFact = window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)];
      factElement.innerHTML = `<strong>Did you know?...</strong> ${newFact}
        <span id="patterns-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>`;
      // Reset the countdown
      secondsLeft = FACT_ROTATION_SECONDS;
    }
  }, FACT_ROTATION_SECONDS * 1000);
  
  try {
    // Fetch data
    const queryParams = buildQueryParams();
    
    // Fetch ngrams and outliers (existing logic)
    const patternsRes = await fetch(`/api/patterns?${queryParams}`);
    const patternsData = await patternsRes.json();
    
    // Fetch cluster data
    const clusterRes = await fetch(`/api/embedding_projection?dims=2&${queryParams}`);
    const clusterData = await clusterRes.json();
    const clusterExplain = clusterData.explain || {};
    const points = clusterData.points || [];
    const clusterCounts = {};
    // Store article IDs per cluster for actions
    const clusterMemberIds = {};
    
    points.forEach(p => {
      clusterCounts[p.cluster] = (clusterCounts[p.cluster] || 0) + 1;
      if (!clusterMemberIds[p.cluster]) {
        clusterMemberIds[p.cluster] = [];
      }
      clusterMemberIds[p.cluster].push(p.id);
    });
    
    // Card for Top Keywords
    let keywordsHtml = '<div class="card mb-3"><div class="card-header">Top Keywords</div><div class="card-body pattern-card-body">';
    (patternsData.ngrams||[]).slice(0,20).forEach(ng => {
      keywordsHtml += `<span class="badge bg-secondary me-1 mb-1">${ng.text} (${ng.count})</span>`;
    });
    keywordsHtml += '</div></div>'; // Close keywords card
    
    // Card for Cluster Summary
    let clustersHtml = '<div class="card mb-3"><div class="card-header">Cluster Summary</div><div class="card-body pattern-card-body">';
    if (Object.keys(clusterExplain).length > 0) {
      clustersHtml += '<div class="list-group list-group-flush">';
      Object.entries(clusterExplain).sort(([idA], [idB]) => parseInt(idA) - parseInt(idB)).forEach(([id, keywords]) => {
        const count = clusterCounts[id] || 0;
        const hasSummary = window._clusterSummaries && window._clusterSummaries[id];
        clustersHtml += `
          <div class="list-group-item d-flex justify-content-between align-items-start py-1 px-0">
            <div class="ms-2 me-auto flex-grow-1">
              <div class="fw-bold">Cluster ${id} 
                <span class="badge bg-light text-dark rounded-pill me-1">${count} items</span>
                ${hasSummary ? '<span class="badge bg-success-subtle text-success-emphasis rounded-pill">Summarized</span>' : ''}
              </div>
              <small class="text-muted d-block mb-1">${keywords.slice(0, 5).join(', ')}</small>
            </div>
            <div class="ms-2">
              <button class="btn btn-sm btn-outline-secondary p-1 filter-cluster-btn" data-cluster-id="${id}" title="Filter by this cluster">
                <i class="fas fa-filter fa-xs"></i>
              </button>
              <button class="btn btn-sm btn-outline-primary p-1 summarize-cluster-btn" data-cluster-id="${id}" title="Summarize with Auspex">
                <i class="fas fa-comment-dots fa-xs"></i>
              </button>
            </div>
          </div>`;
      });
      clustersHtml += '</div>';
    } else {
      clustersHtml += '<small class="text-muted">No cluster data available.</small>';
    }
    clustersHtml += '</div></div>'; // Close clusters card
    
    // Card for Outliers
    let outliersHtml = '<div class="card mb-3"><div class="card-header">Outliers</div><div class="card-body pattern-card-body">';
    // Fetch top anomalies
    const anoRes = await fetch(`/api/embedding_anomalies?${queryParams}`);
    const anomalies = await anoRes.json();
    if (anomalies.length > 0) {
      outliersHtml += anomalies.map(a => `
        <div class="border-bottom py-1">
          <a href="#" class="outlier-link" data-id="${a.id}">${a.metadata.title || 'Untitled'}</a>
          <small class="text-muted">score ${a.score.toFixed(3)}</small>
        </div>`).join('');
    } else {
      outliersHtml += '<small class="text-muted">No outliers found.</small>';
    }
    outliersHtml += '</div></div>'; // Close outliers card
    
    // Combine HTML for all cards
    list.innerHTML = keywordsHtml + clustersHtml + outliersHtml;
    
    // Store cluster member IDs globally for event handlers
    window._clusterMemberIds = clusterMemberIds;
    
    // click to open metadata
    list.querySelectorAll('.outlier-link').forEach(link => {
      link.addEventListener('click', async e => {
        e.preventDefault();
        const id = link.dataset.id;
        let target = (window.lastResults || []).find(r => r.id === id);
        if (!target) {
          const res = await fetch(`/api/article?uri=${encodeURIComponent(id)}`);
          if (res.ok) {
            const meta = await res.json();
            renderMetadata(meta);
            return;
          }
        }
        if (target) { renderMetadata(target.metadata); }
      });
    });
  } catch (error) {
    console.error("Error loading patterns:", error);
    list.innerHTML = `<div class="alert alert-danger">Error loading patterns: ${error.message}</div>`;
  } finally {
    // Always clear the interval, even on error
    if (patternsLoadingIntervalId) {
      clearInterval(patternsLoadingIntervalId);
      patternsLoadingIntervalId = null;
    }
    // Also clear the countdown
    if (patternsCountdownId) {
      clearInterval(patternsCountdownId);
      patternsCountdownId = null;
    }
  }
}

// ---------------------------
// Visualization helpers – method dropdown & legend
// ---------------------------
document.getElementById('embedMethod').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

document.getElementById('embed3d').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

document.getElementById('colorMode').addEventListener('change',()=>{
  if(scatterLoaded){updateScatter();}
});

function rebuildLegend(items, colourMap, nonCluster=false, colorMode='cluster'){
  const container=document.getElementById('clusterLegend');
  container.innerHTML='';
  items.forEach(idx=>{
    const span=document.createElement('span');
    span.className='badge me-1';
    span.style.background=colourMap.get(idx)||'#6c63ff';
    span.style.cursor='pointer';
    let label;
    if(nonCluster){
      label=idx;
    }else{
      const kw=(window.clusterExplain||{})[idx]||[];
      label=kw.length?kw.slice(0,2).join(', '):`Cluster ${idx}`;
      if(kw.length){span.title=kw.join(', ');}  // tooltip for cluster mode
    }
    span.textContent=label;
    span.addEventListener('click',()=>{
      window._activeLabel=window._activeLabel||null;
      if(window._activeLabel===idx){
        // toggle off – reset all
        Plotly.restyle('scatter',{'marker.opacity':[window.scatterPoints.map(()=>0.9)]});
        window._activeLabel=null;
        return;
      }
      const style=window.scatterPoints.map(p=>{
        if(colorMode!=='cluster'){
            return (p[colorMode]||'unknown')===idx?1:0.15;
        }
        return p.cluster===idx?1:0.15;
      });
      Plotly.restyle('scatter',{'marker.opacity':[style]});
      window._activeLabel=idx;
    });
    container.appendChild(span);
  });
}

// simple fallback: cycle through a fixed palette
function palette(n){
  const base = ['#6c63ff','#36a2eb','#ff6384','#ff9f40',
                '#4bc0c0','#9966ff','#c9cbcf'];
  const colours = [];
  for (let i = 0; i < n; i++) colours.push(base[i % base.length]);
  return colours;
}

// Pagination helpers
let currentIndex=0;
const loadMoreBtn=document.createElement('button');
loadMoreBtn.textContent='Load more';
loadMoreBtn.className='btn btn-outline-primary w-100 my-2';
loadMoreBtn.style.display='none';
loadMoreBtn.addEventListener('click',()=>renderNextPage());
document.getElementById('results').after(loadMoreBtn);

function renderNextPage(){
  const per = window._pageSize;
  const slice=lastResults.slice(currentIndex, currentIndex + per);
  if(!slice.length){
    loadMoreBtn.style.display='none';
    return;
  }
  renderResults(slice, currentIndex===0);
  currentIndex+=slice.length;
  if(currentIndex>=lastResults.length){
      loadMoreBtn.style.display='none';
  }else{
      loadMoreBtn.style.display='block';
  }
}

// ---------------------------
// Autosuggest / autocomplete helpers (Awesomplete)
// ---------------------------
const awesomplete = new Awesomplete(
  document.getElementById('searchInput'),
  { minChars: 1, maxItems: 20, autoFirst: true }
);
// Seed with base tokens so autocomplete works before first search
updateAttrSuggestions({});

function updateAttrSuggestions(facets){
  const seen=new Set();
  const addVal=v=>{if(!seen.has(v)){seen.add(v);} };
  ['keyword=','topic=','category=','sentiment=','driver_type=','future_signal=',
   'news_source=','has:','similar:','cluster=',
   'sort:','limit:','AND','OR','NOT',
   '^','!=','>=','<=','>','<'].forEach(addVal);
  Object.entries(facets||{}).forEach(([field,vals])=>{
    Object.keys(vals).slice(0,50).forEach(val=>addVal(`${field}="${val}"`));
  });
  awesomplete.list=[...seen];
}

// ---------------------------
// Auspex integration – summarise results
// ---------------------------
document.getElementById('askAuspexBtn').addEventListener('click', () => askAuspex()); // Call without args for general summary

async function askAuspex(idsToSummarize = null, clusterId = null, modelName = null) {
    // If no specific IDs are passed, use selection or all results
    let ids = idsToSummarize;
    if (!ids) {
        if(!window.lastResults || !window.lastResults.length){alert('Run a search first');return;}
        const idsSelected = Array.from(window.selectedUris || []);
        ids = (idsSelected.length ? idsSelected : window.lastResults.map(r => r.id)).slice(0, 100);
        clusterId = null; // Ensure clusterId is null for general summary
    }

    const auspexContent = document.getElementById('auspexContent');
    const exportBtn = document.getElementById('exportSummaryBtn');
    const modalElement = document.getElementById('auspexModal');
    modalElement.dataset.clusterId = clusterId; // Store clusterId for export
    exportBtn.style.display = 'none'; // Hide export button initially

    // Clear previous interval if any
    if (auspexLoadingIntervalId) clearInterval(auspexLoadingIntervalId);
    // Clear any existing countdown
    if (auspexCountdownId) {
      clearInterval(auspexCountdownId);
      auspexCountdownId = null;
    }

    try{
        // Show progress indicator with rotating fact
        let randomFact = window._newsFacts.length > 0 ? window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)] : 'Querying Auspex...';
        auspexContent.innerHTML = `
            <div class="d-flex justify-content-center align-items-center p-4 my-4">
                <div class="spinner-border text-primary me-3" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div id="auspex-loading-fact" class="fs-6">
                    <strong>Did you know?...</strong> ${randomFact}
                    <span id="auspex-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>
                </div>
            </div>`;

        const modalObj=new bootstrap.Modal(document.getElementById('auspexModal'));
        modalObj.show();

        // Start countdown timer (updates every second)
        let secondsLeft = FACT_ROTATION_SECONDS;
        auspexCountdownId = setInterval(() => {
          secondsLeft -= 1;
          const countdownEl = document.getElementById('auspex-countdown');
          if (countdownEl) {
            countdownEl.textContent = `${secondsLeft}s`;
          }
          if (secondsLeft <= 0) {
            secondsLeft = FACT_ROTATION_SECONDS; // Reset when a new fact appears
          }
        }, 1000);

        // Start interval to rotate facts
        auspexLoadingIntervalId = setInterval(() => {
            const factElement = document.getElementById('auspex-loading-fact');
            if (factElement && window._newsFacts.length > 0) {
                let newFact = window._newsFacts[Math.floor(Math.random() * window._newsFacts.length)];
                factElement.innerHTML = `<strong>Did you know?...</strong> ${newFact}
                    <span id="auspex-countdown" class="badge rounded-pill bg-secondary ms-2">${FACT_ROTATION_SECONDS}s</span>`;
                // Reset the countdown
                secondsLeft = FACT_ROTATION_SECONDS;
            }
        }, FACT_ROTATION_SECONDS * 1000);

        const res=await fetch('/api/vector-summary',{
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({ids:ids, model: modelName}) // Pass model name if provided
        });

        // Clear the interval timer now that fetch is complete
        if (auspexLoadingIntervalId) {
           clearInterval(auspexLoadingIntervalId);
           auspexLoadingIntervalId = null;
        }
        // Also clear the countdown
        if (auspexCountdownId) {
          clearInterval(auspexCountdownId);
          auspexCountdownId = null;
        }

        if(!res.ok){throw new Error(await res.text());}
        const json=await res.json();
        const txt=json.response||json.error||'No response';

        // Store summary if it came from a cluster request
        if (clusterId !== null) {
            window._clusterSummaries[clusterId] = txt;
            // Find and store articles for this cluster
            const memberIds = (window._clusterMemberIds || {})[clusterId] || [];
            window._clusterArticles[clusterId] = (window.lastResults || []).filter(r => memberIds.includes(r.id))
                .map(r => ({ title: r.metadata.title || 'Untitled', uri: r.metadata.uri }));

            console.log(`[askAuspex] Summary received for clusterId: ${clusterId}`);
            console.log(`[askAuspex] Stored summary: ${window._clusterSummaries[clusterId] ? 'Yes' : 'No'}`);

            // Find the specific cluster list item and add the badge directly
            const patternList = document.getElementById('patternList');
            console.log(`[askAuspex] patternList element found: ${patternList ? 'Yes' : 'No'}`);
            if (patternList) {
                const summaryButton = patternList.querySelector(`.summarize-cluster-btn[data-cluster-id="${clusterId}"]`);
                console.log(`[askAuspex] Summary button found for cluster ${clusterId}: ${summaryButton ? 'Yes' : 'No'}`);
                const clusterItem = summaryButton?.closest('.list-group-item');
                console.log(`[askAuspex] clusterItem element found: ${clusterItem ? 'Yes' : 'No'}`);
                if (clusterItem) {
                    const titleDiv = clusterItem.querySelector('.fw-bold');
                    console.log(`[askAuspex] titleDiv element found: ${titleDiv ? 'Yes' : 'No'}`);
                    if (titleDiv && !titleDiv.querySelector('.badge.bg-success-subtle')) { // Avoid adding duplicate badges
                        console.log(`[askAuspex] Adding 'Summarized' badge to cluster ${clusterId}`);
                        titleDiv.insertAdjacentHTML('beforeend', ' <span class="badge bg-success-subtle text-success-emphasis rounded-pill">Summarized</span>');
                    }
                }
            }
        }

        // Use the helper function to render the modal content
        renderAuspexModalContent(txt, window._clusterArticles[clusterId] || [], clusterId);

    }catch(err){
        auspexContent.innerHTML=`<div class="text-danger">${err}</div>`;
        exportBtn.style.display = 'none';
        // Clear intervals on error too
        if (auspexLoadingIntervalId) {
            clearInterval(auspexLoadingIntervalId);
            auspexLoadingIntervalId = null;
        }
        if (auspexCountdownId) {
            clearInterval(auspexCountdownId);
            auspexCountdownId = null;
        }
    }
}

function downloadMarkdown(filename, text) {
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

document.getElementById('exportSummaryBtn').addEventListener('click', () => {
    const modalElement = document.getElementById('auspexModal');
    const clusterId = modalElement.dataset.clusterId;
    if (clusterId === null || clusterId === undefined || clusterId === 'null') {
        console.warn('No cluster ID found for export.');
        return;
    }
    const summary = window._clusterSummaries[clusterId] || 'No summary available.';
    const articles = window._clusterArticles[clusterId] || [];

    let markdownContent = `# Cluster ${clusterId} Summary\n\n`;
    markdownContent += `${summary}\n\n`;
    markdownContent += `## Articles\n\n`;
    if (articles.length > 0) {
        articles.forEach(article => {
            markdownContent += `- [${article.title}](${article.uri})\n`;
        });
    } else {
        markdownContent += `No articles found for this cluster.\n`;
    }

    downloadMarkdown(`cluster_${clusterId}_summary.md`, markdownContent);
});

// Event delegation for cluster actions within the patterns tab
document.getElementById('patternsPane').addEventListener('click', async (e) => {
    const filterBtn = e.target.closest('.filter-cluster-btn');
    const summarizeBtn = e.target.closest('.summarize-cluster-btn');

    if (filterBtn) {
        e.preventDefault(); // Prevent potential default button actions
        const clusterId = filterBtn.dataset.clusterId;
        const input = document.getElementById('searchInput');
        let currentQuery = input.value;
        // Remove existing cluster filter (regex handles cluster:n or cluster=n)
        currentQuery = currentQuery.replace(/\bcluster(?:=|:)\d+\b/i, '').trim();
        // Add new cluster filter
        input.value = `${currentQuery} cluster=${clusterId}`.trim();
        runSearch();
        // Optionally switch back to Data Points tab
        bootstrap.Tab.getOrCreateInstance(document.querySelector('button[data-bs-target="#eventsPane"]')).show();
    }

    if (summarizeBtn) {
        const clusterId = summarizeBtn.dataset.clusterId;
        const ids = (window._clusterMemberIds || {})[clusterId] || [];

        // Check if summary already exists
        if (window._clusterSummaries && window._clusterSummaries[clusterId]) {
            console.log(`[Cluster ${clusterId}] Found existing summary. Rendering directly.`);
            const existingSummary = window._clusterSummaries[clusterId];
            const existingArticles = window._clusterArticles[clusterId] || [];
            renderAuspexModalContent(existingSummary, existingArticles, clusterId);
        } else {
            // No summary exists, proceed to fetch
            if (ids.length > 0) {
                askAuspex(ids, clusterId); // Pass IDs and clusterId
            } else {
                alert('Could not find members for this cluster.');
            }
        }
    }
});

// Helper function to render content in the Auspex modal
function renderAuspexModalContent(summaryText, articles = [], clusterId = null) {
   const auspexContent = document.getElementById('auspexContent');
   const exportBtn = document.getElementById('exportSummaryBtn');
   const modalElement = document.getElementById('auspexModal');
   modalElement.dataset.clusterId = clusterId; // Store clusterId for export

   let modalHtml = marked.parse(summaryText || 'No summary available.');

   // Add article list if provided
   if (clusterId !== null && articles && articles.length > 0) {
       modalHtml += '<hr><h6>Cluster Articles</h6><div style="max-height: 200px; overflow-y: auto; font-size: 0.9rem;">';
       articles.forEach(article => {
           modalHtml += `<div><a href="${article.uri}" target="_blank" rel="noopener">${article.title}</a></div>`;
       });
       modalHtml += '</div>';
       exportBtn.style.display = 'block'; // Show export button
   } else {
       exportBtn.style.display = 'none'; // Hide if not a cluster or no articles
   }

   auspexContent.innerHTML = modalHtml;
   // Ensure the modal is shown if not already
   const modalInstance = bootstrap.Modal.getOrCreateInstance(modalElement);
   modalInstance.show();
}

// Add listener to handle focus after modal closes (Accessibility fix)
document.getElementById('auspexModal').addEventListener('hidden.bs.modal', function () {
   // Return focus to a sensible element, e.g., the search input
   document.getElementById('searchInput')?.focus();
});

// Fetch news facts once on page load
async function fetchNewsFacts() {
   try {
       const res = await fetch('/api/news-facts');
       if (res.ok) {
           const data = await res.json();
           if (data && data.facts && Array.isArray(data.facts)) {
               window._newsFacts = data.facts;
               console.log(`Fetched ${window._newsFacts.length} news facts.`);
           } else {
               console.error('Invalid format received from /api/news-facts');
           }
       } else {
           console.error('Failed to fetch news facts:', res.status);
       }
   } catch (err) {
       console.error('Error fetching news facts:', err);
   }
}
document.addEventListener('DOMContentLoaded', fetchNewsFacts);
</script>
{% endblock %} 