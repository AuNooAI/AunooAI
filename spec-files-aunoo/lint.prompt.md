---
mode: agent
---

# AunooAI Specification Linting and Optimization

Optimize [the application specification](./main.md) for clarity, conciseness, and maintainability. Treat the English language as a programming language with consistent terminology and structure.

## Linting Objectives

### Language Consistency
- **Minimize Synonyms**: Use consistent terminology throughout
  - Use "fetch" instead of "pull/get/retrieve" for data operations
  - Use "analyze" instead of "process/evaluate/examine" for AI operations
  - Use "collect" instead of "gather/acquire/obtain" for data collection
  - Use "store" instead of "save/persist/write" for database operations
  - Use "retrieve" instead of "fetch/get/read" for database queries
  - Use "validate" instead of "check/verify/confirm" for input validation

### Structure Optimization
- **Remove Duplicate Content**: Eliminate redundant sections and information
- **Consolidate Related Information**: Group related concepts together
- **Improve Flow**: Ensure logical progression of information
- **Standardize Formatting**: Use consistent markdown formatting
- **Clarify Dependencies**: Make relationships between components explicit

### Technical Precision
- **Use Specific Terms**: Replace vague language with precise technical terms
- **Define Acronyms**: Ensure all acronyms are defined on first use
- **Standardize Naming**: Use consistent naming conventions throughout
- **Clarify Interfaces**: Make API contracts and data flows explicit
- **Specify Requirements**: Convert "should" to "must" where appropriate

## Optimization Guidelines

### Section Organization
1. **Overview**: High-level description and purpose
2. **Architecture**: System design and component relationships
3. **Database Schema**: Data models and relationships
4. **API Specification**: Endpoint definitions and contracts
5. **Implementation Details**: Technical specifications
6. **Configuration**: Environment and deployment settings
7. **Security**: Authentication, authorization, and data protection
8. **Performance**: Optimization strategies and requirements
9. **Deployment**: Infrastructure and deployment procedures

### Language Rules
- **Active Voice**: Use active voice instead of passive voice
- **Present Tense**: Use present tense for specifications
- **Imperative Mood**: Use imperative mood for requirements
- **Consistent Terminology**: Maintain the same terms throughout
- **Technical Precision**: Use precise technical language

### Content Rules
- **Single Source of Truth**: Each concept should be defined once
- **Logical Grouping**: Group related information together
- **Progressive Detail**: Start general, become more specific
- **Clear Dependencies**: Make component relationships explicit
- **Actionable Requirements**: Convert descriptions to requirements

## Specific Optimizations

### Database Schema Section
- Consolidate table descriptions
- Use consistent field naming conventions
- Group related tables together
- Standardize data type descriptions
- Clarify relationships between tables

### API Endpoints Section
- Use consistent HTTP method descriptions
- Standardize request/response format descriptions
- Group endpoints by functional area
- Use consistent parameter naming
- Clarify authentication requirements

### Architecture Section
- Clarify component responsibilities
- Standardize technology descriptions
- Group related technologies together
- Make dependencies explicit
- Use consistent architectural patterns

### Configuration Section
- Standardize environment variable descriptions
- Group related configurations together
- Use consistent naming conventions
- Clarify required vs optional settings
- Standardize default value descriptions

## Quality Checks

### Consistency Checks
- [ ] All synonyms have been replaced with standard terms
- [ ] All acronyms are defined on first use
- [ ] All naming conventions are consistent
- [ ] All formatting is standardized
- [ ] All technical terms are used consistently

### Completeness Checks
- [ ] No duplicate information exists
- [ ] All sections are properly organized
- [ ] All dependencies are clearly stated
- [ ] All requirements are actionable
- [ ] All interfaces are properly defined

### Clarity Checks
- [ ] All sentences are clear and concise
- [ ] All technical concepts are properly explained
- [ ] All relationships are explicit
- [ ] All requirements are unambiguous
- [ ] All examples are relevant and helpful

## Output Requirements

### Formatting Standards
- Use consistent markdown formatting
- Use proper heading hierarchy
- Use consistent bullet point styles
- Use consistent code block formatting
- Use consistent table formatting

### Content Standards
- Maintain all important technical details
- Preserve all functional requirements
- Keep all architectural decisions
- Maintain all security specifications
- Preserve all performance requirements

### Structure Standards
- Use logical section ordering
- Group related information together
- Use consistent section naming
- Maintain proper information hierarchy
- Use consistent cross-referencing

## Validation Criteria

The optimized specification should:

1. **Be More Readable**: Easier to understand and follow
2. **Be More Maintainable**: Easier to update and modify
3. **Be More Consistent**: Use consistent terminology and structure
4. **Be More Complete**: Include all necessary information
5. **Be More Precise**: Use specific technical language
6. **Be Better Organized**: Logical flow and grouping
7. **Be More Actionable**: Clear requirements and specifications

## Focus Areas

When optimizing, pay special attention to:

- **Terminology Consistency**: Ensure the same terms are used throughout
- **Technical Precision**: Use precise technical language
- **Structural Clarity**: Make the organization logical and clear
- **Dependency Clarity**: Make relationships between components explicit
- **Requirement Actionability**: Ensure all requirements are clear and actionable

## Success Metrics

The optimization is successful when:

1. **Consistency**: All terminology is consistent throughout
2. **Clarity**: All sections are clear and easy to understand
3. **Completeness**: All necessary information is included
4. **Organization**: Information is logically grouped and ordered
5. **Precision**: All technical terms are used correctly
6. **Maintainability**: The specification is easy to update
7. **Actionability**: All requirements are clear and implementable

## Preserve Critical Information

While optimizing, ensure to preserve:

- All technical specifications and requirements
- All architectural decisions and rationale
- All security requirements and measures
- All performance requirements and optimizations
- All deployment and configuration details
- All API contracts and data models
- All business logic and functional requirements

## Do Not Modify

Do not modify or remove:

- The core application functionality
- The database schema and relationships
- The API endpoint specifications
- The security requirements
- The performance requirements
- The deployment specifications
- The configuration requirements

Focus on improving the presentation and organization of the existing information rather than changing the underlying technical specifications.
