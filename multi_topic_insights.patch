################################################################################
# Multi-Topic Insights & Incident Tracking - Complete Patch
# Created: 2025-10-24
# 
# This patch implements full multi-topic selection support for:
# 1. Topic selector UI (dropdown with count badge)
# 2. Incident tracking across multiple topics
# 3. Article insights across all selected topics
# 4. Category insights across all selected topics
# 5. Topic badges on incident cards
#
# Features:
# - Multi-select dropdown with checkboxes
# - Topic count badge inside dropdown button
# - Colored topic badges on incident cards
# - "all_topics" mode for analyzing multiple topics together
# - Backward compatible with single-topic selection
#
# Files Modified:
# - templates/news_feed.html (frontend)
# - app/routes/vector_routes.py (backend incident tracking)
# - app/routes/dashboard_routes.py (backend article/category insights)
################################################################################

diff --git a/templates/news_feed.html b/templates/news_feed.html
index 3f075e3..523ac0e 100644
--- a/templates/news_feed.html
+++ b/templates/news_feed.html
@@ -1168,10 +1168,23 @@
                 </select>
             </div>
                         <div class="col-6">
-                            <label class="form-label small">Topic:</label>
-                            <select id="topic-select" class="form-select form-select-sm">
-                                <option value="">All Topics</option>
-                            </select>
+                            <label class="form-label small">Topics:</label>
+                            <div class="dropdown">
+                                <button class="btn btn-outline-primary btn-sm dropdown-toggle w-100 text-start d-flex justify-content-between align-items-center" type="button" id="topic-select-btn" data-bs-toggle="dropdown" aria-expanded="false" style="overflow: hidden;">
+                                    <span id="topic-select-label" class="text-truncate" style="flex: 1;">Select Topics</span>
+                                    <span id="topic-select-count" class="badge bg-primary ms-2" style="display: none;">0</span>
+                                </button>
+                                <ul class="dropdown-menu w-100" id="topic-select-dropdown" style="max-height: 300px; overflow-y: auto;">
+                                    <li><a class="dropdown-item" href="#" onclick="selectAllTopics(); return false;">
+                                        <i class="fas fa-check-double me-1"></i> Select All
+                                    </a></li>
+                                    <li><a class="dropdown-item" href="#" onclick="clearAllTopics(); return false;">
+                                        <i class="fas fa-times me-1"></i> Clear All
+                                    </a></li>
+                                    <li><hr class="dropdown-divider"></li>
+                                    <!-- Topics will be dynamically loaded here -->
+                                </ul>
+                            </div>
                         </div>
                     </div>
                     <div class="mt-2">
@@ -2634,11 +2647,11 @@ document.addEventListener('DOMContentLoaded', function() {
         `;
     }
     
-    // Populate topics dropdown and wire change handlers
+    // Populate topics multi-select dropdown with checkboxes
     try {
-        const sel = document.getElementById('topic-select');
-        if (sel) {
-            console.log('Fetching topics for news feed dropdown...');
+        const dropdown = document.getElementById('topic-select-dropdown');
+        if (dropdown) {
+            console.log('Fetching topics for multi-select dropdown...');
             fetch('/api/topics')
                 .then(r => {
                     console.log('Topics API response status:', r.status);
@@ -2646,31 +2659,63 @@ document.addEventListener('DOMContentLoaded', function() {
                 })
                 .then(topics => {
                     console.log('Topics loaded:', topics);
-                    sel.innerHTML = '<option value="">All Topics</option>' + topics.map(t => `<option value="${t.name.trim()}">${t.name.trim()}</option>`).join('');
-                    console.log('Topic dropdown populated with', topics.length, 'topics');
-                    const savedTopic = localStorage.getItem('newsFeedTopic');
-                    console.log('Saved topic from localStorage:', savedTopic);
-                    if (savedTopic && Array.from(sel.options).some(o => o.value === savedTopic)) {
-                        sel.value = savedTopic;
-                        console.log('Restored saved topic:', savedTopic);
+
+                    // Build checkbox list (keep Select All/Clear All, add topics after divider)
+                    const topicCheckboxes = topics.map(t => {
+                        const topicName = t.name.trim();
+                        return `
+                            <li>
+                                <label class="dropdown-item" style="cursor: pointer;">
+                                    <input type="checkbox" value="${escapeHtml(topicName)}" onchange="updateTopicSelectorDisplay()" class="me-2">
+                                    ${escapeHtml(topicName)}
+                                </label>
+                            </li>
+                        `;
+                    }).join('');
+
+                    // Find the divider and append topics after it
+                    const divider = dropdown.querySelector('hr.dropdown-divider');
+                    if (divider && divider.parentElement) {
+                        // Remove existing topic checkboxes (in case of reload)
+                        const existingTopics = dropdown.querySelectorAll('li:not(:has(a)), li:has(label)');
+                        existingTopics.forEach(el => {
+                            if (el !== divider.parentElement && !el.querySelector('.dropdown-divider')) {
+                                el.remove();
+                            }
+                        });
+
+                        // Insert topics after divider
+                        divider.parentElement.insertAdjacentHTML('afterend', topicCheckboxes);
+                    }
+
+                    console.log('Topic checkboxes populated with', topics.length, 'topics');
+
+                    // Restore saved topics from localStorage
+                    const savedTopicsJson = localStorage.getItem('newsFeedTopics');
+                    if (savedTopicsJson) {
+                        try {
+                            const savedTopics = JSON.parse(savedTopicsJson);
+                            console.log('Restoring saved topics:', savedTopics);
+                            if (Array.isArray(savedTopics)) {
+                                savedTopics.forEach(topic => {
+                                    const checkbox = dropdown.querySelector(`input[value="${topic}"]`);
+                                    if (checkbox) checkbox.checked = true;
+                                });
+                                updateTopicSelectorDisplay();
+                            }
+                        } catch (e) {
+                            console.error('Error parsing saved topics:', e);
+                        }
                     }
                 })
                 .catch(err => {
                     console.error('Error loading topics:', err);
                 });
-            sel.addEventListener('change', () => {
-                localStorage.setItem('newsFeedTopic', sel.value);
-                updateArticleCountForDateRange();
-                generateNewsFeed();
-
-                // Clear insights when topic changes
-                clearInsightsContent();
-            });
         } else {
-            console.error('topic-select element not found');
+            console.error('topic-select-dropdown element not found');
         }
     } catch (err) {
-        console.error('Error in topic dropdown setup:', err);
+        console.error('Error in topic multi-select setup:', err);
     }
 
     // Load saved feeds when modal is opened
@@ -7360,10 +7405,92 @@ function loadSavedDefaults() {
     return false;
 }
 
-// Get the currently selected topic from the news feed
+// Get the currently selected topic from the news feed (DEPRECATED - use getSelectedTopics())
 function getCurrentTopic() {
-    const topicSelect = document.getElementById('topic-select');
-    return topicSelect?.value || null;
+    const selected = getSelectedTopics();
+    return selected.length > 0 ? selected[0] : null;
+}
+
+// Get all selected topics as an array
+function getSelectedTopics() {
+    const checkboxes = document.querySelectorAll('#topic-select-dropdown input[type="checkbox"]:checked');
+    return Array.from(checkboxes).map(cb => cb.value);
+}
+
+// Update topic selector display with count badge inside button
+function updateTopicSelectorDisplay() {
+    const selected = getSelectedTopics();
+    const label = document.getElementById('topic-select-label');
+    const countBadge = document.getElementById('topic-select-count');
+
+    if (!label || !countBadge) return;
+
+    if (selected.length === 0) {
+        label.textContent = 'Select Topics';
+        countBadge.style.display = 'none';
+    } else if (selected.length === 1) {
+        label.textContent = selected[0];
+        countBadge.style.display = 'none';
+    } else {
+        label.textContent = `${selected.length} topics selected`;
+        countBadge.textContent = selected.length;
+        countBadge.style.display = 'inline-block';
+    }
+
+    // Update article count when topics change
+    updateDateRangeDisplay();
+}
+
+// Select all topics
+function selectAllTopics() {
+    document.querySelectorAll('#topic-select-dropdown input[type="checkbox"]').forEach(cb => cb.checked = true);
+    updateTopicSelectorDisplay();
+}
+
+// Clear all topics
+function clearAllTopics() {
+    document.querySelectorAll('#topic-select-dropdown input[type="checkbox"]').forEach(cb => cb.checked = false);
+    updateTopicSelectorDisplay();
+}
+
+// Remove specific topic from selection
+function removeTopicFromSelection(topic) {
+    const checkbox = document.querySelector(`#topic-select-dropdown input[value="${topic}"]`);
+    if (checkbox) {
+        checkbox.checked = false;
+        updateTopicSelectorDisplay();
+    }
+}
+
+// Helper: escape HTML to prevent XSS
+function escapeHtml(text) {
+    const div = document.createElement('div');
+    div.textContent = text;
+    return div.innerHTML;
+}
+
+// Get color for topic badge (consistent hashing for unknown topics)
+function getTopicColor(topic) {
+    const colors = {
+        'AI': '#3498db',
+        'Cybersecurity': '#e74c3c',
+        'Quantum': '#9b59b6',
+        'Blockchain': '#f39c12',
+        'Cloud': '#1abc9c',
+        'IoT': '#16a085',
+        'Fintech': '#27ae60',
+        'Healthtech': '#2980b9',
+        'Automation': '#8e44ad',
+        'Privacy': '#c0392b'
+    };
+    // Generate consistent color for unknown topics using hash
+    if (colors[topic]) return colors[topic];
+
+    let hash = 0;
+    for (let i = 0; i < topic.length; i++) {
+        hash = topic.charCodeAt(i) + ((hash << 5) - hash);
+    }
+    return `hsl(${Math.abs(hash) % 360}, 70%, 50%)`;
 }
 
 // Launch Auspex research for a specific theme
@@ -8741,19 +8868,41 @@ function showInsightsWelcomeMessage() {
     }
 }
 
-async function loadArticleInsights(topic, startDate, endDate, daysLimit, forceRegenerate = false) {
+async function loadArticleInsights(topics, startDate, endDate, daysLimit, forceRegenerate = false) {
+    // Handle both array and string input
+    let topic;
+    if (Array.isArray(topics)) {
+        if (topics.length === 0) {
+            console.error('[ArticleInsights] No topics provided');
+            return;
+        } else if (topics.length === 1) {
+            topic = topics[0];
+        } else {
+            // Multiple topics selected - use "all_topics" to get insights across all topics
+            topic = "all_topics";
+            console.log(`[ArticleInsights] Multiple topics selected (${topics.length}), analyzing all topics together`);
+        }
+    } else {
+        topic = topics;
+    }
+
+    if (!topic) {
+        console.error('[ArticleInsights] No topic provided');
+        return;
+    }
+
     const loadingEl = document.getElementById('article-insights-loading');
     const errorEl = document.getElementById('article-insights-error');
     const containerEl = document.getElementById('article-insights-container');
-    
+
     loadingEl.style.display = 'block';
     errorEl.style.display = 'none';
-    
+
     try {
         // Check database cache first using representative article URI
         const cacheKey = `article_insights_${topic}_${startDate || 'no_start'}_${endDate || 'no_end'}_${daysLimit}`;
         let cacheUri = null;
-        
+
         // Use the first article URI from current dataset as cache reference
         const currentArticles = window.lastArticlesData?.items || [];
         console.log('[ArticleInsights] forceRegenerate:', forceRegenerate, 'topic:', topic, 'startDate:', startDate, 'endDate:', endDate, 'daysLimit:', daysLimit);
@@ -8941,19 +9090,41 @@ async function loadArticleInsights(topic, startDate, endDate, daysLimit, forceRe
     }
 }
 
-async function loadCategoryInsights(topic, startDate, endDate, daysLimit, forceRegenerate = false) {
+async function loadCategoryInsights(topics, startDate, endDate, daysLimit, forceRegenerate = false) {
+    // Handle both array and string input
+    let topic;
+    if (Array.isArray(topics)) {
+        if (topics.length === 0) {
+            console.error('[CategoryInsights] No topics provided');
+            return;
+        } else if (topics.length === 1) {
+            topic = topics[0];
+        } else {
+            // Multiple topics selected - use "all_topics" to get insights across all topics
+            topic = "all_topics";
+            console.log(`[CategoryInsights] Multiple topics selected (${topics.length}), analyzing all topics together`);
+        }
+    } else {
+        topic = topics;
+    }
+
+    if (!topic) {
+        console.error('[CategoryInsights] No topic provided');
+        return;
+    }
+
     const loadingEl = document.getElementById('category-insights-loading');
     const errorEl = document.getElementById('category-insights-error');
     const containerEl = document.getElementById('category-insights-container');
-    
+
     loadingEl.style.display = 'block';
     errorEl.style.display = 'none';
-    
+
     try {
         // Check database cache first using representative article URI
         const cacheKey = `category_insights_${topic}_${startDate || 'no_start'}_${endDate || 'no_end'}_${daysLimit}`;
         let cacheUri = null;
-        
+
         // Use the first article URI from current dataset as cache reference
         const currentArticles = window.lastArticlesData?.items || [];
         if (currentArticles.length > 0) {
@@ -10149,17 +10320,20 @@ async function deleteSignalInstruction(instructionId) {
 
 // ===== INCIDENT TRACKING FUNCTIONS =====
 
-async function loadIncidentTracking(topic, startDate, endDate, daysLimit, forceRegenerate = false) {
+async function loadIncidentTracking(topics, startDate, endDate, daysLimit, forceRegenerate = false) {
     const loadingEl = document.getElementById('incident-tracking-loading');
     const errorEl = document.getElementById('incident-tracking-error');
     const containerEl = document.getElementById('incident-tracking-container');
-    
+
     loadingEl.style.display = 'block';
     errorEl.style.display = 'none';
 
     try {
-        if (!topic) {
-            errorEl.innerHTML = `<div class="alert alert-warning"><i class="fas fa-info-circle me-2"></i>Select a topic to track incidents.</div>`;
+        // Handle both array and string input for backward compatibility
+        const topicsArray = Array.isArray(topics) ? topics : (topics ? [topics] : []);
+
+        if (topicsArray.length === 0) {
+            errorEl.innerHTML = `<div class="alert alert-warning"><i class="fas fa-info-circle me-2"></i>Select at least one topic to track incidents.</div>`;
             errorEl.style.display = 'block';
             return;
         }
@@ -10168,13 +10342,14 @@ async function loadIncidentTracking(topic, startDate, endDate, daysLimit, forceR
         const modelSelect = document.getElementById('model-select');
         const selectedModel = modelSelect ? modelSelect.value : 'gpt-4o-mini';
 
-        // Check database cache first using representative article URI
-        const cacheKey = `incident_tracking_${topic}_${startDate || 'no_start'}_${endDate || 'no_end'}_${daysLimit || 14}`;
+        // Build cache key from sorted topics for consistent caching
+        const topicsStr = topicsArray.slice().sort().join(',');
+        const cacheKey = `incident_tracking_${topicsStr}_${startDate || 'no_start'}_${endDate || 'no_end'}_${daysLimit || 14}`;
         let cacheUri = null;
 
         // Use the first article URI from current dataset as cache reference
         const currentArticles = window.lastArticlesData?.items || [];
-        console.log('[IncidentTracking] forceRegenerate:', forceRegenerate, 'topic:', topic, 'startDate:', startDate, 'endDate:', endDate, 'daysLimit:', daysLimit);
+        console.log('[IncidentTracking] forceRegenerate:', forceRegenerate, 'topics:', topicsArray, 'startDate:', startDate, 'endDate:', endDate, 'daysLimit:', daysLimit);
         console.log('[IncidentTracking] lastArticlesData.items length:', currentArticles.length);
         if (currentArticles.length > 0) {
             cacheUri = currentArticles[0].uri; // Use first article as cache anchor
@@ -10183,7 +10358,7 @@ async function loadIncidentTracking(topic, startDate, endDate, daysLimit, forceR
 
         if (cacheUri && !forceRegenerate) {
             try {
-                const cacheCheckUrl = `/api/analysis-cache?article_uri=${encodeURIComponent(cacheUri)}&analysis_type=incident_tracking_${topic}&model=incident_analysis`;
+                const cacheCheckUrl = `/api/analysis-cache?article_uri=${encodeURIComponent(cacheUri)}&analysis_type=incident_tracking_${topicsStr}&model=incident_analysis`;
                 console.log('[IncidentTracking] Checking DB cache:', cacheCheckUrl);
                 const cacheResponse = await fetch(cacheCheckUrl);
                 console.log('[IncidentTracking] Cache response status:', cacheResponse.status);
@@ -10229,21 +10404,21 @@ async function loadIncidentTracking(topic, startDate, endDate, daysLimit, forceR
         // Get the selected organizational profile
         const profileSelect = document.getElementById('profile-select');
         const selectedProfileId = profileSelect && profileSelect.value ? parseInt(profileSelect.value) : null;
-        
+
         // Use passed parameters instead of reading from DOM
         let requestBody = {
-            topic: topic,
+            topics: topicsArray,  // Send topics array instead of single topic
             max_articles: 100,
             model: selectedModel,
             force_regenerate: forceRegenerate || false
         };
-        
+
         // Add profile_id if selected
         if (selectedProfileId) {
             requestBody.profile_id = selectedProfileId;
             console.log(`Using organizational profile ID: ${selectedProfileId} for incident tracking`);
         }
-        
+
         // Use passed date parameters
         if (startDate && endDate) {
             requestBody.start_date = startDate;
@@ -10695,19 +10870,20 @@ document.addEventListener('DOMContentLoaded', function() {
 
 async function generateInsights(forceRegenerate = false) {
     console.log('Generate insights button clicked', forceRegenerate ? '(force regenerate)' : '');
-    
-    const selectedTopic = document.getElementById('topic-select').value.trim();
-    if (!selectedTopic) {
-        showNotification('Please select a topic to generate insights', 'warning');
+
+    // Get selected topics (multi-select)
+    const selectedTopics = getSelectedTopics();
+    if (selectedTopics.length === 0) {
+        showNotification('Please select at least one topic to generate insights', 'warning');
         return;
     }
-    
+
     // Get current date range parameters
     const dateRangeValue = document.getElementById('date-range-select').value;
     let startDate = null;
     let endDate = null;
     let daysLimit = 30;
-    
+
     if (dateRangeValue === 'custom') {
         const customDate = document.getElementById('custom-date-input').value || document.getElementById('selected-date').value;
         if (customDate) {
@@ -10718,7 +10894,7 @@ async function generateInsights(forceRegenerate = false) {
         // Calculate date range based on selection
         const now = new Date();
         endDate = now.toISOString().split('T')[0];
-        
+
         switch (dateRangeValue) {
             case '24h': daysLimit = 1; break;
             case '7d': daysLimit = 7; break;
@@ -10726,21 +10902,29 @@ async function generateInsights(forceRegenerate = false) {
             case '3m': daysLimit = 90; break;
             case '1y': daysLimit = 365; break;
         }
-        
+
         const startDateObj = new Date(now.getTime() - daysLimit * 24 * 60 * 60 * 1000);
         startDate = startDateObj.toISOString().split('T')[0];
     }
-    
-    console.log('Loading insights for topic:', selectedTopic, 'date range:', startDate, 'to', endDate, 'days:', daysLimit);
-    
+
+    const topicsDisplay = selectedTopics.join(', ');
+    console.log('Loading insights for topics:', topicsDisplay, 'date range:', startDate, 'to', endDate, 'days:', daysLimit);
+
+    // Save selected topics to localStorage
+    try {
+        localStorage.setItem('newsFeedTopics', JSON.stringify(selectedTopics));
+    } catch (e) {
+        console.error('Error saving topics to localStorage:', e);
+    }
+
     // Load all insights including incident tracking
     await Promise.all([
-        loadArticleInsights(selectedTopic, startDate, endDate, daysLimit, forceRegenerate),
-        loadCategoryInsights(selectedTopic, startDate, endDate, daysLimit, forceRegenerate),
-        loadIncidentTracking(selectedTopic, startDate, endDate, daysLimit, forceRegenerate)
+        loadArticleInsights(selectedTopics, startDate, endDate, daysLimit, forceRegenerate),
+        loadCategoryInsights(selectedTopics, startDate, endDate, daysLimit, forceRegenerate),
+        loadIncidentTracking(selectedTopics, startDate, endDate, daysLimit, forceRegenerate)
     ]);
-    
-    showNotification('Insights generated successfully!', 'success');
+
+    showNotification(`Insights generated for ${selectedTopics.length} topic(s)!`, 'success');
 }
 // Add this function to your JavaScript section:
 
@@ -12084,13 +12268,21 @@ function createIndividualIncidentCard(incident, globalMin, globalMax) {
         const statusBadgeColor = status === 'seen' ? 'secondary' : 'success';
         const cardOpacity = status === 'seen' ? 'opacity-75' : '';
         
+        // Build topic badge HTML if topic is present
+        let topicBadgeHtml = '';
+        if (incident.topic) {
+            const topicColor = getTopicColor(incident.topic);
+            topicBadgeHtml = `<span class="badge me-1" style="background-color: ${topicColor}; font-size: 10px;" title="Topic">${escapeHTML(incident.topic)}</span>`;
+        }
+
         card.innerHTML = `
             <div class="d-flex justify-content-between align-items-start mb-2">
-                <div class="d-flex align-items-center gap-2">
+                <div class="d-flex align-items-center gap-2 flex-wrap">
                     <h6 class="mb-0">${escapeHTML(incident.name || 'Unnamed Incident')}</h6>
+                    ${topicBadgeHtml}
                     ${status === 'seen' ? `<span class="badge bg-${statusBadgeColor}"><i class="fas fa-eye me-1"></i>Seen</span>` : ''}
                 </div>
-                <div class="d-flex gap-1">
+                <div class="d-flex gap-1 flex-shrink-0">
                     <span class="badge bg-${typeBadgeColor}">${incident.type || 'Unknown'}</span>
                     <span class="badge bg-${significanceBadgeColor}">${incident.significance || 'Unknown'}</span>
                 </div>
@@ -14436,15 +14628,14 @@ const NewsTicker = (function() {
         try {
             const params = new URLSearchParams({
                 per_page: state.settings.count,
-                page: '1',
-                date_range: 'custom'
+                page: '1'
             });
 
-            // Add time range filter (convert hours to days for backend)
+            // Add time range filter using the date_range parameter
             if (state.settings.timeRange) {
-                const hours = parseTimeRange(state.settings.timeRange);
-                const days = Math.ceil(hours / 24);
-                params.append('days_back', days.toString());
+                params.append('date_range', state.settings.timeRange);
+            } else {
+                params.append('date_range', '7d');  // Default to 7 days
             }
 
             // Add topic filter



diff --git a/app/routes/vector_routes.py b/app/routes/vector_routes.py
index c30f191..91e5a59 100644
--- a/app/routes/vector_routes.py
+++ b/app/routes/vector_routes.py
@@ -1662,7 +1662,8 @@ async def article_insights(
 
 class _IncidentTrackingRequest(BaseModel):
     """Request for incident tracking analysis."""
-    topic: str = Field(..., description="Topic to analyze for incidents")
+    topic: Optional[str] = Field(None, description="Single topic (DEPRECATED - use topics)")
+    topics: Optional[List[str]] = Field(None, description="List of topics to analyze for incidents (max 10)")
     days_limit: int = Field(14, ge=1, le=90, description="Days back to analyze")
     start_date: Optional[str] = Field(None, description="Start date YYYY-MM-DD")
     end_date: Optional[str] = Field(None, description="End date YYYY-MM-DD")
@@ -1678,13 +1679,35 @@ class _IncidentTrackingRequest(BaseModel):
 
     @field_validator('topic')
     @classmethod
-    def sanitize_topic(cls, v: str) -> str:
+    def sanitize_topic(cls, v: Optional[str]) -> Optional[str]:
         """Sanitize topic name - strip whitespace and normalize spaces."""
         if v:
             import re
             return re.sub(r'\s+', ' ', v.strip())
         return v
 
+    @field_validator('topics')
+    @classmethod
+    def sanitize_topics(cls, v: Optional[List[str]]) -> Optional[List[str]]:
+        """Sanitize and validate topics list."""
+        if v:
+            import re
+            # Sanitize each topic
+            sanitized = [re.sub(r'\s+', ' ', topic.strip()) for topic in v if topic and topic.strip()]
+            # Enforce max limit
+            if len(sanitized) > 10:
+                raise ValueError("Maximum 10 topics allowed")
+            return sanitized if sanitized else None
+        return v
+
+    def get_topics_list(self) -> List[str]:
+        """Get topics as a list, handling backward compatibility."""
+        if self.topics:
+            return self.topics
+        elif self.topic:
+            return [self.topic]
+        return []
+
 @router.post("/incident-tracking")
 async def analyze_incidents(
     req: _IncidentTrackingRequest,
@@ -1694,13 +1717,17 @@ async def analyze_incidents(
     try:
         from app.database import get_database_instance
         db = get_database_instance()
-        
-        # Check cache first
-        cache_key = f"incident_tracking_{req.topic}_{req.start_date or 'no_start'}_{req.end_date or 'no_end'}_{req.days_limit}"
-        
+
+        # Get topics list (backward compatible)
+        topics_list = req.get_topics_list()
+
+        # Build cache key from sorted topics for consistent caching
+        topics_str = ','.join(sorted(topics_list)) if topics_list else 'all_topics'
+        cache_key = f"incident_tracking_{topics_str}_{req.start_date or 'no_start'}_{req.end_date or 'no_end'}_{req.days_limit}"
+
         # Get articles for analysis
         from datetime import datetime, timedelta
-        
+
         if req.start_date and req.end_date:
             start_date_dt = datetime.strptime(req.start_date, '%Y-%m-%d')
             end_date_dt = datetime.strptime(req.end_date, '%Y-%m-%d')
@@ -1711,7 +1738,7 @@ async def analyze_incidents(
         # Query articles - use same approach as working news feed service
         # NOTE: publication_date is TEXT, use strftime() to match database format
         query = """
-        SELECT uri, title, summary, news_source, publication_date, category, sentiment,
+        SELECT uri, title, summary, news_source, publication_date, category, sentiment, topic,
                bias, factual_reporting, mbfc_credibility_rating, bias_source
         FROM articles
         WHERE publication_date >= ? AND publication_date <= ?
@@ -1720,12 +1747,26 @@ async def analyze_incidents(
 
         # Format dates to match database TEXT format (space separator, not 'T')
         params = [start_date_dt.strftime('%Y-%m-%d'), end_date_dt.strftime('%Y-%m-%d %H:%M:%S')]
-        
-        if req.topic:
-            query += " AND (topic = ? OR title LIKE ? OR summary LIKE ?)"
-            topic_pattern = f"%{req.topic}%"
-            params.extend([req.topic, topic_pattern, topic_pattern])
-        
+
+        # Add topic filtering for single or multiple topics
+        if topics_list:
+            if len(topics_list) == 1:
+                # Single topic - use existing pattern
+                query += " AND (topic = ? OR title LIKE ? OR summary LIKE ?)"
+                topic_pattern = f"%{topics_list[0]}%"
+                params.extend([topics_list[0], topic_pattern, topic_pattern])
+            else:
+                # Multiple topics - use IN clause with LIKE fallbacks
+                topic_placeholders = ','.join(['?' for _ in topics_list])
+                like_conditions = ' OR '.join([f"title LIKE ? OR summary LIKE ?" for _ in topics_list])
+                query += f" AND (topic IN ({topic_placeholders}) OR {like_conditions})"
+                # Add exact topic matches
+                params.extend(topics_list)
+                # Add LIKE patterns for each topic
+                for topic in topics_list:
+                    topic_pattern = f"%{topic}%"
+                    params.extend([topic_pattern, topic_pattern])
+
         query += " ORDER BY publication_date DESC LIMIT ?"
         params.append(req.max_articles)
         
@@ -1735,28 +1776,29 @@ async def analyze_incidents(
             articles = req.test_articles
         else:
             articles = db.fetch_all(query, params)
-        
+
         if not articles:
-            return {"incidents": [], "message": f"No articles found for topic '{req.topic}' in date range {start_date_dt.strftime('%Y-%m-%d')} to {end_date_dt.strftime('%Y-%m-%d')}"}
-        
+            topics_display = ', '.join(topics_list) if topics_list else 'all topics'
+            return {"incidents": [], "message": f"No articles found for topics '{topics_display}' in date range {start_date_dt.strftime('%Y-%m-%d')} to {end_date_dt.strftime('%Y-%m-%d')}"}
+
         # Define cache_uri for later use
         cache_uri = articles[0]['uri'] if hasattr(articles[0], '__getitem__') else articles[0].uri
-        
+
         # Check cache using first article as anchor (unless force regenerate)
         if not req.force_regenerate:
             cached = db.get_article_analysis_cache(
                 article_uri=cache_uri,
-                analysis_type=f"incident_tracking_{req.topic}",
+                analysis_type=f"incident_tracking_{topics_str}",
                 model_used="incident_analysis"
             )
-            
+
             if cached and cached.get("metadata", {}).get("cache_key") == cache_key:
-                logger.info(f"Cache HIT: incident tracking for {req.topic}")
+                logger.info(f"Cache HIT: incident tracking for {topics_str}")
                 import json
                 return json.loads(cached["content"])
-        
+
         if req.force_regenerate:
-            logger.info(f"Force regenerating incident tracking for {req.topic} (bypassing cache)")
+            logger.info(f"Force regenerating incident tracking for {topics_str} (bypassing cache)")
         
         # Prepare articles for LLM analysis with credibility markers
         def _norm(value):
@@ -2160,28 +2202,30 @@ Extraordinary Claims Protocol:
             cache_content = json_module.dumps(result, ensure_ascii=False, default=str)
             cache_metadata = {
                 "cache_key": cache_key,
-                "topic": req.topic,
+                "topics": topics_list,
+                "topics_str": topics_str,
                 "start_date": req.start_date,
                 "end_date": req.end_date,
                 "days_limit": req.days_limit,
                 "analysis_type": "incident_tracking"
             }
-            
+
             success = db.save_article_analysis_cache(
                 article_uri=cache_uri,
-                analysis_type=f"incident_tracking_{req.topic}",
+                analysis_type=f"incident_tracking_{topics_str}",
                 content=cache_content,
                 model_used="incident_analysis",
                 metadata=cache_metadata
             )
-            
+
             if success:
-                logger.info(f"Cache SAVE: incident tracking for {req.topic}")
+                logger.info(f"Cache SAVE: incident tracking for {topics_str}")
         except Exception as cache_error:
             logger.warning(f"Failed to cache incident tracking: {cache_error}")
-        
-        # Get incident statuses and filter out deleted ones
-        incident_statuses = db.get_incident_status(req.topic)
+
+        # Get incident statuses and filter out deleted ones (use first topic for backward compatibility)
+        primary_topic = topics_list[0] if topics_list else None
+        incident_statuses = db.get_incident_status(primary_topic) if primary_topic else {}
         
         # Filter out deleted incidents and mark seen ones
         filtered_incidents = []
@@ -2204,23 +2248,37 @@ Extraordinary Claims Protocol:
                     'publication_date': a.get('publication_date'),
                     'factual_reporting': a.get('factual_reporting'),
                     'mbfc_credibility_rating': a.get('mbfc_credibility_rating'),
-                    'bias': a.get('bias')
+                    'bias': a.get('bias'),
+                    'topic': a.get('topic')  # Include topic for badge display
                 }
 
-        # Add article metadata to each incident
+        # Add article metadata and topic to each incident
         for incident in filtered_incidents:
             if incident.get('article_uris'):
                 incident['article_metadata'] = []
+                # Track topics for this incident to display badge
+                incident_topics = set()
+
                 for uri in incident['article_uris']:
                     if uri in article_metadata:
+                        metadata = article_metadata[uri]
                         incident['article_metadata'].append({
                             'uri': uri,
-                            **article_metadata[uri]
+                            **metadata
                         })
+                        # Collect topic from article
+                        if metadata.get('topic'):
+                            incident_topics.add(metadata['topic'])
                     else:
                         # Article not in current dataset, just keep URI
                         incident['article_metadata'].append({'uri': uri})
 
+                # Set the primary topic for this incident (first topic found, or primary topic)
+                if incident_topics:
+                    incident['topic'] = sorted(incident_topics)[0]  # Use first topic alphabetically for consistency
+                elif len(topics_list) == 1:
+                    incident['topic'] = topics_list[0]  # Single topic selected
+
         result = {
             "incidents": filtered_incidents,
             "total_articles": len(articles),
@@ -2234,23 +2292,24 @@ Extraordinary Claims Protocol:
             cache_content = json_module.dumps(result, ensure_ascii=False, default=str)
             cache_metadata = {
                 "cache_key": cache_key,
-                "topic": req.topic,
+                "topics": topics_list,
+                "topics_str": topics_str,
                 "start_date": req.start_date,
                 "end_date": req.end_date,
                 "days_limit": req.days_limit,
                 "analysis_type": "incident_tracking"
             }
-            
+
             success = db.save_article_analysis_cache(
                 article_uri=cache_uri,
-                analysis_type=f"incident_tracking_{req.topic}",
+                analysis_type=f"incident_tracking_{topics_str}",
                 content=cache_content,
                 model_used="incident_analysis",
                 metadata=cache_metadata
             )
-            
+
             if success:
-                logger.info(f"Cache SAVE: incident tracking for {req.topic}")
+                logger.info(f"Cache SAVE: incident tracking for {topics_str}")
         except Exception as cache_error:
             logger.warning(f"Failed to cache incident tracking: {cache_error}")
         



diff --git a/app/routes/dashboard_routes.py b/app/routes/dashboard_routes.py
index d59a8ef..39f0c26 100644
--- a/app/routes/dashboard_routes.py
+++ b/app/routes/dashboard_routes.py
@@ -258,10 +258,13 @@ async def get_topic_articles(
         # For simplicity, let's assume passing pub_date_start/end filters submission_date correctly for now.
         # We might need to check/modify db.search_articles if this assumption is wrong.
         
+        # Check if user wants all topics (multi-topic selection)
+        search_topic = None if topic_name.lower() in ['all_topics', 'all'] else topic_name
+
         # First attempt: exact topic match using publication_date to align with news feed
         articles_list_raw, total_items = await run_in_threadpool(
             db.search_articles,
-            topic=topic_name,
+            topic=search_topic,  # None = all topics, string = specific topic
             page=page,
             per_page=per_page,
             pub_date_start=start_date, # Pass date filters
@@ -272,7 +275,8 @@ async def get_topic_articles(
         )
 
         # Fallback: if too few results with exact topic, try fuzzy keyword search (title/summary)
-        if (not articles_list_raw or total_items < 3):
+        # Skip fallback if user explicitly requested all topics
+        if (not articles_list_raw or total_items < 3) and search_topic is not None:
             fallback_per_page = max(per_page, 30)
             articles_list_raw, total_items = await run_in_threadpool(
                 db.search_articles,
